"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fuse.js";
exports.ids = ["vendor-chunks/fuse.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/fuse.js/dist/fuse.mjs":
/*!********************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fuse)\n/* harmony export */ });\n/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */ function isArray(value) {\n    return !Array.isArray ? getTag(value) === \"[object Array]\" : Array.isArray(value);\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    let result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nfunction toString(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n    return value === true || value === false || isObjectLike(value) && getTag(value) == \"[object Boolean]\";\n}\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n    return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n    return !value.trim().length;\n}\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n    return value == null ? value === undefined ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n}\nconst EXTENDED_SEARCH_UNAVAILABLE = \"Extended search is not available\";\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key)=>`Invalid value for key ${key}`;\nconst PATTERN_LENGTH_TOO_LARGE = (max)=>`Pattern length exceeds max of ${max}.`;\nconst MISSING_KEY_PROPERTY = (name)=>`Missing ${name} property in key`;\nconst INVALID_KEY_WEIGHT_VALUE = (key)=>`Property 'weight' in key '${key}' must be a positive integer`;\nconst hasOwn = Object.prototype.hasOwnProperty;\nclass KeyStore {\n    constructor(keys){\n        this._keys = [];\n        this._keyMap = {};\n        let totalWeight = 0;\n        keys.forEach((key)=>{\n            let obj = createKey(key);\n            this._keys.push(obj);\n            this._keyMap[obj.id] = obj;\n            totalWeight += obj.weight;\n        });\n        // Normalize weights so that their sum is equal to 1\n        this._keys.forEach((key)=>{\n            key.weight /= totalWeight;\n        });\n    }\n    get(keyId) {\n        return this._keyMap[keyId];\n    }\n    keys() {\n        return this._keys;\n    }\n    toJSON() {\n        return JSON.stringify(this._keys);\n    }\n}\nfunction createKey(key) {\n    let path = null;\n    let id = null;\n    let src = null;\n    let weight = 1;\n    let getFn = null;\n    if (isString(key) || isArray(key)) {\n        src = key;\n        path = createKeyPath(key);\n        id = createKeyId(key);\n    } else {\n        if (!hasOwn.call(key, \"name\")) {\n            throw new Error(MISSING_KEY_PROPERTY(\"name\"));\n        }\n        const name = key.name;\n        src = name;\n        if (hasOwn.call(key, \"weight\")) {\n            weight = key.weight;\n            if (weight <= 0) {\n                throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n            }\n        }\n        path = createKeyPath(name);\n        id = createKeyId(name);\n        getFn = key.getFn;\n    }\n    return {\n        path,\n        id,\n        weight,\n        src,\n        getFn\n    };\n}\nfunction createKeyPath(key) {\n    return isArray(key) ? key : key.split(\".\");\n}\nfunction createKeyId(key) {\n    return isArray(key) ? key.join(\".\") : key;\n}\nfunction get(obj, path) {\n    let list = [];\n    let arr = false;\n    const deepGet = (obj, path, index)=>{\n        if (!isDefined(obj)) {\n            return;\n        }\n        if (!path[index]) {\n            // If there's no path left, we've arrived at the object we care about.\n            list.push(obj);\n        } else {\n            let key = path[index];\n            const value = obj[key];\n            if (!isDefined(value)) {\n                return;\n            }\n            // If we're at the last value in the path, and if it's a string/number/bool,\n            // add it to the list\n            if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n                list.push(toString(value));\n            } else if (isArray(value)) {\n                arr = true;\n                // Search each item in the array.\n                for(let i = 0, len = value.length; i < len; i += 1){\n                    deepGet(value[i], path, index + 1);\n                }\n            } else if (path.length) {\n                // An object. Recurse further.\n                deepGet(value, path, index + 1);\n            }\n        }\n    };\n    // Backwards compatibility (since path used to be a string)\n    deepGet(obj, isString(path) ? path.split(\".\") : path, 0);\n    return arr ? list : list[0];\n}\nconst MatchOptions = {\n    // Whether the matches should be included in the result set. When `true`, each record in the result\n    // set will include the indices of the matched characters.\n    // These can consequently be used for highlighting purposes.\n    includeMatches: false,\n    // When `true`, the matching function will continue to the end of a search pattern even if\n    // a perfect match has already been located in the string.\n    findAllMatches: false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1\n};\nconst BasicOptions = {\n    // When `true`, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    isCaseSensitive: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    includeScore: false,\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n    // Whether to sort the result list, by score\n    shouldSort: true,\n    // Default sort function: sort by ascending score, ascending index\n    sortFn: (a, b)=>a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1\n};\nconst FuzzyOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100\n};\nconst AdvancedOptions = {\n    // When `true`, it enables the use of unix-like search commands\n    useExtendedSearch: false,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: get,\n    // When `true`, search will ignore `location` and `distance`, so it won't matter\n    // where in the string the pattern appears.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n    ignoreLocation: false,\n    // When `true`, the calculation for the relevance score (used for sorting) will\n    // ignore the field-length norm.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n    ignoreFieldNorm: false,\n    // The weight to determine how much field length norm effects scoring.\n    fieldNormWeight: 1\n};\nvar Config = {\n    ...BasicOptions,\n    ...MatchOptions,\n    ...FuzzyOptions,\n    ...AdvancedOptions\n};\nconst SPACE = /[^ ]+/g;\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n    const cache = new Map();\n    const m = Math.pow(10, mantissa);\n    return {\n        get (value) {\n            const numTokens = value.match(SPACE).length;\n            if (cache.has(numTokens)) {\n                return cache.get(numTokens);\n            }\n            // Default function is 1/sqrt(x), weight makes that variable\n            const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n            // In place of `toFixed(mantissa)`, for faster computation\n            const n = parseFloat(Math.round(norm * m) / m);\n            cache.set(numTokens, n);\n            return n;\n        },\n        clear () {\n            cache.clear();\n        }\n    };\n}\nclass FuseIndex {\n    constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}){\n        this.norm = norm(fieldNormWeight, 3);\n        this.getFn = getFn;\n        this.isCreated = false;\n        this.setIndexRecords();\n    }\n    setSources(docs = []) {\n        this.docs = docs;\n    }\n    setIndexRecords(records = []) {\n        this.records = records;\n    }\n    setKeys(keys = []) {\n        this.keys = keys;\n        this._keysMap = {};\n        keys.forEach((key, idx)=>{\n            this._keysMap[key.id] = idx;\n        });\n    }\n    create() {\n        if (this.isCreated || !this.docs.length) {\n            return;\n        }\n        this.isCreated = true;\n        // List is Array<String>\n        if (isString(this.docs[0])) {\n            this.docs.forEach((doc, docIndex)=>{\n                this._addString(doc, docIndex);\n            });\n        } else {\n            // List is Array<Object>\n            this.docs.forEach((doc, docIndex)=>{\n                this._addObject(doc, docIndex);\n            });\n        }\n        this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n    add(doc) {\n        const idx = this.size();\n        if (isString(doc)) {\n            this._addString(doc, idx);\n        } else {\n            this._addObject(doc, idx);\n        }\n    }\n    // Removes the doc at the specified index of the index\n    removeAt(idx) {\n        this.records.splice(idx, 1);\n        // Change ref index of every subsquent doc\n        for(let i = idx, len = this.size(); i < len; i += 1){\n            this.records[i].i -= 1;\n        }\n    }\n    getValueForItemAtKeyId(item, keyId) {\n        return item[this._keysMap[keyId]];\n    }\n    size() {\n        return this.records.length;\n    }\n    _addString(doc, docIndex) {\n        if (!isDefined(doc) || isBlank(doc)) {\n            return;\n        }\n        let record = {\n            v: doc,\n            i: docIndex,\n            n: this.norm.get(doc)\n        };\n        this.records.push(record);\n    }\n    _addObject(doc, docIndex) {\n        let record = {\n            i: docIndex,\n            $: {}\n        };\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        this.keys.forEach((key, keyIndex)=>{\n            let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n            if (!isDefined(value)) {\n                return;\n            }\n            if (isArray(value)) {\n                let subRecords = [];\n                const stack = [\n                    {\n                        nestedArrIndex: -1,\n                        value\n                    }\n                ];\n                while(stack.length){\n                    const { nestedArrIndex, value } = stack.pop();\n                    if (!isDefined(value)) {\n                        continue;\n                    }\n                    if (isString(value) && !isBlank(value)) {\n                        let subRecord = {\n                            v: value,\n                            i: nestedArrIndex,\n                            n: this.norm.get(value)\n                        };\n                        subRecords.push(subRecord);\n                    } else if (isArray(value)) {\n                        value.forEach((item, k)=>{\n                            stack.push({\n                                nestedArrIndex: k,\n                                value: item\n                            });\n                        });\n                    } else ;\n                }\n                record.$[keyIndex] = subRecords;\n            } else if (isString(value) && !isBlank(value)) {\n                let subRecord = {\n                    v: value,\n                    n: this.norm.get(value)\n                };\n                record.$[keyIndex] = subRecord;\n            }\n        });\n        this.records.push(record);\n    }\n    toJSON() {\n        return {\n            keys: this.keys,\n            records: this.records\n        };\n    }\n}\nfunction createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys.map(createKey));\n    myIndex.setSources(docs);\n    myIndex.create();\n    return myIndex;\n}\nfunction parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const { keys, records } = data;\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys);\n    myIndex.setIndexRecords(records);\n    return myIndex;\n}\nfunction computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {\n    const accuracy = errors / pattern.length;\n    if (ignoreLocation) {\n        return accuracy;\n    }\n    const proximity = Math.abs(expectedLocation - currentLocation);\n    if (!distance) {\n        // Dodge divide by zero error.\n        return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + proximity / distance;\n}\nfunction convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n    let indices = [];\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(let len = matchmask.length; i < len; i += 1){\n        let match = matchmask[i];\n        if (match && start === -1) {\n            start = i;\n        } else if (!match && start !== -1) {\n            end = i - 1;\n            if (end - start + 1 >= minMatchCharLength) {\n                indices.push([\n                    start,\n                    end\n                ]);\n            }\n            start = -1;\n        }\n    }\n    // (i-1 - start) + 1 => i - start\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n        indices.push([\n            start,\n            i - 1\n        ]);\n    }\n    return indices;\n}\n// Machine word size\nconst MAX_BITS = 32;\nfunction search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {\n    if (pattern.length > MAX_BITS) {\n        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n    }\n    const patternLen = pattern.length;\n    // Set starting location at beginning text and initialize the alphabet.\n    const textLen = text.length;\n    // Handle the case when location > text.length\n    const expectedLocation = Math.max(0, Math.min(location, textLen));\n    // Highest score beyond which we give up.\n    let currentThreshold = threshold;\n    // Is there a nearby exact match? (speedup)\n    let bestLocation = expectedLocation;\n    // Performance: only computer matches when the minMatchCharLength > 1\n    // OR if `includeMatches` is true.\n    const computeMatches = minMatchCharLength > 1 || includeMatches;\n    // A mask of the matches, used for building the indices\n    const matchMask = computeMatches ? Array(textLen) : [];\n    let index;\n    // Get all exact matches, here for speed up\n    while((index = text.indexOf(pattern, bestLocation)) > -1){\n        let score = computeScore$1(pattern, {\n            currentLocation: index,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        currentThreshold = Math.min(score, currentThreshold);\n        bestLocation = index + patternLen;\n        if (computeMatches) {\n            let i = 0;\n            while(i < patternLen){\n                matchMask[index + i] = 1;\n                i += 1;\n            }\n        }\n    }\n    // Reset the best location\n    bestLocation = -1;\n    let lastBitArr = [];\n    let finalScore = 1;\n    let binMax = patternLen + textLen;\n    const mask = 1 << patternLen - 1;\n    for(let i = 0; i < patternLen; i += 1){\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from the match location we can stray\n        // at this error level.\n        let binMin = 0;\n        let binMid = binMax;\n        while(binMin < binMid){\n            const score = computeScore$1(pattern, {\n                errors: i,\n                currentLocation: expectedLocation + binMid,\n                expectedLocation,\n                distance,\n                ignoreLocation\n            });\n            if (score <= currentThreshold) {\n                binMin = binMid;\n            } else {\n                binMax = binMid;\n            }\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        binMax = binMid;\n        let start = Math.max(1, expectedLocation - binMid + 1);\n        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n        // Initialize the bit array\n        let bitArr = Array(finish + 2);\n        bitArr[finish + 1] = (1 << i) - 1;\n        for(let j = finish; j >= start; j -= 1){\n            let currentLocation = j - 1;\n            let charMatch = patternAlphabet[text.charAt(currentLocation)];\n            if (computeMatches) {\n                // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n                matchMask[currentLocation] = +!!charMatch;\n            }\n            // First pass: exact match\n            bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n            // Subsequent passes: fuzzy match\n            if (i) {\n                bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n            }\n            if (bitArr[j] & mask) {\n                finalScore = computeScore$1(pattern, {\n                    errors: i,\n                    currentLocation,\n                    expectedLocation,\n                    distance,\n                    ignoreLocation\n                });\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (finalScore <= currentThreshold) {\n                    // Indeed it is\n                    currentThreshold = finalScore;\n                    bestLocation = currentLocation;\n                    // Already passed `loc`, downhill from here on in.\n                    if (bestLocation <= expectedLocation) {\n                        break;\n                    }\n                    // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n                    start = Math.max(1, 2 * expectedLocation - bestLocation);\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        const score = computeScore$1(pattern, {\n            errors: i + 1,\n            currentLocation: expectedLocation,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        if (score > currentThreshold) {\n            break;\n        }\n        lastBitArr = bitArr;\n    }\n    const result = {\n        isMatch: bestLocation >= 0,\n        // Count exact matches (those with a score of 0) to be \"almost\" exact\n        score: Math.max(0.001, finalScore)\n    };\n    if (computeMatches) {\n        const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n        if (!indices.length) {\n            result.isMatch = false;\n        } else if (includeMatches) {\n            result.indices = indices;\n        }\n    }\n    return result;\n}\nfunction createPatternAlphabet(pattern) {\n    let mask = {};\n    for(let i = 0, len = pattern.length; i < len; i += 1){\n        const char = pattern.charAt(i);\n        mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n    }\n    return mask;\n}\nclass BitapSearch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        this.options = {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.chunks = [];\n        if (!this.pattern.length) {\n            return;\n        }\n        const addChunk = (pattern, startIndex)=>{\n            this.chunks.push({\n                pattern,\n                alphabet: createPatternAlphabet(pattern),\n                startIndex\n            });\n        };\n        const len = this.pattern.length;\n        if (len > MAX_BITS) {\n            let i = 0;\n            const remainder = len % MAX_BITS;\n            const end = len - remainder;\n            while(i < end){\n                addChunk(this.pattern.substr(i, MAX_BITS), i);\n                i += MAX_BITS;\n            }\n            if (remainder) {\n                const startIndex = len - MAX_BITS;\n                addChunk(this.pattern.substr(startIndex), startIndex);\n            }\n        } else {\n            addChunk(this.pattern, 0);\n        }\n    }\n    searchIn(text) {\n        const { isCaseSensitive, includeMatches } = this.options;\n        if (!isCaseSensitive) {\n            text = text.toLowerCase();\n        }\n        // Exact match\n        if (this.pattern === text) {\n            let result = {\n                isMatch: true,\n                score: 0\n            };\n            if (includeMatches) {\n                result.indices = [\n                    [\n                        0,\n                        text.length - 1\n                    ]\n                ];\n            }\n            return result;\n        }\n        // Otherwise, use Bitap algorithm\n        const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;\n        let allIndices = [];\n        let totalScore = 0;\n        let hasMatches = false;\n        this.chunks.forEach(({ pattern, alphabet, startIndex })=>{\n            const { isMatch, score, indices } = search(text, pattern, alphabet, {\n                location: location + startIndex,\n                distance,\n                threshold,\n                findAllMatches,\n                minMatchCharLength,\n                includeMatches,\n                ignoreLocation\n            });\n            if (isMatch) {\n                hasMatches = true;\n            }\n            totalScore += score;\n            if (isMatch && indices) {\n                allIndices = [\n                    ...allIndices,\n                    ...indices\n                ];\n            }\n        });\n        let result = {\n            isMatch: hasMatches,\n            score: hasMatches ? totalScore / this.chunks.length : 1\n        };\n        if (hasMatches && includeMatches) {\n            result.indices = allIndices;\n        }\n        return result;\n    }\n}\nclass BaseMatch {\n    constructor(pattern){\n        this.pattern = pattern;\n    }\n    static isMultiMatch(pattern) {\n        return getMatch(pattern, this.multiRegex);\n    }\n    static isSingleMatch(pattern) {\n        return getMatch(pattern, this.singleRegex);\n    }\n    search() {}\n}\nfunction getMatch(pattern, exp) {\n    const matches = pattern.match(exp);\n    return matches ? matches[1] : null;\n}\n// Token: 'file\nclass ExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"exact\";\n    }\n    static get multiRegex() {\n        return /^=\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^=(.*)$/;\n    }\n    search(text) {\n        const isMatch = text === this.pattern;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !fire\nclass InverseExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)$/;\n    }\n    search(text) {\n        const index = text.indexOf(this.pattern);\n        const isMatch = index === -1;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: ^file\nclass PrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !^fire\nclass InversePrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = !text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: .file$\nclass SuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                text.length - this.pattern.length,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: !.file$\nclass InverseSuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = !text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\nclass FuzzyMatch extends BaseMatch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        super(pattern);\n        this._bitapSearch = new BitapSearch(pattern, {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        });\n    }\n    static get type() {\n        return \"fuzzy\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^(.*)$/;\n    }\n    search(text) {\n        return this._bitapSearch.searchIn(text);\n    }\n}\n// Token: 'file\nclass IncludeMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"include\";\n    }\n    static get multiRegex() {\n        return /^'\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^'(.*)$/;\n    }\n    search(text) {\n        let location = 0;\n        let index;\n        const indices = [];\n        const patternLen = this.pattern.length;\n        // Get all exact matches\n        while((index = text.indexOf(this.pattern, location)) > -1){\n            location = index + patternLen;\n            indices.push([\n                index,\n                location - 1\n            ]);\n        }\n        const isMatch = !!indices.length;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices\n        };\n    }\n}\n// â—Order is important. DO NOT CHANGE.\nconst searchers = [\n    ExactMatch,\n    IncludeMatch,\n    PrefixExactMatch,\n    InversePrefixExactMatch,\n    InverseSuffixExactMatch,\n    SuffixExactMatch,\n    InverseExactMatch,\n    FuzzyMatch\n];\nconst searchersLen = searchers.length;\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = \"|\";\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n    return pattern.split(OR_TOKEN).map((item)=>{\n        let query = item.trim().split(SPACE_RE).filter((item)=>item && !!item.trim());\n        let results = [];\n        for(let i = 0, len = query.length; i < len; i += 1){\n            const queryItem = query[i];\n            // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n            let found = false;\n            let idx = -1;\n            while(!found && ++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isMultiMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    found = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n            // 2. Handle single query matches (i.e, once that are *not* quoted)\n            idx = -1;\n            while(++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isSingleMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    break;\n                }\n            }\n        }\n        return results;\n    });\n}\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([\n    FuzzyMatch.type,\n    IncludeMatch.type\n]);\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */ class ExtendedSearch {\n    constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}){\n        this.query = null;\n        this.options = {\n            isCaseSensitive,\n            includeMatches,\n            minMatchCharLength,\n            findAllMatches,\n            ignoreLocation,\n            location,\n            threshold,\n            distance\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.query = parseQuery(this.pattern, this.options);\n    }\n    static condition(_, options) {\n        return options.useExtendedSearch;\n    }\n    searchIn(text) {\n        const query = this.query;\n        if (!query) {\n            return {\n                isMatch: false,\n                score: 1\n            };\n        }\n        const { includeMatches, isCaseSensitive } = this.options;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        let numMatches = 0;\n        let allIndices = [];\n        let totalScore = 0;\n        // ORs\n        for(let i = 0, qLen = query.length; i < qLen; i += 1){\n            const searchers = query[i];\n            // Reset indices\n            allIndices.length = 0;\n            numMatches = 0;\n            // ANDs\n            for(let j = 0, pLen = searchers.length; j < pLen; j += 1){\n                const searcher = searchers[j];\n                const { isMatch, indices, score } = searcher.search(text);\n                if (isMatch) {\n                    numMatches += 1;\n                    totalScore += score;\n                    if (includeMatches) {\n                        const type = searcher.constructor.type;\n                        if (MultiMatchSet.has(type)) {\n                            allIndices = [\n                                ...allIndices,\n                                ...indices\n                            ];\n                        } else {\n                            allIndices.push(indices);\n                        }\n                    }\n                } else {\n                    totalScore = 0;\n                    numMatches = 0;\n                    allIndices.length = 0;\n                    break;\n                }\n            }\n            // OR condition, so if TRUE, return\n            if (numMatches) {\n                let result = {\n                    isMatch: true,\n                    score: totalScore / numMatches\n                };\n                if (includeMatches) {\n                    result.indices = allIndices;\n                }\n                return result;\n            }\n        }\n        // Nothing was matched\n        return {\n            isMatch: false,\n            score: 1\n        };\n    }\n}\nconst registeredSearchers = [];\nfunction register(...args) {\n    registeredSearchers.push(...args);\n}\nfunction createSearcher(pattern, options) {\n    for(let i = 0, len = registeredSearchers.length; i < len; i += 1){\n        let searcherClass = registeredSearchers[i];\n        if (searcherClass.condition(pattern, options)) {\n            return new searcherClass(pattern, options);\n        }\n    }\n    return new BitapSearch(pattern, options);\n}\nconst LogicalOperator = {\n    AND: \"$and\",\n    OR: \"$or\"\n};\nconst KeyType = {\n    PATH: \"$path\",\n    PATTERN: \"$val\"\n};\nconst isExpression = (query)=>!!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\nconst isPath = (query)=>!!query[KeyType.PATH];\nconst isLeaf = (query)=>!isArray(query) && isObject(query) && !isExpression(query);\nconst convertToExplicit = (query)=>({\n        [LogicalOperator.AND]: Object.keys(query).map((key)=>({\n                [key]: query[key]\n            }))\n    });\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n    const next = (query)=>{\n        let keys = Object.keys(query);\n        const isQueryPath = isPath(query);\n        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n            return next(convertToExplicit(query));\n        }\n        if (isLeaf(query)) {\n            const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n            const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n            if (!isString(pattern)) {\n                throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n            }\n            const obj = {\n                keyId: createKeyId(key),\n                pattern\n            };\n            if (auto) {\n                obj.searcher = createSearcher(pattern, options);\n            }\n            return obj;\n        }\n        let node = {\n            children: [],\n            operator: keys[0]\n        };\n        keys.forEach((key)=>{\n            const value = query[key];\n            if (isArray(value)) {\n                value.forEach((item)=>{\n                    node.children.push(next(item));\n                });\n            }\n        });\n        return node;\n    };\n    if (!isExpression(query)) {\n        query = convertToExplicit(query);\n    }\n    return next(query);\n}\n// Practical scoring function\nfunction computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {\n    results.forEach((result)=>{\n        let totalScore = 1;\n        result.matches.forEach(({ key, norm, score })=>{\n            const weight = key ? key.weight : null;\n            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n        });\n        result.score = totalScore;\n    });\n}\nfunction transformMatches(result, data) {\n    const matches = result.matches;\n    data.matches = [];\n    if (!isDefined(matches)) {\n        return;\n    }\n    matches.forEach((match)=>{\n        if (!isDefined(match.indices) || !match.indices.length) {\n            return;\n        }\n        const { indices, value } = match;\n        let obj = {\n            indices,\n            value\n        };\n        if (match.key) {\n            obj.key = match.key.src;\n        }\n        if (match.idx > -1) {\n            obj.refIndex = match.idx;\n        }\n        data.matches.push(obj);\n    });\n}\nfunction transformScore(result, data) {\n    data.score = result.score;\n}\nfunction format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {\n    const transformers = [];\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n    return results.map((result)=>{\n        const { idx } = result;\n        const data = {\n            item: docs[idx],\n            refIndex: idx\n        };\n        if (transformers.length) {\n            transformers.forEach((transformer)=>{\n                transformer(result, data);\n            });\n        }\n        return data;\n    });\n}\nclass Fuse {\n    constructor(docs, options = {}, index){\n        this.options = {\n            ...Config,\n            ...options\n        };\n        if (this.options.useExtendedSearch && !true) {}\n        this._keyStore = new KeyStore(this.options.keys);\n        this.setCollection(docs, index);\n    }\n    setCollection(docs, index) {\n        this._docs = docs;\n        if (index && !(index instanceof FuseIndex)) {\n            throw new Error(INCORRECT_INDEX_TYPE);\n        }\n        this._myIndex = index || createIndex(this.options.keys, this._docs, {\n            getFn: this.options.getFn,\n            fieldNormWeight: this.options.fieldNormWeight\n        });\n    }\n    add(doc) {\n        if (!isDefined(doc)) {\n            return;\n        }\n        this._docs.push(doc);\n        this._myIndex.add(doc);\n    }\n    remove(predicate = ()=>false) {\n        const results = [];\n        for(let i = 0, len = this._docs.length; i < len; i += 1){\n            const doc = this._docs[i];\n            if (predicate(doc, i)) {\n                this.removeAt(i);\n                i -= 1;\n                len -= 1;\n                results.push(doc);\n            }\n        }\n        return results;\n    }\n    removeAt(idx) {\n        this._docs.splice(idx, 1);\n        this._myIndex.removeAt(idx);\n    }\n    getIndex() {\n        return this._myIndex;\n    }\n    search(query, { limit = -1 } = {}) {\n        const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;\n        let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n        computeScore(results, {\n            ignoreFieldNorm\n        });\n        if (shouldSort) {\n            results.sort(sortFn);\n        }\n        if (isNumber(limit) && limit > -1) {\n            results = results.slice(0, limit);\n        }\n        return format(results, this._docs, {\n            includeMatches,\n            includeScore\n        });\n    }\n    _searchStringList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { records } = this._myIndex;\n        const results = [];\n        // Iterate over every string in the index\n        records.forEach(({ v: text, i: idx, n: norm })=>{\n            if (!isDefined(text)) {\n                return;\n            }\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                results.push({\n                    item: text,\n                    idx,\n                    matches: [\n                        {\n                            score,\n                            value: text,\n                            norm,\n                            indices\n                        }\n                    ]\n                });\n            }\n        });\n        return results;\n    }\n    _searchLogical(query) {\n        const expression = parse(query, this.options);\n        const evaluate = (node, item, idx)=>{\n            if (!node.children) {\n                const { keyId, searcher } = node;\n                const matches = this._findMatches({\n                    key: this._keyStore.get(keyId),\n                    value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n                    searcher\n                });\n                if (matches && matches.length) {\n                    return [\n                        {\n                            idx,\n                            item,\n                            matches\n                        }\n                    ];\n                }\n                return [];\n            }\n            const res = [];\n            for(let i = 0, len = node.children.length; i < len; i += 1){\n                const child = node.children[i];\n                const result = evaluate(child, item, idx);\n                if (result.length) {\n                    res.push(...result);\n                } else if (node.operator === LogicalOperator.AND) {\n                    return [];\n                }\n            }\n            return res;\n        };\n        const records = this._myIndex.records;\n        const resultMap = {};\n        const results = [];\n        records.forEach(({ $: item, i: idx })=>{\n            if (isDefined(item)) {\n                let expResults = evaluate(expression, item, idx);\n                if (expResults.length) {\n                    // Dedupe when adding\n                    if (!resultMap[idx]) {\n                        resultMap[idx] = {\n                            idx,\n                            item,\n                            matches: []\n                        };\n                        results.push(resultMap[idx]);\n                    }\n                    expResults.forEach(({ matches })=>{\n                        resultMap[idx].matches.push(...matches);\n                    });\n                }\n            }\n        });\n        return results;\n    }\n    _searchObjectList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { keys, records } = this._myIndex;\n        const results = [];\n        // List is Array<Object>\n        records.forEach(({ $: item, i: idx })=>{\n            if (!isDefined(item)) {\n                return;\n            }\n            let matches = [];\n            // Iterate over every key (i.e, path), and fetch the value at that key\n            keys.forEach((key, keyIndex)=>{\n                matches.push(...this._findMatches({\n                    key,\n                    value: item[keyIndex],\n                    searcher\n                }));\n            });\n            if (matches.length) {\n                results.push({\n                    idx,\n                    item,\n                    matches\n                });\n            }\n        });\n        return results;\n    }\n    _findMatches({ key, value, searcher }) {\n        if (!isDefined(value)) {\n            return [];\n        }\n        let matches = [];\n        if (isArray(value)) {\n            value.forEach(({ v: text, i: idx, n: norm })=>{\n                if (!isDefined(text)) {\n                    return;\n                }\n                const { isMatch, score, indices } = searcher.searchIn(text);\n                if (isMatch) {\n                    matches.push({\n                        score,\n                        key,\n                        value: text,\n                        idx,\n                        norm,\n                        indices\n                    });\n                }\n            });\n        } else {\n            const { v: text, n: norm } = value;\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                matches.push({\n                    score,\n                    key,\n                    value: text,\n                    norm,\n                    indices\n                });\n            }\n        }\n        return matches;\n    }\n}\nFuse.version = \"7.0.0\";\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n    Fuse.parseQuery = parse;\n}{\n    register(ExtendedSearch);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBRUQsU0FBU0EsUUFBUUMsS0FBSztJQUNwQixPQUFPLENBQUNDLE1BQU1GLE9BQU8sR0FDakJHLE9BQU9GLFdBQVcsbUJBQ2xCQyxNQUFNRixPQUFPLENBQUNDO0FBQ3BCO0FBRUEsdUZBQXVGO0FBQ3ZGLE1BQU1HLFdBQVcsSUFBSTtBQUNyQixTQUFTQyxhQUFhSixLQUFLO0lBQ3pCLDBFQUEwRTtJQUMxRSxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSUssU0FBU0wsUUFBUTtJQUNyQixPQUFPSyxVQUFVLE9BQU8sSUFBSUwsU0FBUyxDQUFDRyxXQUFXLE9BQU9FO0FBQzFEO0FBRUEsU0FBU0MsU0FBU04sS0FBSztJQUNyQixPQUFPQSxTQUFTLE9BQU8sS0FBS0ksYUFBYUo7QUFDM0M7QUFFQSxTQUFTTyxTQUFTUCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLFNBQVNRLFNBQVNSLEtBQUs7SUFDckIsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBRUEsMEVBQTBFO0FBQzFFLFNBQVNTLFVBQVVULEtBQUs7SUFDdEIsT0FDRUEsVUFBVSxRQUNWQSxVQUFVLFNBQ1RVLGFBQWFWLFVBQVVFLE9BQU9GLFVBQVU7QUFFN0M7QUFFQSxTQUFTVyxTQUFTWCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLG9DQUFvQztBQUNwQyxTQUFTVSxhQUFhVixLQUFLO0lBQ3pCLE9BQU9XLFNBQVNYLFVBQVVBLFVBQVU7QUFDdEM7QUFFQSxTQUFTWSxVQUFVWixLQUFLO0lBQ3RCLE9BQU9BLFVBQVVhLGFBQWFiLFVBQVU7QUFDMUM7QUFFQSxTQUFTYyxRQUFRZCxLQUFLO0lBQ3BCLE9BQU8sQ0FBQ0EsTUFBTWUsSUFBSSxHQUFHQyxNQUFNO0FBQzdCO0FBRUEscUNBQXFDO0FBQ3JDLGlGQUFpRjtBQUNqRixTQUFTZCxPQUFPRixLQUFLO0lBQ25CLE9BQU9BLFNBQVMsT0FDWkEsVUFBVWEsWUFDUix1QkFDQSxrQkFDRkksT0FBT0MsU0FBUyxDQUFDWixRQUFRLENBQUNhLElBQUksQ0FBQ25CO0FBQ3JDO0FBRUEsTUFBTW9CLDhCQUE4QjtBQUVwQyxNQUFNQyx1QkFBdUI7QUFFN0IsTUFBTUMsdUNBQXVDLENBQUNDLE1BQzVDLENBQUMsc0JBQXNCLEVBQUVBLElBQUksQ0FBQztBQUVoQyxNQUFNQywyQkFBMkIsQ0FBQ0MsTUFDaEMsQ0FBQyw4QkFBOEIsRUFBRUEsSUFBSSxDQUFDLENBQUM7QUFFekMsTUFBTUMsdUJBQXVCLENBQUNDLE9BQVMsQ0FBQyxRQUFRLEVBQUVBLEtBQUssZ0JBQWdCLENBQUM7QUFFeEUsTUFBTUMsMkJBQTJCLENBQUNMLE1BQ2hDLENBQUMsMEJBQTBCLEVBQUVBLElBQUksNEJBQTRCLENBQUM7QUFFaEUsTUFBTU0sU0FBU1osT0FBT0MsU0FBUyxDQUFDWSxjQUFjO0FBRTlDLE1BQU1DO0lBQ0pDLFlBQVlDLElBQUksQ0FBRTtRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQztRQUVoQixJQUFJQyxjQUFjO1FBRWxCSCxLQUFLSSxPQUFPLENBQUMsQ0FBQ2Q7WUFDWixJQUFJZSxNQUFNQyxVQUFVaEI7WUFFcEIsSUFBSSxDQUFDVyxLQUFLLENBQUNNLElBQUksQ0FBQ0Y7WUFDaEIsSUFBSSxDQUFDSCxPQUFPLENBQUNHLElBQUlHLEVBQUUsQ0FBQyxHQUFHSDtZQUV2QkYsZUFBZUUsSUFBSUksTUFBTTtRQUMzQjtRQUVBLG9EQUFvRDtRQUNwRCxJQUFJLENBQUNSLEtBQUssQ0FBQ0csT0FBTyxDQUFDLENBQUNkO1lBQ2xCQSxJQUFJbUIsTUFBTSxJQUFJTjtRQUNoQjtJQUNGO0lBQ0FPLElBQUlDLEtBQUssRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDVCxPQUFPLENBQUNTLE1BQU07SUFDNUI7SUFDQVgsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDQyxLQUFLO0lBQ25CO0lBQ0FXLFNBQVM7UUFDUCxPQUFPQyxLQUFLQyxTQUFTLENBQUMsSUFBSSxDQUFDYixLQUFLO0lBQ2xDO0FBQ0Y7QUFFQSxTQUFTSyxVQUFVaEIsR0FBRztJQUNwQixJQUFJeUIsT0FBTztJQUNYLElBQUlQLEtBQUs7SUFDVCxJQUFJUSxNQUFNO0lBQ1YsSUFBSVAsU0FBUztJQUNiLElBQUlRLFFBQVE7SUFFWixJQUFJM0MsU0FBU2dCLFFBQVF4QixRQUFRd0IsTUFBTTtRQUNqQzBCLE1BQU0xQjtRQUNOeUIsT0FBT0csY0FBYzVCO1FBQ3JCa0IsS0FBS1csWUFBWTdCO0lBQ25CLE9BQU87UUFDTCxJQUFJLENBQUNNLE9BQU9WLElBQUksQ0FBQ0ksS0FBSyxTQUFTO1lBQzdCLE1BQU0sSUFBSThCLE1BQU0zQixxQkFBcUI7UUFDdkM7UUFFQSxNQUFNQyxPQUFPSixJQUFJSSxJQUFJO1FBQ3JCc0IsTUFBTXRCO1FBRU4sSUFBSUUsT0FBT1YsSUFBSSxDQUFDSSxLQUFLLFdBQVc7WUFDOUJtQixTQUFTbkIsSUFBSW1CLE1BQU07WUFFbkIsSUFBSUEsVUFBVSxHQUFHO2dCQUNmLE1BQU0sSUFBSVcsTUFBTXpCLHlCQUF5QkQ7WUFDM0M7UUFDRjtRQUVBcUIsT0FBT0csY0FBY3hCO1FBQ3JCYyxLQUFLVyxZQUFZekI7UUFDakJ1QixRQUFRM0IsSUFBSTJCLEtBQUs7SUFDbkI7SUFFQSxPQUFPO1FBQUVGO1FBQU1QO1FBQUlDO1FBQVFPO1FBQUtDO0lBQU07QUFDeEM7QUFFQSxTQUFTQyxjQUFjNUIsR0FBRztJQUN4QixPQUFPeEIsUUFBUXdCLE9BQU9BLE1BQU1BLElBQUkrQixLQUFLLENBQUM7QUFDeEM7QUFFQSxTQUFTRixZQUFZN0IsR0FBRztJQUN0QixPQUFPeEIsUUFBUXdCLE9BQU9BLElBQUlnQyxJQUFJLENBQUMsT0FBT2hDO0FBQ3hDO0FBRUEsU0FBU29CLElBQUlMLEdBQUcsRUFBRVUsSUFBSTtJQUNwQixJQUFJUSxPQUFPLEVBQUU7SUFDYixJQUFJQyxNQUFNO0lBRVYsTUFBTUMsVUFBVSxDQUFDcEIsS0FBS1UsTUFBTVc7UUFDMUIsSUFBSSxDQUFDL0MsVUFBVTBCLE1BQU07WUFDbkI7UUFDRjtRQUNBLElBQUksQ0FBQ1UsSUFBSSxDQUFDVyxNQUFNLEVBQUU7WUFDaEIsc0VBQXNFO1lBQ3RFSCxLQUFLaEIsSUFBSSxDQUFDRjtRQUNaLE9BQU87WUFDTCxJQUFJZixNQUFNeUIsSUFBSSxDQUFDVyxNQUFNO1lBRXJCLE1BQU0zRCxRQUFRc0MsR0FBRyxDQUFDZixJQUFJO1lBRXRCLElBQUksQ0FBQ1gsVUFBVVosUUFBUTtnQkFDckI7WUFDRjtZQUVBLDRFQUE0RTtZQUM1RSxxQkFBcUI7WUFDckIsSUFDRTJELFVBQVVYLEtBQUtoQyxNQUFNLEdBQUcsS0FDdkJULENBQUFBLFNBQVNQLFVBQVVRLFNBQVNSLFVBQVVTLFVBQVVULE1BQUssR0FDdEQ7Z0JBQ0F3RCxLQUFLaEIsSUFBSSxDQUFDbEMsU0FBU047WUFDckIsT0FBTyxJQUFJRCxRQUFRQyxRQUFRO2dCQUN6QnlELE1BQU07Z0JBQ04saUNBQWlDO2dCQUNqQyxJQUFLLElBQUlHLElBQUksR0FBR0MsTUFBTTdELE1BQU1nQixNQUFNLEVBQUU0QyxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7b0JBQ25ERixRQUFRMUQsS0FBSyxDQUFDNEQsRUFBRSxFQUFFWixNQUFNVyxRQUFRO2dCQUNsQztZQUNGLE9BQU8sSUFBSVgsS0FBS2hDLE1BQU0sRUFBRTtnQkFDdEIsOEJBQThCO2dCQUM5QjBDLFFBQVExRCxPQUFPZ0QsTUFBTVcsUUFBUTtZQUMvQjtRQUNGO0lBQ0Y7SUFFQSwyREFBMkQ7SUFDM0RELFFBQVFwQixLQUFLL0IsU0FBU3lDLFFBQVFBLEtBQUtNLEtBQUssQ0FBQyxPQUFPTixNQUFNO0lBRXRELE9BQU9TLE1BQU1ELE9BQU9BLElBQUksQ0FBQyxFQUFFO0FBQzdCO0FBRUEsTUFBTU0sZUFBZTtJQUNuQixtR0FBbUc7SUFDbkcsMERBQTBEO0lBQzFELDREQUE0RDtJQUM1REMsZ0JBQWdCO0lBQ2hCLDBGQUEwRjtJQUMxRiwwREFBMEQ7SUFDMURDLGdCQUFnQjtJQUNoQiwwRkFBMEY7SUFDMUZDLG9CQUFvQjtBQUN0QjtBQUVBLE1BQU1DLGVBQWU7SUFDbkIsMkZBQTJGO0lBQzNGLG1EQUFtRDtJQUNuREMsaUJBQWlCO0lBQ2pCLHdGQUF3RjtJQUN4RkMsY0FBYztJQUNkLGtGQUFrRjtJQUNsRm5DLE1BQU0sRUFBRTtJQUNSLDRDQUE0QztJQUM1Q29DLFlBQVk7SUFDWixrRUFBa0U7SUFDbEVDLFFBQVEsQ0FBQ0MsR0FBR0MsSUFDVkQsRUFBRUUsS0FBSyxLQUFLRCxFQUFFQyxLQUFLLEdBQUlGLEVBQUVHLEdBQUcsR0FBR0YsRUFBRUUsR0FBRyxHQUFHLENBQUMsSUFBSSxJQUFLSCxFQUFFRSxLQUFLLEdBQUdELEVBQUVDLEtBQUssR0FBRyxDQUFDLElBQUk7QUFDOUU7QUFFQSxNQUFNRSxlQUFlO0lBQ25CLHVFQUF1RTtJQUN2RUMsVUFBVTtJQUNWLGdHQUFnRztJQUNoRyw2RUFBNkU7SUFDN0VDLFdBQVc7SUFDWCxrRkFBa0Y7SUFDbEYsb0ZBQW9GO0lBQ3BGLGlGQUFpRjtJQUNqRixvRkFBb0Y7SUFDcEYsdUZBQXVGO0lBQ3ZGQyxVQUFVO0FBQ1o7QUFFQSxNQUFNQyxrQkFBa0I7SUFDdEIsK0RBQStEO0lBQy9EQyxtQkFBbUI7SUFDbkIsZ0VBQWdFO0lBQ2hFLHdEQUF3RDtJQUN4RDlCLE9BQU9QO0lBQ1AsZ0ZBQWdGO0lBQ2hGLDJDQUEyQztJQUMzQyw0RUFBNEU7SUFDNUVzQyxnQkFBZ0I7SUFDaEIsK0VBQStFO0lBQy9FLGdDQUFnQztJQUNoQyw4RUFBOEU7SUFDOUVDLGlCQUFpQjtJQUNqQixzRUFBc0U7SUFDdEVDLGlCQUFpQjtBQUNuQjtBQUVBLElBQUlDLFNBQVM7SUFDWCxHQUFHbEIsWUFBWTtJQUNmLEdBQUdKLFlBQVk7SUFDZixHQUFHYSxZQUFZO0lBQ2YsR0FBR0ksZUFBZTtBQUNwQjtBQUVBLE1BQU1NLFFBQVE7QUFFZCxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLFNBQVNDLEtBQUs1QyxTQUFTLENBQUMsRUFBRTZDLFdBQVcsQ0FBQztJQUNwQyxNQUFNQyxRQUFRLElBQUlDO0lBQ2xCLE1BQU1DLElBQUlDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJTDtJQUV2QixPQUFPO1FBQ0w1QyxLQUFJM0MsS0FBSztZQUNQLE1BQU02RixZQUFZN0YsTUFBTThGLEtBQUssQ0FBQ1QsT0FBT3JFLE1BQU07WUFFM0MsSUFBSXdFLE1BQU1PLEdBQUcsQ0FBQ0YsWUFBWTtnQkFDeEIsT0FBT0wsTUFBTTdDLEdBQUcsQ0FBQ2tEO1lBQ25CO1lBRUEsNERBQTREO1lBQzVELE1BQU1QLE9BQU8sSUFBSUssS0FBS0MsR0FBRyxDQUFDQyxXQUFXLE1BQU1uRDtZQUUzQywwREFBMEQ7WUFDMUQsTUFBTXNELElBQUlDLFdBQVdOLEtBQUtPLEtBQUssQ0FBQ1osT0FBT0ksS0FBS0E7WUFFNUNGLE1BQU1XLEdBQUcsQ0FBQ04sV0FBV0c7WUFFckIsT0FBT0E7UUFDVDtRQUNBSTtZQUNFWixNQUFNWSxLQUFLO1FBQ2I7SUFDRjtBQUNGO0FBRUEsTUFBTUM7SUFDSnJFLFlBQVksRUFDVmtCLFFBQVFrQyxPQUFPbEMsS0FBSyxFQUNwQmlDLGtCQUFrQkMsT0FBT0QsZUFBZSxFQUN6QyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ04sSUFBSSxDQUFDRyxJQUFJLEdBQUdBLEtBQUtILGlCQUFpQjtRQUNsQyxJQUFJLENBQUNqQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDb0QsU0FBUyxHQUFHO1FBRWpCLElBQUksQ0FBQ0MsZUFBZTtJQUN0QjtJQUNBQyxXQUFXQyxPQUFPLEVBQUUsRUFBRTtRQUNwQixJQUFJLENBQUNBLElBQUksR0FBR0E7SUFDZDtJQUNBRixnQkFBZ0JHLFVBQVUsRUFBRSxFQUFFO1FBQzVCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUNBQyxRQUFRMUUsT0FBTyxFQUFFLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDMkUsUUFBUSxHQUFHLENBQUM7UUFDakIzRSxLQUFLSSxPQUFPLENBQUMsQ0FBQ2QsS0FBS21EO1lBQ2pCLElBQUksQ0FBQ2tDLFFBQVEsQ0FBQ3JGLElBQUlrQixFQUFFLENBQUMsR0FBR2lDO1FBQzFCO0lBQ0Y7SUFDQW1DLFNBQVM7UUFDUCxJQUFJLElBQUksQ0FBQ1AsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDRyxJQUFJLENBQUN6RixNQUFNLEVBQUU7WUFDdkM7UUFDRjtRQUVBLElBQUksQ0FBQ3NGLFNBQVMsR0FBRztRQUVqQix3QkFBd0I7UUFDeEIsSUFBSS9GLFNBQVMsSUFBSSxDQUFDa0csSUFBSSxDQUFDLEVBQUUsR0FBRztZQUMxQixJQUFJLENBQUNBLElBQUksQ0FBQ3BFLE9BQU8sQ0FBQyxDQUFDeUUsS0FBS0M7Z0JBQ3RCLElBQUksQ0FBQ0MsVUFBVSxDQUFDRixLQUFLQztZQUN2QjtRQUNGLE9BQU87WUFDTCx3QkFBd0I7WUFDeEIsSUFBSSxDQUFDTixJQUFJLENBQUNwRSxPQUFPLENBQUMsQ0FBQ3lFLEtBQUtDO2dCQUN0QixJQUFJLENBQUNFLFVBQVUsQ0FBQ0gsS0FBS0M7WUFDdkI7UUFDRjtRQUVBLElBQUksQ0FBQ3pCLElBQUksQ0FBQ2MsS0FBSztJQUNqQjtJQUNBLHFDQUFxQztJQUNyQ2MsSUFBSUosR0FBRyxFQUFFO1FBQ1AsTUFBTXBDLE1BQU0sSUFBSSxDQUFDeUMsSUFBSTtRQUVyQixJQUFJNUcsU0FBU3VHLE1BQU07WUFDakIsSUFBSSxDQUFDRSxVQUFVLENBQUNGLEtBQUtwQztRQUN2QixPQUFPO1lBQ0wsSUFBSSxDQUFDdUMsVUFBVSxDQUFDSCxLQUFLcEM7UUFDdkI7SUFDRjtJQUNBLHNEQUFzRDtJQUN0RDBDLFNBQVMxQyxHQUFHLEVBQUU7UUFDWixJQUFJLENBQUNnQyxPQUFPLENBQUNXLE1BQU0sQ0FBQzNDLEtBQUs7UUFFekIsMENBQTBDO1FBQzFDLElBQUssSUFBSWQsSUFBSWMsS0FBS2IsTUFBTSxJQUFJLENBQUNzRCxJQUFJLElBQUl2RCxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDcEQsSUFBSSxDQUFDOEMsT0FBTyxDQUFDOUMsRUFBRSxDQUFDQSxDQUFDLElBQUk7UUFDdkI7SUFDRjtJQUNBMEQsdUJBQXVCQyxJQUFJLEVBQUUzRSxLQUFLLEVBQUU7UUFDbEMsT0FBTzJFLElBQUksQ0FBQyxJQUFJLENBQUNYLFFBQVEsQ0FBQ2hFLE1BQU0sQ0FBQztJQUNuQztJQUNBdUUsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDVCxPQUFPLENBQUMxRixNQUFNO0lBQzVCO0lBQ0FnRyxXQUFXRixHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN4QixJQUFJLENBQUNuRyxVQUFVa0csUUFBUWhHLFFBQVFnRyxNQUFNO1lBQ25DO1FBQ0Y7UUFFQSxJQUFJVSxTQUFTO1lBQ1hDLEdBQUdYO1lBQ0hsRCxHQUFHbUQ7WUFDSGYsR0FBRyxJQUFJLENBQUNWLElBQUksQ0FBQzNDLEdBQUcsQ0FBQ21FO1FBQ25CO1FBRUEsSUFBSSxDQUFDSixPQUFPLENBQUNsRSxJQUFJLENBQUNnRjtJQUNwQjtJQUNBUCxXQUFXSCxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN4QixJQUFJUyxTQUFTO1lBQUU1RCxHQUFHbUQ7WUFBVVcsR0FBRyxDQUFDO1FBQUU7UUFFbEMsc0VBQXNFO1FBQ3RFLElBQUksQ0FBQ3pGLElBQUksQ0FBQ0ksT0FBTyxDQUFDLENBQUNkLEtBQUtvRztZQUN0QixJQUFJM0gsUUFBUXVCLElBQUkyQixLQUFLLEdBQUczQixJQUFJMkIsS0FBSyxDQUFDNEQsT0FBTyxJQUFJLENBQUM1RCxLQUFLLENBQUM0RCxLQUFLdkYsSUFBSXlCLElBQUk7WUFFakUsSUFBSSxDQUFDcEMsVUFBVVosUUFBUTtnQkFDckI7WUFDRjtZQUVBLElBQUlELFFBQVFDLFFBQVE7Z0JBQ2xCLElBQUk0SCxhQUFhLEVBQUU7Z0JBQ25CLE1BQU1DLFFBQVE7b0JBQUM7d0JBQUVDLGdCQUFnQixDQUFDO3dCQUFHOUg7b0JBQU07aUJBQUU7Z0JBRTdDLE1BQU82SCxNQUFNN0csTUFBTSxDQUFFO29CQUNuQixNQUFNLEVBQUU4RyxjQUFjLEVBQUU5SCxLQUFLLEVBQUUsR0FBRzZILE1BQU1FLEdBQUc7b0JBRTNDLElBQUksQ0FBQ25ILFVBQVVaLFFBQVE7d0JBQ3JCO29CQUNGO29CQUVBLElBQUlPLFNBQVNQLFVBQVUsQ0FBQ2MsUUFBUWQsUUFBUTt3QkFDdEMsSUFBSWdJLFlBQVk7NEJBQ2RQLEdBQUd6SDs0QkFDSDRELEdBQUdrRTs0QkFDSDlCLEdBQUcsSUFBSSxDQUFDVixJQUFJLENBQUMzQyxHQUFHLENBQUMzQzt3QkFDbkI7d0JBRUE0SCxXQUFXcEYsSUFBSSxDQUFDd0Y7b0JBQ2xCLE9BQU8sSUFBSWpJLFFBQVFDLFFBQVE7d0JBQ3pCQSxNQUFNcUMsT0FBTyxDQUFDLENBQUNrRixNQUFNVTs0QkFDbkJKLE1BQU1yRixJQUFJLENBQUM7Z0NBQ1RzRixnQkFBZ0JHO2dDQUNoQmpJLE9BQU91SDs0QkFDVDt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQUMsT0FBT0UsQ0FBQyxDQUFDQyxTQUFTLEdBQUdDO1lBQ3ZCLE9BQU8sSUFBSXJILFNBQVNQLFVBQVUsQ0FBQ2MsUUFBUWQsUUFBUTtnQkFDN0MsSUFBSWdJLFlBQVk7b0JBQ2RQLEdBQUd6SDtvQkFDSGdHLEdBQUcsSUFBSSxDQUFDVixJQUFJLENBQUMzQyxHQUFHLENBQUMzQztnQkFDbkI7Z0JBRUF3SCxPQUFPRSxDQUFDLENBQUNDLFNBQVMsR0FBR0s7WUFDdkI7UUFDRjtRQUVBLElBQUksQ0FBQ3RCLE9BQU8sQ0FBQ2xFLElBQUksQ0FBQ2dGO0lBQ3BCO0lBQ0EzRSxTQUFTO1FBQ1AsT0FBTztZQUNMWixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmeUUsU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDdkI7SUFDRjtBQUNGO0FBRUEsU0FBU3dCLFlBQ1BqRyxJQUFJLEVBQ0p3RSxJQUFJLEVBQ0osRUFBRXZELFFBQVFrQyxPQUFPbEMsS0FBSyxFQUFFaUMsa0JBQWtCQyxPQUFPRCxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFdkUsTUFBTWdELFVBQVUsSUFBSTlCLFVBQVU7UUFBRW5EO1FBQU9pQztJQUFnQjtJQUN2RGdELFFBQVF4QixPQUFPLENBQUMxRSxLQUFLbUcsR0FBRyxDQUFDN0Y7SUFDekI0RixRQUFRM0IsVUFBVSxDQUFDQztJQUNuQjBCLFFBQVF0QixNQUFNO0lBQ2QsT0FBT3NCO0FBQ1Q7QUFFQSxTQUFTRSxXQUNQQyxJQUFJLEVBQ0osRUFBRXBGLFFBQVFrQyxPQUFPbEMsS0FBSyxFQUFFaUMsa0JBQWtCQyxPQUFPRCxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFdkUsTUFBTSxFQUFFbEQsSUFBSSxFQUFFeUUsT0FBTyxFQUFFLEdBQUc0QjtJQUMxQixNQUFNSCxVQUFVLElBQUk5QixVQUFVO1FBQUVuRDtRQUFPaUM7SUFBZ0I7SUFDdkRnRCxRQUFReEIsT0FBTyxDQUFDMUU7SUFDaEJrRyxRQUFRNUIsZUFBZSxDQUFDRztJQUN4QixPQUFPeUI7QUFDVDtBQUVBLFNBQVNJLGVBQ1BDLE9BQU8sRUFDUCxFQUNFQyxTQUFTLENBQUMsRUFDVkMsa0JBQWtCLENBQUMsRUFDbkJDLG1CQUFtQixDQUFDLEVBQ3BCN0QsV0FBV00sT0FBT04sUUFBUSxFQUMxQkcsaUJBQWlCRyxPQUFPSCxjQUFjLEVBQ3ZDLEdBQUcsQ0FBQyxDQUFDO0lBRU4sTUFBTTJELFdBQVdILFNBQVNELFFBQVF4SCxNQUFNO0lBRXhDLElBQUlpRSxnQkFBZ0I7UUFDbEIsT0FBTzJEO0lBQ1Q7SUFFQSxNQUFNQyxZQUFZbEQsS0FBS21ELEdBQUcsQ0FBQ0gsbUJBQW1CRDtJQUU5QyxJQUFJLENBQUM1RCxVQUFVO1FBQ2IsOEJBQThCO1FBQzlCLE9BQU8rRCxZQUFZLE1BQU1EO0lBQzNCO0lBRUEsT0FBT0EsV0FBV0MsWUFBWS9EO0FBQ2hDO0FBRUEsU0FBU2lFLHFCQUNQQyxZQUFZLEVBQUUsRUFDZC9FLHFCQUFxQm1CLE9BQU9uQixrQkFBa0I7SUFFOUMsSUFBSWdGLFVBQVUsRUFBRTtJQUNoQixJQUFJQyxRQUFRLENBQUM7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFDWCxJQUFJdkYsSUFBSTtJQUVSLElBQUssSUFBSUMsTUFBTW1GLFVBQVVoSSxNQUFNLEVBQUU0QyxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7UUFDaEQsSUFBSWtDLFFBQVFrRCxTQUFTLENBQUNwRixFQUFFO1FBQ3hCLElBQUlrQyxTQUFTb0QsVUFBVSxDQUFDLEdBQUc7WUFDekJBLFFBQVF0RjtRQUNWLE9BQU8sSUFBSSxDQUFDa0MsU0FBU29ELFVBQVUsQ0FBQyxHQUFHO1lBQ2pDQyxNQUFNdkYsSUFBSTtZQUNWLElBQUl1RixNQUFNRCxRQUFRLEtBQUtqRixvQkFBb0I7Z0JBQ3pDZ0YsUUFBUXpHLElBQUksQ0FBQztvQkFBQzBHO29CQUFPQztpQkFBSTtZQUMzQjtZQUNBRCxRQUFRLENBQUM7UUFDWDtJQUNGO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUlGLFNBQVMsQ0FBQ3BGLElBQUksRUFBRSxJQUFJQSxJQUFJc0YsU0FBU2pGLG9CQUFvQjtRQUN2RGdGLFFBQVF6RyxJQUFJLENBQUM7WUFBQzBHO1lBQU90RixJQUFJO1NBQUU7SUFDN0I7SUFFQSxPQUFPcUY7QUFDVDtBQUVBLG9CQUFvQjtBQUNwQixNQUFNRyxXQUFXO0FBRWpCLFNBQVNDLE9BQ1BDLElBQUksRUFDSmQsT0FBTyxFQUNQZSxlQUFlLEVBQ2YsRUFDRTNFLFdBQVdRLE9BQU9SLFFBQVEsRUFDMUJFLFdBQVdNLE9BQU9OLFFBQVEsRUFDMUJELFlBQVlPLE9BQU9QLFNBQVMsRUFDNUJiLGlCQUFpQm9CLE9BQU9wQixjQUFjLEVBQ3RDQyxxQkFBcUJtQixPQUFPbkIsa0JBQWtCLEVBQzlDRixpQkFBaUJxQixPQUFPckIsY0FBYyxFQUN0Q2tCLGlCQUFpQkcsT0FBT0gsY0FBYyxFQUN2QyxHQUFHLENBQUMsQ0FBQztJQUVOLElBQUl1RCxRQUFReEgsTUFBTSxHQUFHb0ksVUFBVTtRQUM3QixNQUFNLElBQUkvRixNQUFNN0IseUJBQXlCNEg7SUFDM0M7SUFFQSxNQUFNSSxhQUFhaEIsUUFBUXhILE1BQU07SUFDakMsdUVBQXVFO0lBQ3ZFLE1BQU15SSxVQUFVSCxLQUFLdEksTUFBTTtJQUMzQiw4Q0FBOEM7SUFDOUMsTUFBTTJILG1CQUFtQmhELEtBQUtsRSxHQUFHLENBQUMsR0FBR2tFLEtBQUsrRCxHQUFHLENBQUM5RSxVQUFVNkU7SUFDeEQseUNBQXlDO0lBQ3pDLElBQUlFLG1CQUFtQjlFO0lBQ3ZCLDJDQUEyQztJQUMzQyxJQUFJK0UsZUFBZWpCO0lBRW5CLHFFQUFxRTtJQUNyRSxrQ0FBa0M7SUFDbEMsTUFBTWtCLGlCQUFpQjVGLHFCQUFxQixLQUFLRjtJQUNqRCx1REFBdUQ7SUFDdkQsTUFBTStGLFlBQVlELGlCQUFpQjVKLE1BQU13SixXQUFXLEVBQUU7SUFFdEQsSUFBSTlGO0lBRUosMkNBQTJDO0lBQzNDLE1BQU8sQ0FBQ0EsUUFBUTJGLEtBQUtTLE9BQU8sQ0FBQ3ZCLFNBQVNvQixhQUFZLElBQUssQ0FBQyxFQUFHO1FBQ3pELElBQUluRixRQUFROEQsZUFBZUMsU0FBUztZQUNsQ0UsaUJBQWlCL0U7WUFDakJnRjtZQUNBN0Q7WUFDQUc7UUFDRjtRQUVBMEUsbUJBQW1CaEUsS0FBSytELEdBQUcsQ0FBQ2pGLE9BQU9rRjtRQUNuQ0MsZUFBZWpHLFFBQVE2RjtRQUV2QixJQUFJSyxnQkFBZ0I7WUFDbEIsSUFBSWpHLElBQUk7WUFDUixNQUFPQSxJQUFJNEYsV0FBWTtnQkFDckJNLFNBQVMsQ0FBQ25HLFFBQVFDLEVBQUUsR0FBRztnQkFDdkJBLEtBQUs7WUFDUDtRQUNGO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUJnRyxlQUFlLENBQUM7SUFFaEIsSUFBSUksYUFBYSxFQUFFO0lBQ25CLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsU0FBU1YsYUFBYUM7SUFFMUIsTUFBTVUsT0FBTyxLQUFNWCxhQUFhO0lBRWhDLElBQUssSUFBSTVGLElBQUksR0FBR0EsSUFBSTRGLFlBQVk1RixLQUFLLEVBQUc7UUFDdEMscUVBQXFFO1FBQ3JFLGdGQUFnRjtRQUNoRix1QkFBdUI7UUFDdkIsSUFBSXdHLFNBQVM7UUFDYixJQUFJQyxTQUFTSDtRQUViLE1BQU9FLFNBQVNDLE9BQVE7WUFDdEIsTUFBTTVGLFFBQVE4RCxlQUFlQyxTQUFTO2dCQUNwQ0MsUUFBUTdFO2dCQUNSOEUsaUJBQWlCQyxtQkFBbUIwQjtnQkFDcEMxQjtnQkFDQTdEO2dCQUNBRztZQUNGO1lBRUEsSUFBSVIsU0FBU2tGLGtCQUFrQjtnQkFDN0JTLFNBQVNDO1lBQ1gsT0FBTztnQkFDTEgsU0FBU0c7WUFDWDtZQUVBQSxTQUFTMUUsS0FBSzJFLEtBQUssQ0FBQyxDQUFDSixTQUFTRSxNQUFLLElBQUssSUFBSUE7UUFDOUM7UUFFQSxrRUFBa0U7UUFDbEVGLFNBQVNHO1FBRVQsSUFBSW5CLFFBQVF2RCxLQUFLbEUsR0FBRyxDQUFDLEdBQUdrSCxtQkFBbUIwQixTQUFTO1FBQ3BELElBQUlFLFNBQVN2RyxpQkFDVHlGLFVBQ0E5RCxLQUFLK0QsR0FBRyxDQUFDZixtQkFBbUIwQixRQUFRWixXQUFXRDtRQUVuRCwyQkFBMkI7UUFDM0IsSUFBSWdCLFNBQVN2SyxNQUFNc0ssU0FBUztRQUU1QkMsTUFBTSxDQUFDRCxTQUFTLEVBQUUsR0FBRyxDQUFDLEtBQUszRyxDQUFBQSxJQUFLO1FBRWhDLElBQUssSUFBSTZHLElBQUlGLFFBQVFFLEtBQUt2QixPQUFPdUIsS0FBSyxFQUFHO1lBQ3ZDLElBQUkvQixrQkFBa0IrQixJQUFJO1lBQzFCLElBQUlDLFlBQVluQixlQUFlLENBQUNELEtBQUtxQixNQUFNLENBQUNqQyxpQkFBaUI7WUFFN0QsSUFBSW1CLGdCQUFnQjtnQkFDbEIsb0VBQW9FO2dCQUNwRUMsU0FBUyxDQUFDcEIsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUNnQztZQUNsQztZQUVBLDBCQUEwQjtZQUMxQkYsTUFBTSxDQUFDQyxFQUFFLEdBQUcsQ0FBQyxNQUFPLENBQUNBLElBQUksRUFBRSxJQUFJLElBQUssS0FBS0M7WUFFekMsaUNBQWlDO1lBQ2pDLElBQUk5RyxHQUFHO2dCQUNMNEcsTUFBTSxDQUFDQyxFQUFFLElBQ1AsQ0FBRVQsVUFBVSxDQUFDUyxJQUFJLEVBQUUsR0FBR1QsVUFBVSxDQUFDUyxFQUFFLEtBQUssSUFBSyxJQUFJVCxVQUFVLENBQUNTLElBQUksRUFBRTtZQUN0RTtZQUVBLElBQUlELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHTixNQUFNO2dCQUNwQkYsYUFBYTFCLGVBQWVDLFNBQVM7b0JBQ25DQyxRQUFRN0U7b0JBQ1I4RTtvQkFDQUM7b0JBQ0E3RDtvQkFDQUc7Z0JBQ0Y7Z0JBRUEsc0VBQXNFO2dCQUN0RSxvQkFBb0I7Z0JBQ3BCLElBQUlnRixjQUFjTixrQkFBa0I7b0JBQ2xDLGVBQWU7b0JBQ2ZBLG1CQUFtQk07b0JBQ25CTCxlQUFlbEI7b0JBRWYsa0RBQWtEO29CQUNsRCxJQUFJa0IsZ0JBQWdCakIsa0JBQWtCO3dCQUNwQztvQkFDRjtvQkFFQSwwRkFBMEY7b0JBQzFGTyxRQUFRdkQsS0FBS2xFLEdBQUcsQ0FBQyxHQUFHLElBQUlrSCxtQkFBbUJpQjtnQkFDN0M7WUFDRjtRQUNGO1FBRUEsd0RBQXdEO1FBQ3hELE1BQU1uRixRQUFROEQsZUFBZUMsU0FBUztZQUNwQ0MsUUFBUTdFLElBQUk7WUFDWjhFLGlCQUFpQkM7WUFDakJBO1lBQ0E3RDtZQUNBRztRQUNGO1FBRUEsSUFBSVIsUUFBUWtGLGtCQUFrQjtZQUM1QjtRQUNGO1FBRUFLLGFBQWFRO0lBQ2Y7SUFFQSxNQUFNbkssU0FBUztRQUNidUssU0FBU2hCLGdCQUFnQjtRQUN6QixxRUFBcUU7UUFDckVuRixPQUFPa0IsS0FBS2xFLEdBQUcsQ0FBQyxPQUFPd0k7SUFDekI7SUFFQSxJQUFJSixnQkFBZ0I7UUFDbEIsTUFBTVosVUFBVUYscUJBQXFCZSxXQUFXN0Y7UUFDaEQsSUFBSSxDQUFDZ0YsUUFBUWpJLE1BQU0sRUFBRTtZQUNuQlgsT0FBT3VLLE9BQU8sR0FBRztRQUNuQixPQUFPLElBQUk3RyxnQkFBZ0I7WUFDekIxRCxPQUFPNEksT0FBTyxHQUFHQTtRQUNuQjtJQUNGO0lBRUEsT0FBTzVJO0FBQ1Q7QUFFQSxTQUFTd0ssc0JBQXNCckMsT0FBTztJQUNwQyxJQUFJMkIsT0FBTyxDQUFDO0lBRVosSUFBSyxJQUFJdkcsSUFBSSxHQUFHQyxNQUFNMkUsUUFBUXhILE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztRQUNyRCxNQUFNa0gsT0FBT3RDLFFBQVFtQyxNQUFNLENBQUMvRztRQUM1QnVHLElBQUksQ0FBQ1csS0FBSyxHQUFHLENBQUNYLElBQUksQ0FBQ1csS0FBSyxJQUFJLEtBQU0sS0FBTWpILE1BQU1ELElBQUk7SUFDcEQ7SUFFQSxPQUFPdUc7QUFDVDtBQUVBLE1BQU1ZO0lBQ0ovSSxZQUNFd0csT0FBTyxFQUNQLEVBQ0U1RCxXQUFXUSxPQUFPUixRQUFRLEVBQzFCQyxZQUFZTyxPQUFPUCxTQUFTLEVBQzVCQyxXQUFXTSxPQUFPTixRQUFRLEVBQzFCZixpQkFBaUJxQixPQUFPckIsY0FBYyxFQUN0Q0MsaUJBQWlCb0IsT0FBT3BCLGNBQWMsRUFDdENDLHFCQUFxQm1CLE9BQU9uQixrQkFBa0IsRUFDOUNFLGtCQUFrQmlCLE9BQU9qQixlQUFlLEVBQ3hDYyxpQkFBaUJHLE9BQU9ILGNBQWMsRUFDdkMsR0FBRyxDQUFDLENBQUMsQ0FDTjtRQUNBLElBQUksQ0FBQytGLE9BQU8sR0FBRztZQUNicEc7WUFDQUM7WUFDQUM7WUFDQWY7WUFDQUM7WUFDQUM7WUFDQUU7WUFDQWM7UUFDRjtRQUVBLElBQUksQ0FBQ3VELE9BQU8sR0FBR3JFLGtCQUFrQnFFLFVBQVVBLFFBQVF5QyxXQUFXO1FBRTlELElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7UUFFaEIsSUFBSSxDQUFDLElBQUksQ0FBQzFDLE9BQU8sQ0FBQ3hILE1BQU0sRUFBRTtZQUN4QjtRQUNGO1FBRUEsTUFBTW1LLFdBQVcsQ0FBQzNDLFNBQVM0QztZQUN6QixJQUFJLENBQUNGLE1BQU0sQ0FBQzFJLElBQUksQ0FBQztnQkFDZmdHO2dCQUNBNkMsVUFBVVIsc0JBQXNCckM7Z0JBQ2hDNEM7WUFDRjtRQUNGO1FBRUEsTUFBTXZILE1BQU0sSUFBSSxDQUFDMkUsT0FBTyxDQUFDeEgsTUFBTTtRQUUvQixJQUFJNkMsTUFBTXVGLFVBQVU7WUFDbEIsSUFBSXhGLElBQUk7WUFDUixNQUFNMEgsWUFBWXpILE1BQU11RjtZQUN4QixNQUFNRCxNQUFNdEYsTUFBTXlIO1lBRWxCLE1BQU8xSCxJQUFJdUYsSUFBSztnQkFDZGdDLFNBQVMsSUFBSSxDQUFDM0MsT0FBTyxDQUFDK0MsTUFBTSxDQUFDM0gsR0FBR3dGLFdBQVd4RjtnQkFDM0NBLEtBQUt3RjtZQUNQO1lBRUEsSUFBSWtDLFdBQVc7Z0JBQ2IsTUFBTUYsYUFBYXZILE1BQU11RjtnQkFDekIrQixTQUFTLElBQUksQ0FBQzNDLE9BQU8sQ0FBQytDLE1BQU0sQ0FBQ0gsYUFBYUE7WUFDNUM7UUFDRixPQUFPO1lBQ0xELFNBQVMsSUFBSSxDQUFDM0MsT0FBTyxFQUFFO1FBQ3pCO0lBQ0Y7SUFFQWdELFNBQVNsQyxJQUFJLEVBQUU7UUFDYixNQUFNLEVBQUVuRixlQUFlLEVBQUVKLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQ2lILE9BQU87UUFFeEQsSUFBSSxDQUFDN0csaUJBQWlCO1lBQ3BCbUYsT0FBT0EsS0FBSzJCLFdBQVc7UUFDekI7UUFFQSxjQUFjO1FBQ2QsSUFBSSxJQUFJLENBQUN6QyxPQUFPLEtBQUtjLE1BQU07WUFDekIsSUFBSWpKLFNBQVM7Z0JBQ1h1SyxTQUFTO2dCQUNUbkcsT0FBTztZQUNUO1lBRUEsSUFBSVYsZ0JBQWdCO2dCQUNsQjFELE9BQU80SSxPQUFPLEdBQUc7b0JBQUM7d0JBQUM7d0JBQUdLLEtBQUt0SSxNQUFNLEdBQUc7cUJBQUU7aUJBQUM7WUFDekM7WUFFQSxPQUFPWDtRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDLE1BQU0sRUFDSnVFLFFBQVEsRUFDUkUsUUFBUSxFQUNSRCxTQUFTLEVBQ1RiLGNBQWMsRUFDZEMsa0JBQWtCLEVBQ2xCZ0IsY0FBYyxFQUNmLEdBQUcsSUFBSSxDQUFDK0YsT0FBTztRQUVoQixJQUFJUyxhQUFhLEVBQUU7UUFDbkIsSUFBSUMsYUFBYTtRQUNqQixJQUFJQyxhQUFhO1FBRWpCLElBQUksQ0FBQ1QsTUFBTSxDQUFDN0ksT0FBTyxDQUFDLENBQUMsRUFBRW1HLE9BQU8sRUFBRTZDLFFBQVEsRUFBRUQsVUFBVSxFQUFFO1lBQ3BELE1BQU0sRUFBRVIsT0FBTyxFQUFFbkcsS0FBSyxFQUFFd0UsT0FBTyxFQUFFLEdBQUdJLE9BQU9DLE1BQU1kLFNBQVM2QyxVQUFVO2dCQUNsRXpHLFVBQVVBLFdBQVd3RztnQkFDckJ0RztnQkFDQUQ7Z0JBQ0FiO2dCQUNBQztnQkFDQUY7Z0JBQ0FrQjtZQUNGO1lBRUEsSUFBSTJGLFNBQVM7Z0JBQ1hlLGFBQWE7WUFDZjtZQUVBRCxjQUFjakg7WUFFZCxJQUFJbUcsV0FBVzNCLFNBQVM7Z0JBQ3RCd0MsYUFBYTt1QkFBSUE7dUJBQWV4QztpQkFBUTtZQUMxQztRQUNGO1FBRUEsSUFBSTVJLFNBQVM7WUFDWHVLLFNBQVNlO1lBQ1RsSCxPQUFPa0gsYUFBYUQsYUFBYSxJQUFJLENBQUNSLE1BQU0sQ0FBQ2xLLE1BQU0sR0FBRztRQUN4RDtRQUVBLElBQUkySyxjQUFjNUgsZ0JBQWdCO1lBQ2hDMUQsT0FBTzRJLE9BQU8sR0FBR3dDO1FBQ25CO1FBRUEsT0FBT3BMO0lBQ1Q7QUFDRjtBQUVBLE1BQU11TDtJQUNKNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDakI7SUFDQSxPQUFPcUQsYUFBYXJELE9BQU8sRUFBRTtRQUMzQixPQUFPc0QsU0FBU3RELFNBQVMsSUFBSSxDQUFDdUQsVUFBVTtJQUMxQztJQUNBLE9BQU9DLGNBQWN4RCxPQUFPLEVBQUU7UUFDNUIsT0FBT3NELFNBQVN0RCxTQUFTLElBQUksQ0FBQ3lELFdBQVc7SUFDM0M7SUFDQTVDLFNBQWlCLENBQUM7QUFDcEI7QUFFQSxTQUFTeUMsU0FBU3RELE9BQU8sRUFBRTBELEdBQUc7SUFDNUIsTUFBTUMsVUFBVTNELFFBQVExQyxLQUFLLENBQUNvRztJQUM5QixPQUFPQyxVQUFVQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQ2hDO0FBRUEsZUFBZTtBQUVmLE1BQU1DLG1CQUFtQlI7SUFDdkI1SixZQUFZd0csT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7SUFDUjtJQUNBLFdBQVc2RCxPQUFPO1FBQ2hCLE9BQU87SUFDVDtJQUNBLFdBQVdOLGFBQWE7UUFDdEIsT0FBTztJQUNUO0lBQ0EsV0FBV0UsY0FBYztRQUN2QixPQUFPO0lBQ1Q7SUFDQTVDLE9BQU9DLElBQUksRUFBRTtRQUNYLE1BQU1zQixVQUFVdEIsU0FBUyxJQUFJLENBQUNkLE9BQU87UUFFckMsT0FBTztZQUNMb0M7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQixTQUFTO2dCQUFDO2dCQUFHLElBQUksQ0FBQ1QsT0FBTyxDQUFDeEgsTUFBTSxHQUFHO2FBQUU7UUFDdkM7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUVmLE1BQU1zTCwwQkFBMEJWO0lBQzlCNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO0lBQ1I7SUFDQSxXQUFXNkQsT0FBTztRQUNoQixPQUFPO0lBQ1Q7SUFDQSxXQUFXTixhQUFhO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFdBQVdFLGNBQWM7UUFDdkIsT0FBTztJQUNUO0lBQ0E1QyxPQUFPQyxJQUFJLEVBQUU7UUFDWCxNQUFNM0YsUUFBUTJGLEtBQUtTLE9BQU8sQ0FBQyxJQUFJLENBQUN2QixPQUFPO1FBQ3ZDLE1BQU1vQyxVQUFVakgsVUFBVSxDQUFDO1FBRTNCLE9BQU87WUFDTGlIO1lBQ0FuRyxPQUFPbUcsVUFBVSxJQUFJO1lBQ3JCM0IsU0FBUztnQkFBQztnQkFBR0ssS0FBS3RJLE1BQU0sR0FBRzthQUFFO1FBQy9CO0lBQ0Y7QUFDRjtBQUVBLGVBQWU7QUFFZixNQUFNdUwseUJBQXlCWDtJQUM3QjVKLFlBQVl3RyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtJQUNSO0lBQ0EsV0FBVzZELE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsTUFBTXNCLFVBQVV0QixLQUFLa0QsVUFBVSxDQUFDLElBQUksQ0FBQ2hFLE9BQU87UUFFNUMsT0FBTztZQUNMb0M7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQixTQUFTO2dCQUFDO2dCQUFHLElBQUksQ0FBQ1QsT0FBTyxDQUFDeEgsTUFBTSxHQUFHO2FBQUU7UUFDdkM7SUFDRjtBQUNGO0FBRUEsZ0JBQWdCO0FBRWhCLE1BQU15TCxnQ0FBZ0NiO0lBQ3BDNUosWUFBWXdHLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO0lBQ1I7SUFDQSxXQUFXNkQsT0FBTztRQUNoQixPQUFPO0lBQ1Q7SUFDQSxXQUFXTixhQUFhO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFdBQVdFLGNBQWM7UUFDdkIsT0FBTztJQUNUO0lBQ0E1QyxPQUFPQyxJQUFJLEVBQUU7UUFDWCxNQUFNc0IsVUFBVSxDQUFDdEIsS0FBS2tELFVBQVUsQ0FBQyxJQUFJLENBQUNoRSxPQUFPO1FBRTdDLE9BQU87WUFDTG9DO1lBQ0FuRyxPQUFPbUcsVUFBVSxJQUFJO1lBQ3JCM0IsU0FBUztnQkFBQztnQkFBR0ssS0FBS3RJLE1BQU0sR0FBRzthQUFFO1FBQy9CO0lBQ0Y7QUFDRjtBQUVBLGdCQUFnQjtBQUVoQixNQUFNMEwseUJBQXlCZDtJQUM3QjVKLFlBQVl3RyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtJQUNSO0lBQ0EsV0FBVzZELE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsTUFBTXNCLFVBQVV0QixLQUFLcUQsUUFBUSxDQUFDLElBQUksQ0FBQ25FLE9BQU87UUFFMUMsT0FBTztZQUNMb0M7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQixTQUFTO2dCQUFDSyxLQUFLdEksTUFBTSxHQUFHLElBQUksQ0FBQ3dILE9BQU8sQ0FBQ3hILE1BQU07Z0JBQUVzSSxLQUFLdEksTUFBTSxHQUFHO2FBQUU7UUFDL0Q7SUFDRjtBQUNGO0FBRUEsaUJBQWlCO0FBRWpCLE1BQU00TCxnQ0FBZ0NoQjtJQUNwQzVKLFlBQVl3RyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtJQUNSO0lBQ0EsV0FBVzZELE9BQU87UUFDaEIsT0FBTztJQUNUO0lBQ0EsV0FBV04sYUFBYTtRQUN0QixPQUFPO0lBQ1Q7SUFDQSxXQUFXRSxjQUFjO1FBQ3ZCLE9BQU87SUFDVDtJQUNBNUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1gsTUFBTXNCLFVBQVUsQ0FBQ3RCLEtBQUtxRCxRQUFRLENBQUMsSUFBSSxDQUFDbkUsT0FBTztRQUMzQyxPQUFPO1lBQ0xvQztZQUNBbkcsT0FBT21HLFVBQVUsSUFBSTtZQUNyQjNCLFNBQVM7Z0JBQUM7Z0JBQUdLLEtBQUt0SSxNQUFNLEdBQUc7YUFBRTtRQUMvQjtJQUNGO0FBQ0Y7QUFFQSxNQUFNNkwsbUJBQW1CakI7SUFDdkI1SixZQUNFd0csT0FBTyxFQUNQLEVBQ0U1RCxXQUFXUSxPQUFPUixRQUFRLEVBQzFCQyxZQUFZTyxPQUFPUCxTQUFTLEVBQzVCQyxXQUFXTSxPQUFPTixRQUFRLEVBQzFCZixpQkFBaUJxQixPQUFPckIsY0FBYyxFQUN0Q0MsaUJBQWlCb0IsT0FBT3BCLGNBQWMsRUFDdENDLHFCQUFxQm1CLE9BQU9uQixrQkFBa0IsRUFDOUNFLGtCQUFrQmlCLE9BQU9qQixlQUFlLEVBQ3hDYyxpQkFBaUJHLE9BQU9ILGNBQWMsRUFDdkMsR0FBRyxDQUFDLENBQUMsQ0FDTjtRQUNBLEtBQUssQ0FBQ3VEO1FBQ04sSUFBSSxDQUFDc0UsWUFBWSxHQUFHLElBQUkvQixZQUFZdkMsU0FBUztZQUMzQzVEO1lBQ0FDO1lBQ0FDO1lBQ0FmO1lBQ0FDO1lBQ0FDO1lBQ0FFO1lBQ0FjO1FBQ0Y7SUFDRjtJQUNBLFdBQVdvSCxPQUFPO1FBQ2hCLE9BQU87SUFDVDtJQUNBLFdBQVdOLGFBQWE7UUFDdEIsT0FBTztJQUNUO0lBQ0EsV0FBV0UsY0FBYztRQUN2QixPQUFPO0lBQ1Q7SUFDQTVDLE9BQU9DLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDd0QsWUFBWSxDQUFDdEIsUUFBUSxDQUFDbEM7SUFDcEM7QUFDRjtBQUVBLGVBQWU7QUFFZixNQUFNeUQscUJBQXFCbkI7SUFDekI1SixZQUFZd0csT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7SUFDUjtJQUNBLFdBQVc2RCxPQUFPO1FBQ2hCLE9BQU87SUFDVDtJQUNBLFdBQVdOLGFBQWE7UUFDdEIsT0FBTztJQUNUO0lBQ0EsV0FBV0UsY0FBYztRQUN2QixPQUFPO0lBQ1Q7SUFDQTVDLE9BQU9DLElBQUksRUFBRTtRQUNYLElBQUkxRSxXQUFXO1FBQ2YsSUFBSWpCO1FBRUosTUFBTXNGLFVBQVUsRUFBRTtRQUNsQixNQUFNTyxhQUFhLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ3hILE1BQU07UUFFdEMsd0JBQXdCO1FBQ3hCLE1BQU8sQ0FBQzJDLFFBQVEyRixLQUFLUyxPQUFPLENBQUMsSUFBSSxDQUFDdkIsT0FBTyxFQUFFNUQsU0FBUSxJQUFLLENBQUMsRUFBRztZQUMxREEsV0FBV2pCLFFBQVE2RjtZQUNuQlAsUUFBUXpHLElBQUksQ0FBQztnQkFBQ21CO2dCQUFPaUIsV0FBVzthQUFFO1FBQ3BDO1FBRUEsTUFBTWdHLFVBQVUsQ0FBQyxDQUFDM0IsUUFBUWpJLE1BQU07UUFFaEMsT0FBTztZQUNMNEo7WUFDQW5HLE9BQU9tRyxVQUFVLElBQUk7WUFDckIzQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLHNDQUFzQztBQUN0QyxNQUFNK0QsWUFBWTtJQUNoQlo7SUFDQVc7SUFDQVI7SUFDQUU7SUFDQUc7SUFDQUY7SUFDQUo7SUFDQU87Q0FDRDtBQUVELE1BQU1JLGVBQWVELFVBQVVoTSxNQUFNO0FBRXJDLGlFQUFpRTtBQUNqRSxNQUFNa00sV0FBVztBQUNqQixNQUFNQyxXQUFXO0FBRWpCLHNFQUFzRTtBQUN0RSxXQUFXO0FBQ1gsNkVBQTZFO0FBQzdFLFNBQVNDLFdBQVc1RSxPQUFPLEVBQUV3QyxVQUFVLENBQUMsQ0FBQztJQUN2QyxPQUFPeEMsUUFBUWxGLEtBQUssQ0FBQzZKLFVBQVUvRSxHQUFHLENBQUMsQ0FBQ2I7UUFDbEMsSUFBSThGLFFBQVE5RixLQUNUeEcsSUFBSSxHQUNKdUMsS0FBSyxDQUFDNEosVUFDTkksTUFBTSxDQUFDLENBQUMvRixPQUFTQSxRQUFRLENBQUMsQ0FBQ0EsS0FBS3hHLElBQUk7UUFFdkMsSUFBSXdNLFVBQVUsRUFBRTtRQUNoQixJQUFLLElBQUkzSixJQUFJLEdBQUdDLE1BQU13SixNQUFNck0sTUFBTSxFQUFFNEMsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQ25ELE1BQU00SixZQUFZSCxLQUFLLENBQUN6SixFQUFFO1lBRTFCLG1GQUFtRjtZQUNuRixJQUFJNkosUUFBUTtZQUNaLElBQUkvSSxNQUFNLENBQUM7WUFDWCxNQUFPLENBQUMrSSxTQUFTLEVBQUUvSSxNQUFNdUksYUFBYztnQkFDckMsTUFBTVMsV0FBV1YsU0FBUyxDQUFDdEksSUFBSTtnQkFDL0IsSUFBSWlKLFFBQVFELFNBQVM3QixZQUFZLENBQUMyQjtnQkFDbEMsSUFBSUcsT0FBTztvQkFDVEosUUFBUS9LLElBQUksQ0FBQyxJQUFJa0wsU0FBU0MsT0FBTzNDO29CQUNqQ3lDLFFBQVE7Z0JBQ1Y7WUFDRjtZQUVBLElBQUlBLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLG1FQUFtRTtZQUNuRS9JLE1BQU0sQ0FBQztZQUNQLE1BQU8sRUFBRUEsTUFBTXVJLGFBQWM7Z0JBQzNCLE1BQU1TLFdBQVdWLFNBQVMsQ0FBQ3RJLElBQUk7Z0JBQy9CLElBQUlpSixRQUFRRCxTQUFTMUIsYUFBYSxDQUFDd0I7Z0JBQ25DLElBQUlHLE9BQU87b0JBQ1RKLFFBQVEvSyxJQUFJLENBQUMsSUFBSWtMLFNBQVNDLE9BQU8zQztvQkFDakM7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3VDO0lBQ1Q7QUFDRjtBQUVBLHFFQUFxRTtBQUNyRSxtQkFBbUI7QUFDbkIsTUFBTUssZ0JBQWdCLElBQUlDLElBQUk7SUFBQ2hCLFdBQVdSLElBQUk7SUFBRVUsYUFBYVYsSUFBSTtDQUFDO0FBRWxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDRCxNQUFNeUI7SUFDSjlMLFlBQ0V3RyxPQUFPLEVBQ1AsRUFDRXJFLGtCQUFrQmlCLE9BQU9qQixlQUFlLEVBQ3hDSixpQkFBaUJxQixPQUFPckIsY0FBYyxFQUN0Q0UscUJBQXFCbUIsT0FBT25CLGtCQUFrQixFQUM5Q2dCLGlCQUFpQkcsT0FBT0gsY0FBYyxFQUN0Q2pCLGlCQUFpQm9CLE9BQU9wQixjQUFjLEVBQ3RDWSxXQUFXUSxPQUFPUixRQUFRLEVBQzFCQyxZQUFZTyxPQUFPUCxTQUFTLEVBQzVCQyxXQUFXTSxPQUFPTixRQUFRLEVBQzNCLEdBQUcsQ0FBQyxDQUFDLENBQ047UUFDQSxJQUFJLENBQUN1SSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNyQyxPQUFPLEdBQUc7WUFDYjdHO1lBQ0FKO1lBQ0FFO1lBQ0FEO1lBQ0FpQjtZQUNBTDtZQUNBQztZQUNBQztRQUNGO1FBRUEsSUFBSSxDQUFDMEQsT0FBTyxHQUFHckUsa0JBQWtCcUUsVUFBVUEsUUFBUXlDLFdBQVc7UUFDOUQsSUFBSSxDQUFDb0MsS0FBSyxHQUFHRCxXQUFXLElBQUksQ0FBQzVFLE9BQU8sRUFBRSxJQUFJLENBQUN3QyxPQUFPO0lBQ3BEO0lBRUEsT0FBTytDLFVBQVVDLENBQUMsRUFBRWhELE9BQU8sRUFBRTtRQUMzQixPQUFPQSxRQUFRaEcsaUJBQWlCO0lBQ2xDO0lBRUF3RyxTQUFTbEMsSUFBSSxFQUFFO1FBQ2IsTUFBTStELFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBRXhCLElBQUksQ0FBQ0EsT0FBTztZQUNWLE9BQU87Z0JBQ0x6QyxTQUFTO2dCQUNUbkcsT0FBTztZQUNUO1FBQ0Y7UUFFQSxNQUFNLEVBQUVWLGNBQWMsRUFBRUksZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDNkcsT0FBTztRQUV4RDFCLE9BQU9uRixrQkFBa0JtRixPQUFPQSxLQUFLMkIsV0FBVztRQUVoRCxJQUFJZ0QsYUFBYTtRQUNqQixJQUFJeEMsYUFBYSxFQUFFO1FBQ25CLElBQUlDLGFBQWE7UUFFakIsTUFBTTtRQUNOLElBQUssSUFBSTlILElBQUksR0FBR3NLLE9BQU9iLE1BQU1yTSxNQUFNLEVBQUU0QyxJQUFJc0ssTUFBTXRLLEtBQUssRUFBRztZQUNyRCxNQUFNb0osWUFBWUssS0FBSyxDQUFDekosRUFBRTtZQUUxQixnQkFBZ0I7WUFDaEI2SCxXQUFXekssTUFBTSxHQUFHO1lBQ3BCaU4sYUFBYTtZQUViLE9BQU87WUFDUCxJQUFLLElBQUl4RCxJQUFJLEdBQUcwRCxPQUFPbkIsVUFBVWhNLE1BQU0sRUFBRXlKLElBQUkwRCxNQUFNMUQsS0FBSyxFQUFHO2dCQUN6RCxNQUFNaUQsV0FBV1YsU0FBUyxDQUFDdkMsRUFBRTtnQkFDN0IsTUFBTSxFQUFFRyxPQUFPLEVBQUUzQixPQUFPLEVBQUV4RSxLQUFLLEVBQUUsR0FBR2lKLFNBQVNyRSxNQUFNLENBQUNDO2dCQUVwRCxJQUFJc0IsU0FBUztvQkFDWHFELGNBQWM7b0JBQ2R2QyxjQUFjakg7b0JBQ2QsSUFBSVYsZ0JBQWdCO3dCQUNsQixNQUFNc0ksT0FBT3FCLFNBQVMxTCxXQUFXLENBQUNxSyxJQUFJO3dCQUN0QyxJQUFJdUIsY0FBYzdILEdBQUcsQ0FBQ3NHLE9BQU87NEJBQzNCWixhQUFhO21DQUFJQTttQ0FBZXhDOzZCQUFRO3dCQUMxQyxPQUFPOzRCQUNMd0MsV0FBV2pKLElBQUksQ0FBQ3lHO3dCQUNsQjtvQkFDRjtnQkFDRixPQUFPO29CQUNMeUMsYUFBYTtvQkFDYnVDLGFBQWE7b0JBQ2J4QyxXQUFXekssTUFBTSxHQUFHO29CQUNwQjtnQkFDRjtZQUNGO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlpTixZQUFZO2dCQUNkLElBQUk1TixTQUFTO29CQUNYdUssU0FBUztvQkFDVG5HLE9BQU9pSCxhQUFhdUM7Z0JBQ3RCO2dCQUVBLElBQUlsSyxnQkFBZ0I7b0JBQ2xCMUQsT0FBTzRJLE9BQU8sR0FBR3dDO2dCQUNuQjtnQkFFQSxPQUFPcEw7WUFDVDtRQUNGO1FBRUEsc0JBQXNCO1FBQ3RCLE9BQU87WUFDTHVLLFNBQVM7WUFDVG5HLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQSxNQUFNMkosc0JBQXNCLEVBQUU7QUFFOUIsU0FBU0MsU0FBUyxHQUFHQyxJQUFJO0lBQ3ZCRixvQkFBb0I1TCxJQUFJLElBQUk4TDtBQUM5QjtBQUVBLFNBQVNDLGVBQWUvRixPQUFPLEVBQUV3QyxPQUFPO0lBQ3RDLElBQUssSUFBSXBILElBQUksR0FBR0MsTUFBTXVLLG9CQUFvQnBOLE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztRQUNqRSxJQUFJNEssZ0JBQWdCSixtQkFBbUIsQ0FBQ3hLLEVBQUU7UUFDMUMsSUFBSTRLLGNBQWNULFNBQVMsQ0FBQ3ZGLFNBQVN3QyxVQUFVO1lBQzdDLE9BQU8sSUFBSXdELGNBQWNoRyxTQUFTd0M7UUFDcEM7SUFDRjtJQUVBLE9BQU8sSUFBSUQsWUFBWXZDLFNBQVN3QztBQUNsQztBQUVBLE1BQU15RCxrQkFBa0I7SUFDdEJDLEtBQUs7SUFDTEMsSUFBSTtBQUNOO0FBRUEsTUFBTUMsVUFBVTtJQUNkQyxNQUFNO0lBQ05DLFNBQVM7QUFDWDtBQUVBLE1BQU1DLGVBQWUsQ0FBQzFCLFFBQ3BCLENBQUMsQ0FBRUEsQ0FBQUEsS0FBSyxDQUFDb0IsZ0JBQWdCQyxHQUFHLENBQUMsSUFBSXJCLEtBQUssQ0FBQ29CLGdCQUFnQkUsRUFBRSxDQUFDO0FBRTVELE1BQU1LLFNBQVMsQ0FBQzNCLFFBQVUsQ0FBQyxDQUFDQSxLQUFLLENBQUN1QixRQUFRQyxJQUFJLENBQUM7QUFFL0MsTUFBTUksU0FBUyxDQUFDNUIsUUFDZCxDQUFDdE4sUUFBUXNOLFVBQVUxTSxTQUFTME0sVUFBVSxDQUFDMEIsYUFBYTFCO0FBRXRELE1BQU02QixvQkFBb0IsQ0FBQzdCLFFBQVc7UUFDcEMsQ0FBQ29CLGdCQUFnQkMsR0FBRyxDQUFDLEVBQUV6TixPQUFPZ0IsSUFBSSxDQUFDb0wsT0FBT2pGLEdBQUcsQ0FBQyxDQUFDN0csTUFBUztnQkFDdEQsQ0FBQ0EsSUFBSSxFQUFFOEwsS0FBSyxDQUFDOUwsSUFBSTtZQUNuQjtJQUNGO0FBRUEsOEVBQThFO0FBQzlFLHNDQUFzQztBQUN0QyxTQUFTNE4sTUFBTTlCLEtBQUssRUFBRXJDLE9BQU8sRUFBRSxFQUFFb0UsT0FBTyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDakQsTUFBTUMsT0FBTyxDQUFDaEM7UUFDWixJQUFJcEwsT0FBT2hCLE9BQU9nQixJQUFJLENBQUNvTDtRQUV2QixNQUFNaUMsY0FBY04sT0FBTzNCO1FBRTNCLElBQUksQ0FBQ2lDLGVBQWVyTixLQUFLakIsTUFBTSxHQUFHLEtBQUssQ0FBQytOLGFBQWExQixRQUFRO1lBQzNELE9BQU9nQyxLQUFLSCxrQkFBa0I3QjtRQUNoQztRQUVBLElBQUk0QixPQUFPNUIsUUFBUTtZQUNqQixNQUFNOUwsTUFBTStOLGNBQWNqQyxLQUFLLENBQUN1QixRQUFRQyxJQUFJLENBQUMsR0FBRzVNLElBQUksQ0FBQyxFQUFFO1lBRXZELE1BQU11RyxVQUFVOEcsY0FBY2pDLEtBQUssQ0FBQ3VCLFFBQVFFLE9BQU8sQ0FBQyxHQUFHekIsS0FBSyxDQUFDOUwsSUFBSTtZQUVqRSxJQUFJLENBQUNoQixTQUFTaUksVUFBVTtnQkFDdEIsTUFBTSxJQUFJbkYsTUFBTS9CLHFDQUFxQ0M7WUFDdkQ7WUFFQSxNQUFNZSxNQUFNO2dCQUNWTSxPQUFPUSxZQUFZN0I7Z0JBQ25CaUg7WUFDRjtZQUVBLElBQUk0RyxNQUFNO2dCQUNSOU0sSUFBSW9MLFFBQVEsR0FBR2EsZUFBZS9GLFNBQVN3QztZQUN6QztZQUVBLE9BQU8xSTtRQUNUO1FBRUEsSUFBSWlOLE9BQU87WUFDVEMsVUFBVSxFQUFFO1lBQ1pDLFVBQVV4TixJQUFJLENBQUMsRUFBRTtRQUNuQjtRQUVBQSxLQUFLSSxPQUFPLENBQUMsQ0FBQ2Q7WUFDWixNQUFNdkIsUUFBUXFOLEtBQUssQ0FBQzlMLElBQUk7WUFFeEIsSUFBSXhCLFFBQVFDLFFBQVE7Z0JBQ2xCQSxNQUFNcUMsT0FBTyxDQUFDLENBQUNrRjtvQkFDYmdJLEtBQUtDLFFBQVEsQ0FBQ2hOLElBQUksQ0FBQzZNLEtBQUs5SDtnQkFDMUI7WUFDRjtRQUNGO1FBRUEsT0FBT2dJO0lBQ1Q7SUFFQSxJQUFJLENBQUNSLGFBQWExQixRQUFRO1FBQ3hCQSxRQUFRNkIsa0JBQWtCN0I7SUFDNUI7SUFFQSxPQUFPZ0MsS0FBS2hDO0FBQ2Q7QUFFQSw2QkFBNkI7QUFDN0IsU0FBU3FDLGFBQ1BuQyxPQUFPLEVBQ1AsRUFBRXJJLGtCQUFrQkUsT0FBT0YsZUFBZSxFQUFFO0lBRTVDcUksUUFBUWxMLE9BQU8sQ0FBQyxDQUFDaEM7UUFDZixJQUFJcUwsYUFBYTtRQUVqQnJMLE9BQU84TCxPQUFPLENBQUM5SixPQUFPLENBQUMsQ0FBQyxFQUFFZCxHQUFHLEVBQUUrRCxJQUFJLEVBQUViLEtBQUssRUFBRTtZQUMxQyxNQUFNL0IsU0FBU25CLE1BQU1BLElBQUltQixNQUFNLEdBQUc7WUFFbENnSixjQUFjL0YsS0FBS0MsR0FBRyxDQUNwQm5CLFVBQVUsS0FBSy9CLFNBQVNpTixPQUFPQyxPQUFPLEdBQUduTCxPQUN6QyxDQUFDL0IsVUFBVSxLQUFNd0MsQ0FBQUEsa0JBQWtCLElBQUlJLElBQUc7UUFFOUM7UUFFQWpGLE9BQU9vRSxLQUFLLEdBQUdpSDtJQUNqQjtBQUNGO0FBRUEsU0FBU21FLGlCQUFpQnhQLE1BQU0sRUFBRWlJLElBQUk7SUFDcEMsTUFBTTZELFVBQVU5TCxPQUFPOEwsT0FBTztJQUM5QjdELEtBQUs2RCxPQUFPLEdBQUcsRUFBRTtJQUVqQixJQUFJLENBQUN2TCxVQUFVdUwsVUFBVTtRQUN2QjtJQUNGO0lBRUFBLFFBQVE5SixPQUFPLENBQUMsQ0FBQ3lEO1FBQ2YsSUFBSSxDQUFDbEYsVUFBVWtGLE1BQU1tRCxPQUFPLEtBQUssQ0FBQ25ELE1BQU1tRCxPQUFPLENBQUNqSSxNQUFNLEVBQUU7WUFDdEQ7UUFDRjtRQUVBLE1BQU0sRUFBRWlJLE9BQU8sRUFBRWpKLEtBQUssRUFBRSxHQUFHOEY7UUFFM0IsSUFBSXhELE1BQU07WUFDUjJHO1lBQ0FqSjtRQUNGO1FBRUEsSUFBSThGLE1BQU12RSxHQUFHLEVBQUU7WUFDYmUsSUFBSWYsR0FBRyxHQUFHdUUsTUFBTXZFLEdBQUcsQ0FBQzBCLEdBQUc7UUFDekI7UUFFQSxJQUFJNkMsTUFBTXBCLEdBQUcsR0FBRyxDQUFDLEdBQUc7WUFDbEJwQyxJQUFJd04sUUFBUSxHQUFHaEssTUFBTXBCLEdBQUc7UUFDMUI7UUFFQTRELEtBQUs2RCxPQUFPLENBQUMzSixJQUFJLENBQUNGO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTeU4sZUFBZTFQLE1BQU0sRUFBRWlJLElBQUk7SUFDbENBLEtBQUs3RCxLQUFLLEdBQUdwRSxPQUFPb0UsS0FBSztBQUMzQjtBQUVBLFNBQVN1TCxPQUNQekMsT0FBTyxFQUNQOUcsSUFBSSxFQUNKLEVBQ0UxQyxpQkFBaUJxQixPQUFPckIsY0FBYyxFQUN0Q0ssZUFBZWdCLE9BQU9oQixZQUFZLEVBQ25DLEdBQUcsQ0FBQyxDQUFDO0lBRU4sTUFBTTZMLGVBQWUsRUFBRTtJQUV2QixJQUFJbE0sZ0JBQWdCa00sYUFBYXpOLElBQUksQ0FBQ3FOO0lBQ3RDLElBQUl6TCxjQUFjNkwsYUFBYXpOLElBQUksQ0FBQ3VOO0lBRXBDLE9BQU94QyxRQUFRbkYsR0FBRyxDQUFDLENBQUMvSDtRQUNsQixNQUFNLEVBQUVxRSxHQUFHLEVBQUUsR0FBR3JFO1FBRWhCLE1BQU1pSSxPQUFPO1lBQ1hmLE1BQU1kLElBQUksQ0FBQy9CLElBQUk7WUFDZm9MLFVBQVVwTDtRQUNaO1FBRUEsSUFBSXVMLGFBQWFqUCxNQUFNLEVBQUU7WUFDdkJpUCxhQUFhNU4sT0FBTyxDQUFDLENBQUM2TjtnQkFDcEJBLFlBQVk3UCxRQUFRaUk7WUFDdEI7UUFDRjtRQUVBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLE1BQU02SDtJQUNKbk8sWUFBWXlFLElBQUksRUFBRXVFLFVBQVUsQ0FBQyxDQUFDLEVBQUVySCxLQUFLLENBQUU7UUFDckMsSUFBSSxDQUFDcUgsT0FBTyxHQUFHO1lBQUUsR0FBRzVGLE1BQU07WUFBRSxHQUFHNEYsT0FBTztRQUFDO1FBRXZDLElBQ0UsSUFBSSxDQUFDQSxPQUFPLENBQUNoRyxpQkFBaUIsSUFDOUIsQ0FBQyxNQUNELEVBRUQ7UUFFRCxJQUFJLENBQUNvTCxTQUFTLEdBQUcsSUFBSXJPLFNBQVMsSUFBSSxDQUFDaUosT0FBTyxDQUFDL0ksSUFBSTtRQUUvQyxJQUFJLENBQUNvTyxhQUFhLENBQUM1SixNQUFNOUM7SUFDM0I7SUFFQTBNLGNBQWM1SixJQUFJLEVBQUU5QyxLQUFLLEVBQUU7UUFDekIsSUFBSSxDQUFDMk0sS0FBSyxHQUFHN0o7UUFFYixJQUFJOUMsU0FBUyxDQUFFQSxDQUFBQSxpQkFBaUIwQyxTQUFRLEdBQUk7WUFDMUMsTUFBTSxJQUFJaEQsTUFBTWhDO1FBQ2xCO1FBRUEsSUFBSSxDQUFDa1AsUUFBUSxHQUNYNU0sU0FDQXVFLFlBQVksSUFBSSxDQUFDOEMsT0FBTyxDQUFDL0ksSUFBSSxFQUFFLElBQUksQ0FBQ3FPLEtBQUssRUFBRTtZQUN6Q3BOLE9BQU8sSUFBSSxDQUFDOEgsT0FBTyxDQUFDOUgsS0FBSztZQUN6QmlDLGlCQUFpQixJQUFJLENBQUM2RixPQUFPLENBQUM3RixlQUFlO1FBQy9DO0lBQ0o7SUFFQStCLElBQUlKLEdBQUcsRUFBRTtRQUNQLElBQUksQ0FBQ2xHLFVBQVVrRyxNQUFNO1lBQ25CO1FBQ0Y7UUFFQSxJQUFJLENBQUN3SixLQUFLLENBQUM5TixJQUFJLENBQUNzRTtRQUNoQixJQUFJLENBQUN5SixRQUFRLENBQUNySixHQUFHLENBQUNKO0lBQ3BCO0lBRUEwSixPQUFPQyxZQUFZLElBQW9CLEtBQUssRUFBRTtRQUM1QyxNQUFNbEQsVUFBVSxFQUFFO1FBRWxCLElBQUssSUFBSTNKLElBQUksR0FBR0MsTUFBTSxJQUFJLENBQUN5TSxLQUFLLENBQUN0UCxNQUFNLEVBQUU0QyxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDeEQsTUFBTWtELE1BQU0sSUFBSSxDQUFDd0osS0FBSyxDQUFDMU0sRUFBRTtZQUN6QixJQUFJNk0sVUFBVTNKLEtBQUtsRCxJQUFJO2dCQUNyQixJQUFJLENBQUN3RCxRQUFRLENBQUN4RDtnQkFDZEEsS0FBSztnQkFDTEMsT0FBTztnQkFFUDBKLFFBQVEvSyxJQUFJLENBQUNzRTtZQUNmO1FBQ0Y7UUFFQSxPQUFPeUc7SUFDVDtJQUVBbkcsU0FBUzFDLEdBQUcsRUFBRTtRQUNaLElBQUksQ0FBQzRMLEtBQUssQ0FBQ2pKLE1BQU0sQ0FBQzNDLEtBQUs7UUFDdkIsSUFBSSxDQUFDNkwsUUFBUSxDQUFDbkosUUFBUSxDQUFDMUM7SUFDekI7SUFFQWdNLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ0gsUUFBUTtJQUN0QjtJQUVBbEgsT0FBT2dFLEtBQUssRUFBRSxFQUFFc0QsUUFBUSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ2pDLE1BQU0sRUFDSjVNLGNBQWMsRUFDZEssWUFBWSxFQUNaQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTlksZUFBZSxFQUNoQixHQUFHLElBQUksQ0FBQzhGLE9BQU87UUFFaEIsSUFBSXVDLFVBQVVoTixTQUFTOE0sU0FDbkI5TSxTQUFTLElBQUksQ0FBQytQLEtBQUssQ0FBQyxFQUFFLElBQ3BCLElBQUksQ0FBQ00saUJBQWlCLENBQUN2RCxTQUN2QixJQUFJLENBQUN3RCxpQkFBaUIsQ0FBQ3hELFNBQ3pCLElBQUksQ0FBQ3lELGNBQWMsQ0FBQ3pEO1FBRXhCcUMsYUFBYW5DLFNBQVM7WUFBRXJJO1FBQWdCO1FBRXhDLElBQUliLFlBQVk7WUFDZGtKLFFBQVF3RCxJQUFJLENBQUN6TTtRQUNmO1FBRUEsSUFBSTlELFNBQVNtUSxVQUFVQSxRQUFRLENBQUMsR0FBRztZQUNqQ3BELFVBQVVBLFFBQVF5RCxLQUFLLENBQUMsR0FBR0w7UUFDN0I7UUFFQSxPQUFPWCxPQUFPekMsU0FBUyxJQUFJLENBQUMrQyxLQUFLLEVBQUU7WUFDakN2TTtZQUNBSztRQUNGO0lBQ0Y7SUFFQXdNLGtCQUFrQnZELEtBQUssRUFBRTtRQUN2QixNQUFNSyxXQUFXYSxlQUFlbEIsT0FBTyxJQUFJLENBQUNyQyxPQUFPO1FBQ25ELE1BQU0sRUFBRXRFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQzZKLFFBQVE7UUFDakMsTUFBTWhELFVBQVUsRUFBRTtRQUVsQix5Q0FBeUM7UUFDekM3RyxRQUFRckUsT0FBTyxDQUFDLENBQUMsRUFBRW9GLEdBQUc2QixJQUFJLEVBQUUxRixHQUFHYyxHQUFHLEVBQUVzQixHQUFHVixJQUFJLEVBQUU7WUFDM0MsSUFBSSxDQUFDMUUsVUFBVTBJLE9BQU87Z0JBQ3BCO1lBQ0Y7WUFFQSxNQUFNLEVBQUVzQixPQUFPLEVBQUVuRyxLQUFLLEVBQUV3RSxPQUFPLEVBQUUsR0FBR3lFLFNBQVNsQyxRQUFRLENBQUNsQztZQUV0RCxJQUFJc0IsU0FBUztnQkFDWDJDLFFBQVEvSyxJQUFJLENBQUM7b0JBQ1grRSxNQUFNK0I7b0JBQ041RTtvQkFDQXlILFNBQVM7d0JBQUM7NEJBQUUxSDs0QkFBT3pFLE9BQU9zSjs0QkFBTWhFOzRCQUFNMkQ7d0JBQVE7cUJBQUU7Z0JBQ2xEO1lBQ0Y7UUFDRjtRQUVBLE9BQU9zRTtJQUNUO0lBRUF1RCxlQUFlekQsS0FBSyxFQUFFO1FBRXBCLE1BQU00RCxhQUFhOUIsTUFBTTlCLE9BQU8sSUFBSSxDQUFDckMsT0FBTztRQUU1QyxNQUFNa0csV0FBVyxDQUFDM0IsTUFBTWhJLE1BQU03QztZQUM1QixJQUFJLENBQUM2SyxLQUFLQyxRQUFRLEVBQUU7Z0JBQ2xCLE1BQU0sRUFBRTVNLEtBQUssRUFBRThLLFFBQVEsRUFBRSxHQUFHNkI7Z0JBRTVCLE1BQU1wRCxVQUFVLElBQUksQ0FBQ2dGLFlBQVksQ0FBQztvQkFDaEM1UCxLQUFLLElBQUksQ0FBQzZPLFNBQVMsQ0FBQ3pOLEdBQUcsQ0FBQ0M7b0JBQ3hCNUMsT0FBTyxJQUFJLENBQUN1USxRQUFRLENBQUNqSixzQkFBc0IsQ0FBQ0MsTUFBTTNFO29CQUNsRDhLO2dCQUNGO2dCQUVBLElBQUl2QixXQUFXQSxRQUFRbkwsTUFBTSxFQUFFO29CQUM3QixPQUFPO3dCQUNMOzRCQUNFMEQ7NEJBQ0E2Qzs0QkFDQTRFO3dCQUNGO3FCQUNEO2dCQUNIO2dCQUVBLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTWlGLE1BQU0sRUFBRTtZQUNkLElBQUssSUFBSXhOLElBQUksR0FBR0MsTUFBTTBMLEtBQUtDLFFBQVEsQ0FBQ3hPLE1BQU0sRUFBRTRDLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0QsTUFBTXlOLFFBQVE5QixLQUFLQyxRQUFRLENBQUM1TCxFQUFFO2dCQUM5QixNQUFNdkQsU0FBUzZRLFNBQVNHLE9BQU85SixNQUFNN0M7Z0JBQ3JDLElBQUlyRSxPQUFPVyxNQUFNLEVBQUU7b0JBQ2pCb1EsSUFBSTVPLElBQUksSUFBSW5DO2dCQUNkLE9BQU8sSUFBSWtQLEtBQUtFLFFBQVEsS0FBS2hCLGdCQUFnQkMsR0FBRyxFQUFFO29CQUNoRCxPQUFPLEVBQUU7Z0JBQ1g7WUFDRjtZQUNBLE9BQU8wQztRQUNUO1FBRUEsTUFBTTFLLFVBQVUsSUFBSSxDQUFDNkosUUFBUSxDQUFDN0osT0FBTztRQUNyQyxNQUFNNEssWUFBWSxDQUFDO1FBQ25CLE1BQU0vRCxVQUFVLEVBQUU7UUFFbEI3RyxRQUFRckUsT0FBTyxDQUFDLENBQUMsRUFBRXFGLEdBQUdILElBQUksRUFBRTNELEdBQUdjLEdBQUcsRUFBRTtZQUNsQyxJQUFJOUQsVUFBVTJHLE9BQU87Z0JBQ25CLElBQUlnSyxhQUFhTCxTQUFTRCxZQUFZMUosTUFBTTdDO2dCQUU1QyxJQUFJNk0sV0FBV3ZRLE1BQU0sRUFBRTtvQkFDckIscUJBQXFCO29CQUNyQixJQUFJLENBQUNzUSxTQUFTLENBQUM1TSxJQUFJLEVBQUU7d0JBQ25CNE0sU0FBUyxDQUFDNU0sSUFBSSxHQUFHOzRCQUFFQTs0QkFBSzZDOzRCQUFNNEUsU0FBUyxFQUFFO3dCQUFDO3dCQUMxQ29CLFFBQVEvSyxJQUFJLENBQUM4TyxTQUFTLENBQUM1TSxJQUFJO29CQUM3QjtvQkFDQTZNLFdBQVdsUCxPQUFPLENBQUMsQ0FBQyxFQUFFOEosT0FBTyxFQUFFO3dCQUM3Qm1GLFNBQVMsQ0FBQzVNLElBQUksQ0FBQ3lILE9BQU8sQ0FBQzNKLElBQUksSUFBSTJKO29CQUNqQztnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPb0I7SUFDVDtJQUVBc0Qsa0JBQWtCeEQsS0FBSyxFQUFFO1FBQ3ZCLE1BQU1LLFdBQVdhLGVBQWVsQixPQUFPLElBQUksQ0FBQ3JDLE9BQU87UUFDbkQsTUFBTSxFQUFFL0ksSUFBSSxFQUFFeUUsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDNkosUUFBUTtRQUN2QyxNQUFNaEQsVUFBVSxFQUFFO1FBRWxCLHdCQUF3QjtRQUN4QjdHLFFBQVFyRSxPQUFPLENBQUMsQ0FBQyxFQUFFcUYsR0FBR0gsSUFBSSxFQUFFM0QsR0FBR2MsR0FBRyxFQUFFO1lBQ2xDLElBQUksQ0FBQzlELFVBQVUyRyxPQUFPO2dCQUNwQjtZQUNGO1lBRUEsSUFBSTRFLFVBQVUsRUFBRTtZQUVoQixzRUFBc0U7WUFDdEVsSyxLQUFLSSxPQUFPLENBQUMsQ0FBQ2QsS0FBS29HO2dCQUNqQndFLFFBQVEzSixJQUFJLElBQ1AsSUFBSSxDQUFDMk8sWUFBWSxDQUFDO29CQUNuQjVQO29CQUNBdkIsT0FBT3VILElBQUksQ0FBQ0ksU0FBUztvQkFDckIrRjtnQkFDRjtZQUVKO1lBRUEsSUFBSXZCLFFBQVFuTCxNQUFNLEVBQUU7Z0JBQ2xCdU0sUUFBUS9LLElBQUksQ0FBQztvQkFDWGtDO29CQUNBNkM7b0JBQ0E0RTtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPb0I7SUFDVDtJQUNBNEQsYUFBYSxFQUFFNVAsR0FBRyxFQUFFdkIsS0FBSyxFQUFFME4sUUFBUSxFQUFFLEVBQUU7UUFDckMsSUFBSSxDQUFDOU0sVUFBVVosUUFBUTtZQUNyQixPQUFPLEVBQUU7UUFDWDtRQUVBLElBQUltTSxVQUFVLEVBQUU7UUFFaEIsSUFBSXBNLFFBQVFDLFFBQVE7WUFDbEJBLE1BQU1xQyxPQUFPLENBQUMsQ0FBQyxFQUFFb0YsR0FBRzZCLElBQUksRUFBRTFGLEdBQUdjLEdBQUcsRUFBRXNCLEdBQUdWLElBQUksRUFBRTtnQkFDekMsSUFBSSxDQUFDMUUsVUFBVTBJLE9BQU87b0JBQ3BCO2dCQUNGO2dCQUVBLE1BQU0sRUFBRXNCLE9BQU8sRUFBRW5HLEtBQUssRUFBRXdFLE9BQU8sRUFBRSxHQUFHeUUsU0FBU2xDLFFBQVEsQ0FBQ2xDO2dCQUV0RCxJQUFJc0IsU0FBUztvQkFDWHVCLFFBQVEzSixJQUFJLENBQUM7d0JBQ1hpQzt3QkFDQWxEO3dCQUNBdkIsT0FBT3NKO3dCQUNQNUU7d0JBQ0FZO3dCQUNBMkQ7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU87WUFDTCxNQUFNLEVBQUV4QixHQUFHNkIsSUFBSSxFQUFFdEQsR0FBR1YsSUFBSSxFQUFFLEdBQUd0RjtZQUU3QixNQUFNLEVBQUU0SyxPQUFPLEVBQUVuRyxLQUFLLEVBQUV3RSxPQUFPLEVBQUUsR0FBR3lFLFNBQVNsQyxRQUFRLENBQUNsQztZQUV0RCxJQUFJc0IsU0FBUztnQkFDWHVCLFFBQVEzSixJQUFJLENBQUM7b0JBQUVpQztvQkFBT2xEO29CQUFLdkIsT0FBT3NKO29CQUFNaEU7b0JBQU0yRDtnQkFBUTtZQUN4RDtRQUNGO1FBRUEsT0FBT2tEO0lBQ1Q7QUFDRjtBQUVBZ0UsS0FBS3FCLE9BQU8sR0FBRztBQUNmckIsS0FBS2pJLFdBQVcsR0FBR0E7QUFDbkJpSSxLQUFLOUgsVUFBVSxHQUFHQTtBQUNsQjhILEtBQUtzQixNQUFNLEdBQUdyTTtBQUVkO0lBQ0UrSyxLQUFLL0MsVUFBVSxHQUFHK0I7QUFDcEIsQ0FFQTtJQUNFZCxTQUFTUDtBQUNYLENBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViM2RldmNvdXJzZS8uL25vZGVfbW9kdWxlcy9mdXNlLmpzL2Rpc3QvZnVzZS5tanM/ZmFlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZ1c2UuanMgdjcuMC4wIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMyBLaXJvIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXlcbiAgICA/IGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VUb1N0cmluZy5qc1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNCb29sZWFuLmpzXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gdHJ1ZSB8fFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbi8vIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZS50cmltKCkubGVuZ3RoXG59XG5cbi8vIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgPyB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nXG4gICAgICA6ICdbb2JqZWN0IE51bGxdJ1xuICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG5jb25zdCBFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUgPSAnRXh0ZW5kZWQgc2VhcmNoIGlzIG5vdCBhdmFpbGFibGUnO1xuXG5jb25zdCBJTkNPUlJFQ1RfSU5ERVhfVFlQRSA9IFwiSW5jb3JyZWN0ICdpbmRleCcgdHlwZVwiO1xuXG5jb25zdCBMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkgPSAoa2V5KSA9PlxuICBgSW52YWxpZCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWA7XG5cbmNvbnN0IFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSA9IChtYXgpID0+XG4gIGBQYXR0ZXJuIGxlbmd0aCBleGNlZWRzIG1heCBvZiAke21heH0uYDtcblxuY29uc3QgTUlTU0lOR19LRVlfUFJPUEVSVFkgPSAobmFtZSkgPT4gYE1pc3NpbmcgJHtuYW1lfSBwcm9wZXJ0eSBpbiBrZXlgO1xuXG5jb25zdCBJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUgPSAoa2V5KSA9PlxuICBgUHJvcGVydHkgJ3dlaWdodCcgaW4ga2V5ICcke2tleX0nIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYDtcblxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY2xhc3MgS2V5U3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX2tleU1hcCA9IHt9O1xuXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBsZXQgb2JqID0gY3JlYXRlS2V5KGtleSk7XG5cbiAgICAgIHRoaXMuX2tleXMucHVzaChvYmopO1xuICAgICAgdGhpcy5fa2V5TWFwW29iai5pZF0gPSBvYmo7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0cyBzbyB0aGF0IHRoZWlyIHN1bSBpcyBlcXVhbCB0byAxXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGtleS53ZWlnaHQgLz0gdG90YWxXZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleU1hcFtrZXlJZF1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZXlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgbGV0IHBhdGggPSBudWxsO1xuICBsZXQgaWQgPSBudWxsO1xuICBsZXQgc3JjID0gbnVsbDtcbiAgbGV0IHdlaWdodCA9IDE7XG4gIGxldCBnZXRGbiA9IG51bGw7XG5cbiAgaWYgKGlzU3RyaW5nKGtleSkgfHwgaXNBcnJheShrZXkpKSB7XG4gICAgc3JjID0ga2V5O1xuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKGtleSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaGFzT3duLmNhbGwoa2V5LCAnbmFtZScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19LRVlfUFJPUEVSVFkoJ25hbWUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0ga2V5Lm5hbWU7XG4gICAgc3JjID0gbmFtZTtcblxuICAgIGlmIChoYXNPd24uY2FsbChrZXksICd3ZWlnaHQnKSkge1xuICAgICAgd2VpZ2h0ID0ga2V5LndlaWdodDtcblxuICAgICAgaWYgKHdlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUobmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgobmFtZSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChuYW1lKTtcbiAgICBnZXRGbiA9IGtleS5nZXRGbjtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGgsIGlkLCB3ZWlnaHQsIHNyYywgZ2V0Rm4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQYXRoKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5SWQoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkuam9pbignLicpIDoga2V5XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgbGV0IGFyciA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAob2JqLCBwYXRoLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhdGggbGVmdCwgd2UndmUgYXJyaXZlZCBhdCB0aGUgb2JqZWN0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRoLCBhbmQgaWYgaXQncyBhIHN0cmluZy9udW1iZXIvYm9vbCxcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpIHx8IGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICApIHtcbiAgICAgICAgbGlzdC5wdXNoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyciA9IHRydWU7XG4gICAgICAgIC8vIFNlYXJjaCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBkZWVwR2V0KHZhbHVlW2ldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFuIG9iamVjdC4gUmVjdXJzZSBmdXJ0aGVyLlxuICAgICAgICBkZWVwR2V0KHZhbHVlLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2luY2UgcGF0aCB1c2VkIHRvIGJlIGEgc3RyaW5nKVxuICBkZWVwR2V0KG9iaiwgaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCcuJykgOiBwYXRoLCAwKTtcblxuICByZXR1cm4gYXJyID8gbGlzdCA6IGxpc3RbMF1cbn1cblxuY29uc3QgTWF0Y2hPcHRpb25zID0ge1xuICAvLyBXaGV0aGVyIHRoZSBtYXRjaGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gV2hlbiBgdHJ1ZWAsIGVhY2ggcmVjb3JkIGluIHRoZSByZXN1bHRcbiAgLy8gc2V0IHdpbGwgaW5jbHVkZSB0aGUgaW5kaWNlcyBvZiB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXJzLlxuICAvLyBUaGVzZSBjYW4gY29uc2VxdWVudGx5IGJlIHVzZWQgZm9yIGhpZ2hsaWdodGluZyBwdXJwb3Nlcy5cbiAgaW5jbHVkZU1hdGNoZXM6IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgLy8gYSBwZXJmZWN0IG1hdGNoIGhhcyBhbHJlYWR5IGJlZW4gbG9jYXRlZCBpbiB0aGUgc3RyaW5nLlxuICBmaW5kQWxsTWF0Y2hlczogZmFsc2UsXG4gIC8vIE1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIG1hdGNoZWQgYmVmb3JlIGEgcmVzdWx0IGlzIGNvbnNpZGVyZWQgYSBtYXRjaFxuICBtaW5NYXRjaENoYXJMZW5ndGg6IDFcbn07XG5cbmNvbnN0IEJhc2ljT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gY29udGludWVzIHNlYXJjaGluZyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBldmVuIGlmIGEgcGVyZmVjdFxuICAvLyBtYXRjaCBpcyBmb3VuZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc2FtZSBpbnB1dC5cbiAgaXNDYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgLy8gV2hlbiB0cnVlLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICBpbmNsdWRlU2NvcmU6IGZhbHNlLFxuICAvLyBMaXN0IG9mIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNlYXJjaGVkLiBUaGlzIGFsc28gc3VwcG9ydHMgbmVzdGVkIHByb3BlcnRpZXMuXG4gIGtleXM6IFtdLFxuICAvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIHJlc3VsdCBsaXN0LCBieSBzY29yZVxuICBzaG91bGRTb3J0OiB0cnVlLFxuICAvLyBEZWZhdWx0IHNvcnQgZnVuY3Rpb246IHNvcnQgYnkgYXNjZW5kaW5nIHNjb3JlLCBhc2NlbmRpbmcgaW5kZXhcbiAgc29ydEZuOiAoYSwgYikgPT5cbiAgICBhLnNjb3JlID09PSBiLnNjb3JlID8gKGEuaWR4IDwgYi5pZHggPyAtMSA6IDEpIDogYS5zY29yZSA8IGIuc2NvcmUgPyAtMSA6IDFcbn07XG5cbmNvbnN0IEZ1enp5T3B0aW9ucyA9IHtcbiAgLy8gQXBwcm94aW1hdGVseSB3aGVyZSBpbiB0aGUgdGV4dCBpcyB0aGUgcGF0dGVybiBleHBlY3RlZCB0byBiZSBmb3VuZD9cbiAgbG9jYXRpb246IDAsXG4gIC8vIEF0IHdoYXQgcG9pbnQgZG9lcyB0aGUgbWF0Y2ggYWxnb3JpdGhtIGdpdmUgdXAuIEEgdGhyZXNob2xkIG9mICcwLjAnIHJlcXVpcmVzIGEgcGVyZmVjdCBtYXRjaFxuICAvLyAob2YgYm90aCBsZXR0ZXJzIGFuZCBsb2NhdGlvbiksIGEgdGhyZXNob2xkIG9mICcxLjAnIHdvdWxkIG1hdGNoIGFueXRoaW5nLlxuICB0aHJlc2hvbGQ6IDAuNixcbiAgLy8gRGV0ZXJtaW5lcyBob3cgY2xvc2UgdGhlIG1hdGNoIG11c3QgYmUgdG8gdGhlIGZ1enp5IGxvY2F0aW9uIChzcGVjaWZpZWQgYWJvdmUpLlxuICAvLyBBbiBleGFjdCBsZXR0ZXIgbWF0Y2ggd2hpY2ggaXMgJ2Rpc3RhbmNlJyBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZnV6enkgbG9jYXRpb25cbiAgLy8gd291bGQgc2NvcmUgYXMgYSBjb21wbGV0ZSBtaXNtYXRjaC4gQSBkaXN0YW5jZSBvZiAnMCcgcmVxdWlyZXMgdGhlIG1hdGNoIGJlIGF0XG4gIC8vIHRoZSBleGFjdCBsb2NhdGlvbiBzcGVjaWZpZWQsIGEgdGhyZXNob2xkIG9mICcxMDAwJyB3b3VsZCByZXF1aXJlIGEgcGVyZmVjdCBtYXRjaFxuICAvLyB0byBiZSB3aXRoaW4gODAwIGNoYXJhY3RlcnMgb2YgdGhlIGZ1enp5IGxvY2F0aW9uIHRvIGJlIGZvdW5kIHVzaW5nIGEgMC44IHRocmVzaG9sZC5cbiAgZGlzdGFuY2U6IDEwMFxufTtcblxuY29uc3QgQWR2YW5jZWRPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgaXQgZW5hYmxlcyB0aGUgdXNlIG9mIHVuaXgtbGlrZSBzZWFyY2ggY29tbWFuZHNcbiAgdXNlRXh0ZW5kZWRTZWFyY2g6IGZhbHNlLFxuICAvLyBUaGUgZ2V0IGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGZldGNoaW5nIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgc2VhcmNoIG5lc3RlZCBwYXRocyAqaWUgZm9vLmJhci5iYXoqXG4gIGdldEZuOiBnZXQsXG4gIC8vIFdoZW4gYHRydWVgLCBzZWFyY2ggd2lsbCBpZ25vcmUgYGxvY2F0aW9uYCBhbmQgYGRpc3RhbmNlYCwgc28gaXQgd29uJ3QgbWF0dGVyXG4gIC8vIHdoZXJlIGluIHRoZSBzdHJpbmcgdGhlIHBhdHRlcm4gYXBwZWFycy5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2Z1enppbmVzcy1zY29yZVxuICBpZ25vcmVMb2NhdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSByZWxldmFuY2Ugc2NvcmUgKHVzZWQgZm9yIHNvcnRpbmcpIHdpbGxcbiAgLy8gaWdub3JlIHRoZSBmaWVsZC1sZW5ndGggbm9ybS5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2ZpZWxkLWxlbmd0aC1ub3JtXG4gIGlnbm9yZUZpZWxkTm9ybTogZmFsc2UsXG4gIC8vIFRoZSB3ZWlnaHQgdG8gZGV0ZXJtaW5lIGhvdyBtdWNoIGZpZWxkIGxlbmd0aCBub3JtIGVmZmVjdHMgc2NvcmluZy5cbiAgZmllbGROb3JtV2VpZ2h0OiAxXG59O1xuXG52YXIgQ29uZmlnID0ge1xuICAuLi5CYXNpY09wdGlvbnMsXG4gIC4uLk1hdGNoT3B0aW9ucyxcbiAgLi4uRnV6enlPcHRpb25zLFxuICAuLi5BZHZhbmNlZE9wdGlvbnNcbn07XG5cbmNvbnN0IFNQQUNFID0gL1teIF0rL2c7XG5cbi8vIEZpZWxkLWxlbmd0aCBub3JtOiB0aGUgc2hvcnRlciB0aGUgZmllbGQsIHRoZSBoaWdoZXIgdGhlIHdlaWdodC5cbi8vIFNldCB0byAzIGRlY2ltYWxzIHRvIHJlZHVjZSBpbmRleCBzaXplLlxuZnVuY3Rpb24gbm9ybSh3ZWlnaHQgPSAxLCBtYW50aXNzYSA9IDMpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG0gPSBNYXRoLnBvdygxMCwgbWFudGlzc2EpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0KHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1Ub2tlbnMgPSB2YWx1ZS5tYXRjaChTUEFDRSkubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKG51bVRva2VucykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChudW1Ub2tlbnMpXG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gaXMgMS9zcXJ0KHgpLCB3ZWlnaHQgbWFrZXMgdGhhdCB2YXJpYWJsZVxuICAgICAgY29uc3Qgbm9ybSA9IDEgLyBNYXRoLnBvdyhudW1Ub2tlbnMsIDAuNSAqIHdlaWdodCk7XG5cbiAgICAgIC8vIEluIHBsYWNlIG9mIGB0b0ZpeGVkKG1hbnRpc3NhKWAsIGZvciBmYXN0ZXIgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KE1hdGgucm91bmQobm9ybSAqIG0pIC8gbSk7XG5cbiAgICAgIGNhY2hlLnNldChudW1Ub2tlbnMsIG4pO1xuXG4gICAgICByZXR1cm4gblxuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXNlSW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sXG4gICAgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodFxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5vcm0gPSBub3JtKGZpZWxkTm9ybVdlaWdodCwgMyk7XG4gICAgdGhpcy5nZXRGbiA9IGdldEZuO1xuICAgIHRoaXMuaXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEluZGV4UmVjb3JkcygpO1xuICB9XG4gIHNldFNvdXJjZXMoZG9jcyA9IFtdKSB7XG4gICAgdGhpcy5kb2NzID0gZG9jcztcbiAgfVxuICBzZXRJbmRleFJlY29yZHMocmVjb3JkcyA9IFtdKSB7XG4gICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcbiAgfVxuICBzZXRLZXlzKGtleXMgPSBbXSkge1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5fa2V5c01hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHtcbiAgICAgIHRoaXMuX2tleXNNYXBba2V5LmlkXSA9IGlkeDtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNDcmVhdGVkIHx8ICF0aGlzLmRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmlzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PFN0cmluZz5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5kb2NzWzBdKSkge1xuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3JtLmNsZWFyKCk7XG4gIH1cbiAgLy8gQWRkcyBhIGRvYyB0byB0aGUgZW5kIG9mIHRoZSBpbmRleFxuICBhZGQoZG9jKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5zaXplKCk7XG5cbiAgICBpZiAoaXNTdHJpbmcoZG9jKSkge1xuICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgaWR4KTtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlcyB0aGUgZG9jIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb2YgdGhlIGluZGV4XG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMucmVjb3Jkcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIC8vIENoYW5nZSByZWYgaW5kZXggb2YgZXZlcnkgc3Vic3F1ZW50IGRvY1xuICAgIGZvciAobGV0IGkgPSBpZHgsIGxlbiA9IHRoaXMuc2l6ZSgpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucmVjb3Jkc1tpXS5pIC09IDE7XG4gICAgfVxuICB9XG4gIGdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpIHtcbiAgICByZXR1cm4gaXRlbVt0aGlzLl9rZXlzTWFwW2tleUlkXV1cbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMubGVuZ3RoXG4gIH1cbiAgX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSB8fCBpc0JsYW5rKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZWNvcmQgPSB7XG4gICAgICB2OiBkb2MsXG4gICAgICBpOiBkb2NJbmRleCxcbiAgICAgIG46IHRoaXMubm9ybS5nZXQoZG9jKVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIF9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCkge1xuICAgIGxldCByZWNvcmQgPSB7IGk6IGRvY0luZGV4LCAkOiB7fSB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgIHRoaXMua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBrZXkuZ2V0Rm4gPyBrZXkuZ2V0Rm4oZG9jKSA6IHRoaXMuZ2V0Rm4oZG9jLCBrZXkucGF0aCk7XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW3sgbmVzdGVkQXJySW5kZXg6IC0xLCB2YWx1ZSB9XTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgeyBuZXN0ZWRBcnJJbmRleCwgdmFsdWUgfSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICAgICAgaTogbmVzdGVkQXJySW5kZXgsXG4gICAgICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJSZWNvcmRzLnB1c2goc3ViUmVjb3JkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBrKSA9PiB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIG5lc3RlZEFyckluZGV4OiBrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIDtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmRzO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcblxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgcmVjb3JkczogdGhpcy5yZWNvcmRzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4KFxuICBrZXlzLFxuICBkb2NzLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMubWFwKGNyZWF0ZUtleSkpO1xuICBteUluZGV4LnNldFNvdXJjZXMoZG9jcyk7XG4gIG15SW5kZXguY3JlYXRlKCk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5kZXgoXG4gIGRhdGEsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSBkYXRhO1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzKTtcbiAgbXlJbmRleC5zZXRJbmRleFJlY29yZHMocmVjb3Jkcyk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZSQxKFxuICBwYXR0ZXJuLFxuICB7XG4gICAgZXJyb3JzID0gMCxcbiAgICBjdXJyZW50TG9jYXRpb24gPSAwLFxuICAgIGV4cGVjdGVkTG9jYXRpb24gPSAwLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gZXJyb3JzIC8gcGF0dGVybi5sZW5ndGg7XG5cbiAgaWYgKGlnbm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGFjY3VyYWN5XG4gIH1cblxuICBjb25zdCBwcm94aW1pdHkgPSBNYXRoLmFicyhleHBlY3RlZExvY2F0aW9uIC0gY3VycmVudExvY2F0aW9uKTtcblxuICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgcmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5XG4gIH1cblxuICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBkaXN0YW5jZVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TWFza1RvSW5kaWNlcyhcbiAgbWF0Y2htYXNrID0gW10sXG4gIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGhcbikge1xuICBsZXQgaW5kaWNlcyA9IFtdO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgbGVuID0gbWF0Y2htYXNrLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2htYXNrW2ldO1xuICAgIGlmIChtYXRjaCAmJiBzdGFydCA9PT0gLTEpIHtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgIGVuZCA9IGkgLSAxO1xuICAgICAgaWYgKGVuZCAtIHN0YXJ0ICsgMSA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIChpLTEgLSBzdGFydCkgKyAxID0+IGkgLSBzdGFydFxuICBpZiAobWF0Y2htYXNrW2kgLSAxXSAmJiBpIC0gc3RhcnQgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgaSAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzXG59XG5cbi8vIE1hY2hpbmUgd29yZCBzaXplXG5jb25zdCBNQVhfQklUUyA9IDMyO1xuXG5mdW5jdGlvbiBzZWFyY2goXG4gIHRleHQsXG4gIHBhdHRlcm4sXG4gIHBhdHRlcm5BbHBoYWJldCxcbiAge1xuICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUykge1xuICAgIHRocm93IG5ldyBFcnJvcihQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UoTUFYX0JJVFMpKVxuICB9XG5cbiAgY29uc3QgcGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAvLyBTZXQgc3RhcnRpbmcgbG9jYXRpb24gYXQgYmVnaW5uaW5nIHRleHQgYW5kIGluaXRpYWxpemUgdGhlIGFscGhhYmV0LlxuICBjb25zdCB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIGxvY2F0aW9uID4gdGV4dC5sZW5ndGhcbiAgY29uc3QgZXhwZWN0ZWRMb2NhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvY2F0aW9uLCB0ZXh0TGVuKSk7XG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXG4gIGxldCBjdXJyZW50VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIGxldCBiZXN0TG9jYXRpb24gPSBleHBlY3RlZExvY2F0aW9uO1xuXG4gIC8vIFBlcmZvcm1hbmNlOiBvbmx5IGNvbXB1dGVyIG1hdGNoZXMgd2hlbiB0aGUgbWluTWF0Y2hDaGFyTGVuZ3RoID4gMVxuICAvLyBPUiBpZiBgaW5jbHVkZU1hdGNoZXNgIGlzIHRydWUuXG4gIGNvbnN0IGNvbXB1dGVNYXRjaGVzID0gbWluTWF0Y2hDaGFyTGVuZ3RoID4gMSB8fCBpbmNsdWRlTWF0Y2hlcztcbiAgLy8gQSBtYXNrIG9mIHRoZSBtYXRjaGVzLCB1c2VkIGZvciBidWlsZGluZyB0aGUgaW5kaWNlc1xuICBjb25zdCBtYXRjaE1hc2sgPSBjb21wdXRlTWF0Y2hlcyA/IEFycmF5KHRleHRMZW4pIDogW107XG5cbiAgbGV0IGluZGV4O1xuXG4gIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlcywgaGVyZSBmb3Igc3BlZWQgdXBcbiAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBiZXN0TG9jYXRpb24pKSA+IC0xKSB7XG4gICAgbGV0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgY3VycmVudExvY2F0aW9uOiBpbmRleCxcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBjdXJyZW50VGhyZXNob2xkID0gTWF0aC5taW4oc2NvcmUsIGN1cnJlbnRUaHJlc2hvbGQpO1xuICAgIGJlc3RMb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcblxuICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwYXR0ZXJuTGVuKSB7XG4gICAgICAgIG1hdGNoTWFza1tpbmRleCArIGldID0gMTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBiZXN0IGxvY2F0aW9uXG4gIGJlc3RMb2NhdGlvbiA9IC0xO1xuXG4gIGxldCBsYXN0Qml0QXJyID0gW107XG4gIGxldCBmaW5hbFNjb3JlID0gMTtcbiAgbGV0IGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuO1xuXG4gIGNvbnN0IG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpICs9IDEpIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gdGhlIG1hdGNoIGxvY2F0aW9uIHdlIGNhbiBzdHJheVxuICAgIC8vIGF0IHRoaXMgZXJyb3IgbGV2ZWwuXG4gICAgbGV0IGJpbk1pbiA9IDA7XG4gICAgbGV0IGJpbk1pZCA9IGJpbk1heDtcblxuICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCxcbiAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgYmluTWluID0gYmluTWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluTWF4ID0gYmluTWlkO1xuICAgICAgfVxuXG4gICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluTWF4ID0gYmluTWlkO1xuXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgZXhwZWN0ZWRMb2NhdGlvbiAtIGJpbk1pZCArIDEpO1xuICAgIGxldCBmaW5pc2ggPSBmaW5kQWxsTWF0Y2hlc1xuICAgICAgPyB0ZXh0TGVuXG4gICAgICA6IE1hdGgubWluKGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsIHRleHRMZW4pICsgcGF0dGVybkxlbjtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGJpdCBhcnJheVxuICAgIGxldCBiaXRBcnIgPSBBcnJheShmaW5pc2ggKyAyKTtcblxuICAgIGJpdEFycltmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcblxuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGogLT0gMSkge1xuICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IGogLSAxO1xuICAgICAgbGV0IGNoYXJNYXRjaCA9IHBhdHRlcm5BbHBoYWJldFt0ZXh0LmNoYXJBdChjdXJyZW50TG9jYXRpb24pXTtcblxuICAgICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNwZWVkIHVwOiBxdWljayBib29sIHRvIGludCBjb252ZXJzaW9uIChpLmUsIGBjaGFyTWF0Y2ggPyAxIDogMGApXG4gICAgICAgIG1hdGNoTWFza1tjdXJyZW50TG9jYXRpb25dID0gKyEhY2hhck1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaFxuICAgICAgYml0QXJyW2pdID0gKChiaXRBcnJbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG5cbiAgICAgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaFxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYml0QXJyW2pdIHw9XG4gICAgICAgICAgKChsYXN0Qml0QXJyW2ogKyAxXSB8IGxhc3RCaXRBcnJbal0pIDw8IDEpIHwgMSB8IGxhc3RCaXRBcnJbaiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0QXJyW2pdICYgbWFzaykge1xuICAgICAgICBmaW5hbFNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICAgIGVycm9yczogaSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChmaW5hbFNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBJbmRlZWQgaXQgaXNcbiAgICAgICAgICBjdXJyZW50VGhyZXNob2xkID0gZmluYWxTY29yZTtcbiAgICAgICAgICBiZXN0TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBgbG9jYCwgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgIGlmIChiZXN0TG9jYXRpb24gPD0gZXhwZWN0ZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYGJlc3RMb2NhdGlvbmAsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGBleHBlY3RlZExvY2F0aW9uYC5cbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBleHBlY3RlZExvY2F0aW9uIC0gYmVzdExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXG4gICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBlcnJvcnM6IGkgKyAxLFxuICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzY29yZSA+IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGFzdEJpdEFyciA9IGJpdEFycjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpc01hdGNoOiBiZXN0TG9jYXRpb24gPj0gMCxcbiAgICAvLyBDb3VudCBleGFjdCBtYXRjaGVzICh0aG9zZSB3aXRoIGEgc2NvcmUgb2YgMCkgdG8gYmUgXCJhbG1vc3RcIiBleGFjdFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLjAwMSwgZmluYWxTY29yZSlcbiAgfTtcblxuICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gY29udmVydE1hc2tUb0luZGljZXMobWF0Y2hNYXNrLCBtaW5NYXRjaENoYXJMZW5ndGgpO1xuICAgIGlmICghaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pIHtcbiAgbGV0IG1hc2sgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBtYXNrW2NoYXJdID0gKG1hc2tbY2hhcl0gfHwgMCkgfCAoMSA8PCAobGVuIC0gaSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiBtYXNrXG59XG5cbmNsYXNzIEJpdGFwU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICBpZiAoIXRoaXMucGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFkZENodW5rID0gKHBhdHRlcm4sIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBhbHBoYWJldDogY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiBNQVhfQklUUykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gbGVuICUgTUFYX0JJVFM7XG4gICAgICBjb25zdCBlbmQgPSBsZW4gLSByZW1haW5kZXI7XG5cbiAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoaSwgTUFYX0JJVFMpLCBpKTtcbiAgICAgICAgaSArPSBNQVhfQklUUztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gbGVuIC0gTUFYX0JJVFM7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoc3RhcnRJbmRleCksIHN0YXJ0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCB7IGlzQ2FzZVNlbnNpdGl2ZSwgaW5jbHVkZU1hdGNoZXMgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEV4YWN0IG1hdGNoXG4gICAgaWYgKHRoaXMucGF0dGVybiA9PT0gdGV4dCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICByZXN1bHQuaW5kaWNlcyA9IFtbMCwgdGV4dC5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBCaXRhcCBhbGdvcml0aG1cbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcbiAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaHVua3MuZm9yRWFjaCgoeyBwYXR0ZXJuLCBhbHBoYWJldCwgc3RhcnRJbmRleCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2godGV4dCwgcGF0dGVybiwgYWxwaGFiZXQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uICsgc3RhcnRJbmRleCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG5cbiAgICAgIGlmIChpc01hdGNoICYmIGluZGljZXMpIHtcbiAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBpc01hdGNoOiBoYXNNYXRjaGVzLFxuICAgICAgc2NvcmU6IGhhc01hdGNoZXMgPyB0b3RhbFNjb3JlIC8gdGhpcy5jaHVua3MubGVuZ3RoIDogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzTWF0Y2hlcyAmJiBpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jbGFzcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgfVxuICBzdGF0aWMgaXNNdWx0aU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5tdWx0aVJlZ2V4KVxuICB9XG4gIHN0YXRpYyBpc1NpbmdsZU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5zaW5nbGVSZWdleClcbiAgfVxuICBzZWFyY2goLyp0ZXh0Ki8pIHt9XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoKHBhdHRlcm4sIGV4cCkge1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBudWxsXG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2V4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL149XCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePSguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQgPT09IHRoaXMucGF0dGVybjtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFmaXJlXG5cbmNsYXNzIEludmVyc2VFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpbmRleCA9PT0gLTE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogXmZpbGVcblxuY2xhc3MgUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIV5maXJlXG5cbmNsYXNzIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtcHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAuZmlsZSRcblxuY2xhc3MgU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFt0ZXh0Lmxlbmd0aCAtIHRoaXMucGF0dGVybi5sZW5ndGgsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICEuZmlsZSRcblxuY2xhc3MgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1zdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXp6eU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICAgIHRoaXMuX2JpdGFwU2VhcmNoID0gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdmdXp6eSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0YXBTZWFyY2guc2VhcmNoSW4odGV4dClcbiAgfVxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgSW5jbHVkZU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2luY2x1ZGUnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXidcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14nKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBsZXQgbG9jYXRpb24gPSAwO1xuICAgIGxldCBpbmRleDtcblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBwYXR0ZXJuTGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlc1xuICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuLCBsb2NhdGlvbikpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuICAgICAgaW5kaWNlcy5wdXNoKFtpbmRleCwgbG9jYXRpb24gLSAxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRjaCA9ICEhaW5kaWNlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9XG59XG5cbi8vIOKdl09yZGVyIGlzIGltcG9ydGFudC4gRE8gTk9UIENIQU5HRS5cbmNvbnN0IHNlYXJjaGVycyA9IFtcbiAgRXhhY3RNYXRjaCxcbiAgSW5jbHVkZU1hdGNoLFxuICBQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2gsXG4gIFN1ZmZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VFeGFjdE1hdGNoLFxuICBGdXp6eU1hdGNoXG5dO1xuXG5jb25zdCBzZWFyY2hlcnNMZW4gPSBzZWFyY2hlcnMubGVuZ3RoO1xuXG4vLyBSZWdleCB0byBzcGxpdCBieSBzcGFjZXMsIGJ1dCBrZWVwIGFueXRoaW5nIGluIHF1b3RlcyB0b2dldGhlclxuY29uc3QgU1BBQ0VfUkUgPSAvICsoPz0oPzpbXlxcXCJdKlxcXCJbXlxcXCJdKlxcXCIpKlteXFxcIl0qJCkvO1xuY29uc3QgT1JfVE9LRU4gPSAnfCc7XG5cbi8vIFJldHVybiBhIDJEIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSwgZm9yIHNpbXBsZXIgcGFyc2luZy5cbi8vIEV4YW1wbGU6XG4vLyBcIl5jb3JlIGdvJCB8IHJiJCB8IHB5JCB4eSRcIiA9PiBbW1wiXmNvcmVcIiwgXCJnbyRcIl0sIFtcInJiJFwiXSwgW1wicHkkXCIsIFwieHkkXCJdXVxuZnVuY3Rpb24gcGFyc2VRdWVyeShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoT1JfVE9LRU4pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGxldCBxdWVyeSA9IGl0ZW1cbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdChTUEFDRV9SRSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgISFpdGVtLnRyaW0oKSk7XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgcXVlcnlJdGVtID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIDEuIEhhbmRsZSBtdWx0aXBsZSBxdWVyeSBtYXRjaCAoaS5lLCBvbmNlIHRoYXQgYXJlIHF1b3RlZCwgbGlrZSBgXCJoZWxsbyB3b3JsZFwiYClcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCFmb3VuZCAmJiArK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc011bHRpTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSGFuZGxlIHNpbmdsZSBxdWVyeSBtYXRjaGVzIChpLmUsIG9uY2UgdGhhdCBhcmUgKm5vdCogcXVvdGVkKVxuICAgICAgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNTaW5nbGVNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH0pXG59XG5cbi8vIFRoZXNlIGV4dGVuZGVkIG1hdGNoZXJzIGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgbWF0Y2hlcywgYXMgb3Bwb3NlZFxuLy8gdG8gYSBzaW5nbCBtYXRjaFxuY29uc3QgTXVsdGlNYXRjaFNldCA9IG5ldyBTZXQoW0Z1enp5TWF0Y2gudHlwZSwgSW5jbHVkZU1hdGNoLnR5cGVdKTtcblxuLyoqXG4gKiBDb21tYW5kLWxpa2Ugc2VhcmNoaW5nXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR2l2ZW4gbXVsdGlwbGUgc2VhcmNoIHRlcm1zIGRlbGltaXRlZCBieSBzcGFjZXMuZS5nLiBgXmpzY3JpcHQgLnB5dGhvbiQgcnVieSAhamF2YWAsXG4gKiBzZWFyY2ggaW4gYSBnaXZlbiB0ZXh0LlxuICpcbiAqIFNlYXJjaCBzeW50YXg6XG4gKlxuICogfCBUb2tlbiAgICAgICB8IE1hdGNoIHR5cGUgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBganNjcmlwdGAgICB8IGZ1enp5LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBmdXp6eSBtYXRjaCBganNjcmlwdGAgICAgICAgfFxuICogfCBgPXNjaGVtZWAgICB8IGV4YWN0LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBhcmUgYHNjaGVtZWAgICAgICAgICAgICAgICAgfFxuICogfCBgJ3B5dGhvbmAgICB8IGluY2x1ZGUtbWF0Y2ggICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBpbmNsdWRlIGBweXRob25gICAgICAgICAgICAgfFxuICogfCBgIXJ1YnlgICAgICB8IGludmVyc2UtZXhhY3QtbWF0Y2ggICAgICAgIHwgSXRlbXMgdGhhdCBkbyBub3QgaW5jbHVkZSBgcnVieWAgICAgICAgfFxuICogfCBgXmphdmFgICAgICB8IHByZWZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBzdGFydCB3aXRoIGBqYXZhYCAgICAgICAgICAgfFxuICogfCBgIV5lYXJsYW5nYCB8IGludmVyc2UtcHJlZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgZWFybGFuZ2AgfFxuICogfCBgLmpzJGAgICAgICB8IHN1ZmZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBlbmQgd2l0aCBgLmpzYCAgICAgICAgICAgICAgfFxuICogfCBgIS5nbyRgICAgICB8IGludmVyc2Utc3VmZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3QgZW5kIHdpdGggYC5nb2AgICAgICAgfFxuICpcbiAqIEEgc2luZ2xlIHBpcGUgY2hhcmFjdGVyIGFjdHMgYXMgYW4gT1Igb3BlcmF0b3IuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nXG4gKiBxdWVyeSBtYXRjaGVzIGVudHJpZXMgdGhhdCBzdGFydCB3aXRoIGBjb3JlYCBhbmQgZW5kIHdpdGggZWl0aGVyYGdvYCwgYHJiYCxcbiAqIG9yYHB5YC5cbiAqXG4gKiBgYGBcbiAqIF5jb3JlIGdvJCB8IHJiJCB8IHB5JFxuICogYGBgXG4gKi9cbmNsYXNzIEV4dGVuZGVkU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb24sXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBpZ25vcmVMb2NhdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcGFyc2VRdWVyeSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgY29uZGl0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaFxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeTtcblxuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgICBzY29yZTogMVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5jbHVkZU1hdGNoZXMsIGlzQ2FzZVNlbnNpdGl2ZSB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGV4dCA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBsZXQgbnVtTWF0Y2hlcyA9IDA7XG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG5cbiAgICAvLyBPUnNcbiAgICBmb3IgKGxldCBpID0gMCwgcUxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IHFMZW47IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2VhcmNoZXJzID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIFJlc2V0IGluZGljZXNcbiAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIG51bU1hdGNoZXMgPSAwO1xuXG4gICAgICAvLyBBTkRzXG4gICAgICBmb3IgKGxldCBqID0gMCwgcExlbiA9IHNlYXJjaGVycy5sZW5ndGg7IGogPCBwTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbal07XG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgaW5kaWNlcywgc2NvcmUgfSA9IHNlYXJjaGVyLnNlYXJjaCh0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG51bU1hdGNoZXMgKz0gMTtcbiAgICAgICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuICAgICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHNlYXJjaGVyLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgICAgICBpZiAoTXVsdGlNYXRjaFNldC5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMucHVzaChpbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxTY29yZSA9IDA7XG4gICAgICAgICAgbnVtTWF0Y2hlcyA9IDA7XG4gICAgICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1IgY29uZGl0aW9uLCBzbyBpZiBUUlVFLCByZXR1cm5cbiAgICAgIGlmIChudW1NYXRjaGVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgICBzY29yZTogdG90YWxTY29yZSAvIG51bU1hdGNoZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90aGluZyB3YXMgbWF0Y2hlZFxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgIHNjb3JlOiAxXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlZ2lzdGVyZWRTZWFyY2hlcnMgPSBbXTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoLi4uYXJncykge1xuICByZWdpc3RlcmVkU2VhcmNoZXJzLnB1c2goLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ2lzdGVyZWRTZWFyY2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgc2VhcmNoZXJDbGFzcyA9IHJlZ2lzdGVyZWRTZWFyY2hlcnNbaV07XG4gICAgaWYgKHNlYXJjaGVyQ2xhc3MuY29uZGl0aW9uKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IHNlYXJjaGVyQ2xhc3MocGF0dGVybiwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbmNvbnN0IExvZ2ljYWxPcGVyYXRvciA9IHtcbiAgQU5EOiAnJGFuZCcsXG4gIE9SOiAnJG9yJ1xufTtcblxuY29uc3QgS2V5VHlwZSA9IHtcbiAgUEFUSDogJyRwYXRoJyxcbiAgUEFUVEVSTjogJyR2YWwnXG59O1xuXG5jb25zdCBpc0V4cHJlc3Npb24gPSAocXVlcnkpID0+XG4gICEhKHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5BTkRdIHx8IHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5PUl0pO1xuXG5jb25zdCBpc1BhdGggPSAocXVlcnkpID0+ICEhcXVlcnlbS2V5VHlwZS5QQVRIXTtcblxuY29uc3QgaXNMZWFmID0gKHF1ZXJ5KSA9PlxuICAhaXNBcnJheShxdWVyeSkgJiYgaXNPYmplY3QocXVlcnkpICYmICFpc0V4cHJlc3Npb24ocXVlcnkpO1xuXG5jb25zdCBjb252ZXJ0VG9FeHBsaWNpdCA9IChxdWVyeSkgPT4gKHtcbiAgW0xvZ2ljYWxPcGVyYXRvci5BTkRdOiBPYmplY3Qua2V5cyhxdWVyeSkubWFwKChrZXkpID0+ICh7XG4gICAgW2tleV06IHF1ZXJ5W2tleV1cbiAgfSkpXG59KTtcblxuLy8gV2hlbiBgYXV0b2AgaXMgYHRydWVgLCB0aGUgcGFyc2UgZnVuY3Rpb24gd2lsbCBpbmZlciBhbmQgaW5pdGlhbGl6ZSBhbmQgYWRkXG4vLyB0aGUgYXBwcm9wcmlhdGUgYFNlYXJjaGVyYCBpbnN0YW5jZVxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMsIHsgYXV0byA9IHRydWUgfSA9IHt9KSB7XG4gIGNvbnN0IG5leHQgPSAocXVlcnkpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXJ5KTtcblxuICAgIGNvbnN0IGlzUXVlcnlQYXRoID0gaXNQYXRoKHF1ZXJ5KTtcblxuICAgIGlmICghaXNRdWVyeVBhdGggJiYga2V5cy5sZW5ndGggPiAxICYmICFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV4dChjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSkpXG4gICAgfVxuXG4gICAgaWYgKGlzTGVhZihxdWVyeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRIXSA6IGtleXNbMF07XG5cbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUVEVSTl0gOiBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkoa2V5KSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBrZXlJZDogY3JlYXRlS2V5SWQoa2V5KSxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfTtcblxuICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgb2JqLnNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG9wZXJhdG9yOiBrZXlzWzBdXG4gICAgfTtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5leHQoaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgaWYgKCFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgcXVlcnkgPSBjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbmV4dChxdWVyeSlcbn1cblxuLy8gUHJhY3RpY2FsIHNjb3JpbmcgZnVuY3Rpb25cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShcbiAgcmVzdWx0cyxcbiAgeyBpZ25vcmVGaWVsZE5vcm0gPSBDb25maWcuaWdub3JlRmllbGROb3JtIH1cbikge1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgIGxldCB0b3RhbFNjb3JlID0gMTtcblxuICAgIHJlc3VsdC5tYXRjaGVzLmZvckVhY2goKHsga2V5LCBub3JtLCBzY29yZSB9KSA9PiB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBrZXkgPyBrZXkud2VpZ2h0IDogbnVsbDtcblxuICAgICAgdG90YWxTY29yZSAqPSBNYXRoLnBvdyhcbiAgICAgICAgc2NvcmUgPT09IDAgJiYgd2VpZ2h0ID8gTnVtYmVyLkVQU0lMT04gOiBzY29yZSxcbiAgICAgICAgKHdlaWdodCB8fCAxKSAqIChpZ25vcmVGaWVsZE5vcm0gPyAxIDogbm9ybSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuc2NvcmUgPSB0b3RhbFNjb3JlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0Y2hlcyhyZXN1bHQsIGRhdGEpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlc3VsdC5tYXRjaGVzO1xuICBkYXRhLm1hdGNoZXMgPSBbXTtcblxuICBpZiAoIWlzRGVmaW5lZChtYXRjaGVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG1hdGNoLmluZGljZXMpIHx8ICFtYXRjaC5pbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRpY2VzLCB2YWx1ZSB9ID0gbWF0Y2g7XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgaW5kaWNlcyxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmIChtYXRjaC5rZXkpIHtcbiAgICAgIG9iai5rZXkgPSBtYXRjaC5rZXkuc3JjO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5pZHggPiAtMSkge1xuICAgICAgb2JqLnJlZkluZGV4ID0gbWF0Y2guaWR4O1xuICAgIH1cblxuICAgIGRhdGEubWF0Y2hlcy5wdXNoKG9iaik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TY29yZShyZXN1bHQsIGRhdGEpIHtcbiAgZGF0YS5zY29yZSA9IHJlc3VsdC5zY29yZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICByZXN1bHRzLFxuICBkb2NzLFxuICB7XG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaW5jbHVkZVNjb3JlID0gQ29uZmlnLmluY2x1ZGVTY29yZVxuICB9ID0ge31cbikge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBbXTtcblxuICBpZiAoaW5jbHVkZU1hdGNoZXMpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybU1hdGNoZXMpO1xuICBpZiAoaW5jbHVkZVNjb3JlKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1TY29yZSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGlkeCB9ID0gcmVzdWx0O1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl0ZW06IGRvY3NbaWR4XSxcbiAgICAgIHJlZkluZGV4OiBpZHhcbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIHRyYW5zZm9ybWVycy5mb3JFYWNoKCh0cmFuc2Zvcm1lcikgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lcihyZXN1bHQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSlcbn1cblxuY2xhc3MgRnVzZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkNvbmZpZywgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoICYmXG4gICAgICAhdHJ1ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSlcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlTdG9yZSA9IG5ldyBLZXlTdG9yZSh0aGlzLm9wdGlvbnMua2V5cyk7XG5cbiAgICB0aGlzLnNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCkge1xuICAgIHRoaXMuX2RvY3MgPSBkb2NzO1xuXG4gICAgaWYgKGluZGV4ICYmICEoaW5kZXggaW5zdGFuY2VvZiBGdXNlSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5DT1JSRUNUX0lOREVYX1RZUEUpXG4gICAgfVxuXG4gICAgdGhpcy5fbXlJbmRleCA9XG4gICAgICBpbmRleCB8fFxuICAgICAgY3JlYXRlSW5kZXgodGhpcy5vcHRpb25zLmtleXMsIHRoaXMuX2RvY3MsIHtcbiAgICAgICAgZ2V0Rm46IHRoaXMub3B0aW9ucy5nZXRGbixcbiAgICAgICAgZmllbGROb3JtV2VpZ2h0OiB0aGlzLm9wdGlvbnMuZmllbGROb3JtV2VpZ2h0XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChkb2MpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9kb2NzLnB1c2goZG9jKTtcbiAgICB0aGlzLl9teUluZGV4LmFkZChkb2MpO1xuICB9XG5cbiAgcmVtb3ZlKHByZWRpY2F0ZSA9ICgvKiBkb2MsIGlkeCAqLykgPT4gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fZG9jcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5fZG9jc1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUoZG9jLCBpKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgICBpIC09IDE7XG4gICAgICAgIGxlbiAtPSAxO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLl9kb2NzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX215SW5kZXgucmVtb3ZlQXQoaWR4KTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9teUluZGV4XG4gIH1cblxuICBzZWFyY2gocXVlcnksIHsgbGltaXQgPSAtMSB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZSxcbiAgICAgIHNob3VsZFNvcnQsXG4gICAgICBzb3J0Rm4sXG4gICAgICBpZ25vcmVGaWVsZE5vcm1cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBpc1N0cmluZyhxdWVyeSlcbiAgICAgID8gaXNTdHJpbmcodGhpcy5fZG9jc1swXSlcbiAgICAgICAgPyB0aGlzLl9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KVxuICAgICAgICA6IHRoaXMuX3NlYXJjaE9iamVjdExpc3QocXVlcnkpXG4gICAgICA6IHRoaXMuX3NlYXJjaExvZ2ljYWwocXVlcnkpO1xuXG4gICAgY29tcHV0ZVNjb3JlKHJlc3VsdHMsIHsgaWdub3JlRmllbGROb3JtIH0pO1xuXG4gICAgaWYgKHNob3VsZFNvcnQpIHtcbiAgICAgIHJlc3VsdHMuc29ydChzb3J0Rm4pO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihsaW1pdCkgJiYgbGltaXQgPiAtMSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQocmVzdWx0cywgdGhpcy5fZG9jcywge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmVcbiAgICB9KVxuICB9XG5cbiAgX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgc3RyaW5nIGluIHRoZSBpbmRleFxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHRleHQsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIG1hdGNoZXM6IFt7IHNjb3JlLCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoTG9naWNhbChxdWVyeSkge1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgZXZhbHVhdGUgPSAobm9kZSwgaXRlbSwgaWR4KSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBrZXlJZCwgc2VhcmNoZXIgfSA9IG5vZGU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICBrZXk6IHRoaXMuX2tleVN0b3JlLmdldChrZXlJZCksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX215SW5kZXguZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCksXG4gICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlKGNoaWxkLCBpdGVtLCBpZHgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gTG9naWNhbE9wZXJhdG9yLkFORCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9teUluZGV4LnJlY29yZHM7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIGxldCBleHBSZXN1bHRzID0gZXZhbHVhdGUoZXhwcmVzc2lvbiwgaXRlbSwgaWR4KTtcblxuICAgICAgICBpZiAoZXhwUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZWR1cGUgd2hlbiBhZGRpbmdcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpZHhdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XSA9IHsgaWR4LCBpdGVtLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdE1hcFtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwUmVzdWx0cy5mb3JFYWNoKCh7IG1hdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0ubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaE9iamVjdExpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgICBrZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIC4uLnRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtW2tleUluZGV4XSxcbiAgICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuICBfZmluZE1hdGNoZXMoeyBrZXksIHZhbHVlLCBzZWFyY2hlciB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgbm9ybSxcbiAgICAgICAgICAgIGluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdjogdGV4dCwgbjogbm9ybSB9ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBzY29yZSwga2V5LCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG59XG5cbkZ1c2UudmVyc2lvbiA9ICc3LjAuMCc7XG5GdXNlLmNyZWF0ZUluZGV4ID0gY3JlYXRlSW5kZXg7XG5GdXNlLnBhcnNlSW5kZXggPSBwYXJzZUluZGV4O1xuRnVzZS5jb25maWcgPSBDb25maWc7XG5cbntcbiAgRnVzZS5wYXJzZVF1ZXJ5ID0gcGFyc2U7XG59XG5cbntcbiAgcmVnaXN0ZXIoRXh0ZW5kZWRTZWFyY2gpO1xufVxuXG5leHBvcnQgeyBGdXNlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJpc0FycmF5IiwidmFsdWUiLCJBcnJheSIsImdldFRhZyIsIklORklOSVRZIiwiYmFzZVRvU3RyaW5nIiwicmVzdWx0IiwidG9TdHJpbmciLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNCb29sZWFuIiwiaXNPYmplY3RMaWtlIiwiaXNPYmplY3QiLCJpc0RlZmluZWQiLCJ1bmRlZmluZWQiLCJpc0JsYW5rIiwidHJpbSIsImxlbmd0aCIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUiLCJJTkNPUlJFQ1RfSU5ERVhfVFlQRSIsIkxPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSIsImtleSIsIlBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSIsIm1heCIsIk1JU1NJTkdfS0VZX1BST1BFUlRZIiwibmFtZSIsIklOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSIsImhhc093biIsImhhc093blByb3BlcnR5IiwiS2V5U3RvcmUiLCJjb25zdHJ1Y3RvciIsImtleXMiLCJfa2V5cyIsIl9rZXlNYXAiLCJ0b3RhbFdlaWdodCIsImZvckVhY2giLCJvYmoiLCJjcmVhdGVLZXkiLCJwdXNoIiwiaWQiLCJ3ZWlnaHQiLCJnZXQiLCJrZXlJZCIsInRvSlNPTiIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXRoIiwic3JjIiwiZ2V0Rm4iLCJjcmVhdGVLZXlQYXRoIiwiY3JlYXRlS2V5SWQiLCJFcnJvciIsInNwbGl0Iiwiam9pbiIsImxpc3QiLCJhcnIiLCJkZWVwR2V0IiwiaW5kZXgiLCJpIiwibGVuIiwiTWF0Y2hPcHRpb25zIiwiaW5jbHVkZU1hdGNoZXMiLCJmaW5kQWxsTWF0Y2hlcyIsIm1pbk1hdGNoQ2hhckxlbmd0aCIsIkJhc2ljT3B0aW9ucyIsImlzQ2FzZVNlbnNpdGl2ZSIsImluY2x1ZGVTY29yZSIsInNob3VsZFNvcnQiLCJzb3J0Rm4iLCJhIiwiYiIsInNjb3JlIiwiaWR4IiwiRnV6enlPcHRpb25zIiwibG9jYXRpb24iLCJ0aHJlc2hvbGQiLCJkaXN0YW5jZSIsIkFkdmFuY2VkT3B0aW9ucyIsInVzZUV4dGVuZGVkU2VhcmNoIiwiaWdub3JlTG9jYXRpb24iLCJpZ25vcmVGaWVsZE5vcm0iLCJmaWVsZE5vcm1XZWlnaHQiLCJDb25maWciLCJTUEFDRSIsIm5vcm0iLCJtYW50aXNzYSIsImNhY2hlIiwiTWFwIiwibSIsIk1hdGgiLCJwb3ciLCJudW1Ub2tlbnMiLCJtYXRjaCIsImhhcyIsIm4iLCJwYXJzZUZsb2F0Iiwicm91bmQiLCJzZXQiLCJjbGVhciIsIkZ1c2VJbmRleCIsImlzQ3JlYXRlZCIsInNldEluZGV4UmVjb3JkcyIsInNldFNvdXJjZXMiLCJkb2NzIiwicmVjb3JkcyIsInNldEtleXMiLCJfa2V5c01hcCIsImNyZWF0ZSIsImRvYyIsImRvY0luZGV4IiwiX2FkZFN0cmluZyIsIl9hZGRPYmplY3QiLCJhZGQiLCJzaXplIiwicmVtb3ZlQXQiLCJzcGxpY2UiLCJnZXRWYWx1ZUZvckl0ZW1BdEtleUlkIiwiaXRlbSIsInJlY29yZCIsInYiLCIkIiwia2V5SW5kZXgiLCJzdWJSZWNvcmRzIiwic3RhY2siLCJuZXN0ZWRBcnJJbmRleCIsInBvcCIsInN1YlJlY29yZCIsImsiLCJjcmVhdGVJbmRleCIsIm15SW5kZXgiLCJtYXAiLCJwYXJzZUluZGV4IiwiZGF0YSIsImNvbXB1dGVTY29yZSQxIiwicGF0dGVybiIsImVycm9ycyIsImN1cnJlbnRMb2NhdGlvbiIsImV4cGVjdGVkTG9jYXRpb24iLCJhY2N1cmFjeSIsInByb3hpbWl0eSIsImFicyIsImNvbnZlcnRNYXNrVG9JbmRpY2VzIiwibWF0Y2htYXNrIiwiaW5kaWNlcyIsInN0YXJ0IiwiZW5kIiwiTUFYX0JJVFMiLCJzZWFyY2giLCJ0ZXh0IiwicGF0dGVybkFscGhhYmV0IiwicGF0dGVybkxlbiIsInRleHRMZW4iLCJtaW4iLCJjdXJyZW50VGhyZXNob2xkIiwiYmVzdExvY2F0aW9uIiwiY29tcHV0ZU1hdGNoZXMiLCJtYXRjaE1hc2siLCJpbmRleE9mIiwibGFzdEJpdEFyciIsImZpbmFsU2NvcmUiLCJiaW5NYXgiLCJtYXNrIiwiYmluTWluIiwiYmluTWlkIiwiZmxvb3IiLCJmaW5pc2giLCJiaXRBcnIiLCJqIiwiY2hhck1hdGNoIiwiY2hhckF0IiwiaXNNYXRjaCIsImNyZWF0ZVBhdHRlcm5BbHBoYWJldCIsImNoYXIiLCJCaXRhcFNlYXJjaCIsIm9wdGlvbnMiLCJ0b0xvd2VyQ2FzZSIsImNodW5rcyIsImFkZENodW5rIiwic3RhcnRJbmRleCIsImFscGhhYmV0IiwicmVtYWluZGVyIiwic3Vic3RyIiwic2VhcmNoSW4iLCJhbGxJbmRpY2VzIiwidG90YWxTY29yZSIsImhhc01hdGNoZXMiLCJCYXNlTWF0Y2giLCJpc011bHRpTWF0Y2giLCJnZXRNYXRjaCIsIm11bHRpUmVnZXgiLCJpc1NpbmdsZU1hdGNoIiwic2luZ2xlUmVnZXgiLCJleHAiLCJtYXRjaGVzIiwiRXhhY3RNYXRjaCIsInR5cGUiLCJJbnZlcnNlRXhhY3RNYXRjaCIsIlByZWZpeEV4YWN0TWF0Y2giLCJzdGFydHNXaXRoIiwiSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2giLCJTdWZmaXhFeGFjdE1hdGNoIiwiZW5kc1dpdGgiLCJJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCIsIkZ1enp5TWF0Y2giLCJfYml0YXBTZWFyY2giLCJJbmNsdWRlTWF0Y2giLCJzZWFyY2hlcnMiLCJzZWFyY2hlcnNMZW4iLCJTUEFDRV9SRSIsIk9SX1RPS0VOIiwicGFyc2VRdWVyeSIsInF1ZXJ5IiwiZmlsdGVyIiwicmVzdWx0cyIsInF1ZXJ5SXRlbSIsImZvdW5kIiwic2VhcmNoZXIiLCJ0b2tlbiIsIk11bHRpTWF0Y2hTZXQiLCJTZXQiLCJFeHRlbmRlZFNlYXJjaCIsImNvbmRpdGlvbiIsIl8iLCJudW1NYXRjaGVzIiwicUxlbiIsInBMZW4iLCJyZWdpc3RlcmVkU2VhcmNoZXJzIiwicmVnaXN0ZXIiLCJhcmdzIiwiY3JlYXRlU2VhcmNoZXIiLCJzZWFyY2hlckNsYXNzIiwiTG9naWNhbE9wZXJhdG9yIiwiQU5EIiwiT1IiLCJLZXlUeXBlIiwiUEFUSCIsIlBBVFRFUk4iLCJpc0V4cHJlc3Npb24iLCJpc1BhdGgiLCJpc0xlYWYiLCJjb252ZXJ0VG9FeHBsaWNpdCIsInBhcnNlIiwiYXV0byIsIm5leHQiLCJpc1F1ZXJ5UGF0aCIsIm5vZGUiLCJjaGlsZHJlbiIsIm9wZXJhdG9yIiwiY29tcHV0ZVNjb3JlIiwiTnVtYmVyIiwiRVBTSUxPTiIsInRyYW5zZm9ybU1hdGNoZXMiLCJyZWZJbmRleCIsInRyYW5zZm9ybVNjb3JlIiwiZm9ybWF0IiwidHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXIiLCJGdXNlIiwiX2tleVN0b3JlIiwic2V0Q29sbGVjdGlvbiIsIl9kb2NzIiwiX215SW5kZXgiLCJyZW1vdmUiLCJwcmVkaWNhdGUiLCJnZXRJbmRleCIsImxpbWl0IiwiX3NlYXJjaFN0cmluZ0xpc3QiLCJfc2VhcmNoT2JqZWN0TGlzdCIsIl9zZWFyY2hMb2dpY2FsIiwic29ydCIsInNsaWNlIiwiZXhwcmVzc2lvbiIsImV2YWx1YXRlIiwiX2ZpbmRNYXRjaGVzIiwicmVzIiwiY2hpbGQiLCJyZXN1bHRNYXAiLCJleHBSZXN1bHRzIiwidmVyc2lvbiIsImNvbmZpZyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fuse.js/dist/fuse.mjs\n");

/***/ })

};
;