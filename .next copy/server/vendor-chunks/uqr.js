"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uqr";
exports.ids = ["vendor-chunks/uqr"];
exports.modules = {

/***/ "(ssr)/./node_modules/uqr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uqr/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QrCodeDataType: () => (/* binding */ QrCodeDataType),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   renderANSI: () => (/* binding */ renderANSI),\n/* harmony export */   renderSVG: () => (/* binding */ renderSVG),\n/* harmony export */   renderUnicode: () => (/* binding */ renderUnicode),\n/* harmony export */   renderUnicodeCompact: () => (/* binding */ renderUnicodeCompact)\n/* harmony export */ });\nvar QrCodeDataType = /* @__PURE__ */ ((QrCodeDataType2)=>{\n    QrCodeDataType2[QrCodeDataType2[\"Border\"] = -1] = \"Border\";\n    QrCodeDataType2[QrCodeDataType2[\"Data\"] = 0] = \"Data\";\n    QrCodeDataType2[QrCodeDataType2[\"Function\"] = 1] = \"Function\";\n    QrCodeDataType2[QrCodeDataType2[\"Position\"] = 2] = \"Position\";\n    QrCodeDataType2[QrCodeDataType2[\"Timing\"] = 3] = \"Timing\";\n    QrCodeDataType2[QrCodeDataType2[\"Alignment\"] = 4] = \"Alignment\";\n    return QrCodeDataType2;\n})(QrCodeDataType || {});\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nconst LOW = [\n    0,\n    1\n];\nconst MEDIUM = [\n    1,\n    0\n];\nconst QUARTILE = [\n    2,\n    3\n];\nconst HIGH = [\n    3,\n    2\n];\nconst EccMap = {\n    L: LOW,\n    M: MEDIUM,\n    Q: QUARTILE,\n    H: HIGH\n};\nconst NUMERIC_REGEX = /^[0-9]*$/;\nconst ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\nconst ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\nconst MIN_VERSION = 1;\nconst MAX_VERSION = 40;\nconst PENALTY_N1 = 3;\nconst PENALTY_N2 = 3;\nconst PENALTY_N3 = 40;\nconst PENALTY_N4 = 10;\nconst ECC_CODEWORDS_PER_BLOCK = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n        -1,\n        7,\n        10,\n        15,\n        20,\n        26,\n        18,\n        20,\n        24,\n        30,\n        18,\n        20,\n        24,\n        26,\n        30,\n        22,\n        24,\n        28,\n        30,\n        28,\n        28,\n        28,\n        28,\n        30,\n        30,\n        26,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    // Low\n    [\n        -1,\n        10,\n        16,\n        26,\n        18,\n        24,\n        16,\n        18,\n        22,\n        22,\n        26,\n        30,\n        22,\n        22,\n        24,\n        24,\n        28,\n        28,\n        26,\n        26,\n        26,\n        26,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28\n    ],\n    // Medium\n    [\n        -1,\n        13,\n        22,\n        18,\n        26,\n        18,\n        24,\n        18,\n        22,\n        20,\n        24,\n        28,\n        26,\n        24,\n        20,\n        30,\n        24,\n        28,\n        28,\n        26,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    // Quartile\n    [\n        -1,\n        17,\n        28,\n        22,\n        16,\n        22,\n        28,\n        26,\n        26,\n        24,\n        28,\n        24,\n        28,\n        22,\n        24,\n        24,\n        30,\n        28,\n        28,\n        26,\n        28,\n        30,\n        24,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ]\n];\nconst NUM_ERROR_CORRECTION_BLOCKS = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n        -1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        2,\n        2,\n        2,\n        2,\n        4,\n        4,\n        4,\n        4,\n        4,\n        6,\n        6,\n        6,\n        6,\n        7,\n        8,\n        8,\n        9,\n        9,\n        10,\n        12,\n        12,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        19,\n        20,\n        21,\n        22,\n        24,\n        25\n    ],\n    // Low\n    [\n        -1,\n        1,\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        4,\n        5,\n        5,\n        5,\n        8,\n        9,\n        9,\n        10,\n        10,\n        11,\n        13,\n        14,\n        16,\n        17,\n        17,\n        18,\n        20,\n        21,\n        23,\n        25,\n        26,\n        28,\n        29,\n        31,\n        33,\n        35,\n        37,\n        38,\n        40,\n        43,\n        45,\n        47,\n        49\n    ],\n    // Medium\n    [\n        -1,\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        6,\n        6,\n        8,\n        8,\n        8,\n        10,\n        12,\n        16,\n        12,\n        17,\n        16,\n        18,\n        21,\n        20,\n        23,\n        23,\n        25,\n        27,\n        29,\n        34,\n        34,\n        35,\n        38,\n        40,\n        43,\n        45,\n        48,\n        51,\n        53,\n        56,\n        59,\n        62,\n        65,\n        68\n    ],\n    // Quartile\n    [\n        -1,\n        1,\n        1,\n        2,\n        4,\n        4,\n        4,\n        5,\n        6,\n        8,\n        8,\n        11,\n        11,\n        16,\n        16,\n        18,\n        16,\n        19,\n        21,\n        25,\n        25,\n        25,\n        34,\n        30,\n        32,\n        35,\n        37,\n        40,\n        42,\n        45,\n        48,\n        51,\n        54,\n        57,\n        60,\n        63,\n        66,\n        70,\n        74,\n        77,\n        81\n    ]\n];\nclass QrCode {\n    /* -- Constructor (low level) and fields -- */ // Creates a new QR Code with the given version number,\n    // error correction level, data codeword bytes, and mask number.\n    // This is a low-level API that most users should not use directly.\n    // A mid-level API is the encodeSegments() function.\n    constructor(version, ecc, dataCodewords, msk){\n        this.version = version;\n        this.ecc = ecc;\n        /* -- Fields -- */ // The width and height of this QR Code, measured in modules, between\n        // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n        __publicField(this, \"size\");\n        // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n        // Even if a QR Code is created with automatic masking requested (mask = -1),\n        // the resulting object still has a mask value between 0 and 7.\n        __publicField(this, \"mask\");\n        // The modules of this QR Code (false = light, true = dark).\n        // Immutable after constructor finishes. Accessed through getModule().\n        __publicField(this, \"modules\", []);\n        __publicField(this, \"types\", []);\n        if (version < MIN_VERSION || version > MAX_VERSION) throw new RangeError(\"Version value out of range\");\n        if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n        this.size = version * 4 + 17;\n        const row = Array.from({\n            length: this.size\n        }, ()=>false);\n        for(let i = 0; i < this.size; i++){\n            this.modules.push(row.slice());\n            this.types.push(row.map(()=>0));\n        }\n        this.drawFunctionPatterns();\n        const allCodewords = this.addEccAndInterleave(dataCodewords);\n        this.drawCodewords(allCodewords);\n        if (msk === -1) {\n            let minPenalty = 1e9;\n            for(let i = 0; i < 8; i++){\n                this.applyMask(i);\n                this.drawFormatBits(i);\n                const penalty = this.getPenaltyScore();\n                if (penalty < minPenalty) {\n                    msk = i;\n                    minPenalty = penalty;\n                }\n                this.applyMask(i);\n            }\n        }\n        this.mask = msk;\n        this.applyMask(msk);\n        this.drawFormatBits(msk);\n    }\n    /* -- Accessor methods -- */ // Returns the color of the module (pixel) at the given coordinates, which is false\n    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n    // If the given coordinates are out of bounds, then false (light) is returned.\n    getModule(x, y) {\n        return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];\n    }\n    /* -- Private helper methods for constructor: Drawing function modules -- */ // Reads this object's version field, and draws and marks all function modules.\n    drawFunctionPatterns() {\n        for(let i = 0; i < this.size; i++){\n            this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);\n            this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);\n        }\n        this.drawFinderPattern(3, 3);\n        this.drawFinderPattern(this.size - 4, 3);\n        this.drawFinderPattern(3, this.size - 4);\n        const alignPatPos = this.getAlignmentPatternPositions();\n        const numAlign = alignPatPos.length;\n        for(let i = 0; i < numAlign; i++){\n            for(let j = 0; j < numAlign; j++){\n                if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n            }\n        }\n        this.drawFormatBits(0);\n        this.drawVersion();\n    }\n    // Draws two copies of the format bits (with its own error correction code)\n    // based on the given mask and this object's error correction level field.\n    drawFormatBits(mask) {\n        const data = this.ecc[1] << 3 | mask;\n        let rem = data;\n        for(let i = 0; i < 10; i++)rem = rem << 1 ^ (rem >>> 9) * 1335;\n        const bits = (data << 10 | rem) ^ 21522;\n        for(let i = 0; i <= 5; i++)this.setFunctionModule(8, i, getBit(bits, i));\n        this.setFunctionModule(8, 7, getBit(bits, 6));\n        this.setFunctionModule(8, 8, getBit(bits, 7));\n        this.setFunctionModule(7, 8, getBit(bits, 8));\n        for(let i = 9; i < 15; i++)this.setFunctionModule(14 - i, 8, getBit(bits, i));\n        for(let i = 0; i < 8; i++)this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n        for(let i = 8; i < 15; i++)this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n        this.setFunctionModule(8, this.size - 8, true);\n    }\n    // Draws two copies of the version bits (with its own error correction code),\n    // based on this object's version field, iff 7 <= version <= 40.\n    drawVersion() {\n        if (this.version < 7) return;\n        let rem = this.version;\n        for(let i = 0; i < 12; i++)rem = rem << 1 ^ (rem >>> 11) * 7973;\n        const bits = this.version << 12 | rem;\n        for(let i = 0; i < 18; i++){\n            const color = getBit(bits, i);\n            const a = this.size - 11 + i % 3;\n            const b = Math.floor(i / 3);\n            this.setFunctionModule(a, b, color);\n            this.setFunctionModule(b, a, color);\n        }\n    }\n    // Draws a 9*9 finder pattern including the border separator,\n    // with the center module at (x, y). Modules can be out of bounds.\n    drawFinderPattern(x, y) {\n        for(let dy = -4; dy <= 4; dy++){\n            for(let dx = -4; dx <= 4; dx++){\n                const dist = Math.max(Math.abs(dx), Math.abs(dy));\n                const xx = x + dx;\n                const yy = y + dy;\n                if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size) this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);\n            }\n        }\n    }\n    // Draws a 5*5 alignment pattern, with the center module\n    // at (x, y). All modules must be in bounds.\n    drawAlignmentPattern(x, y) {\n        for(let dy = -2; dy <= 2; dy++){\n            for(let dx = -2; dx <= 2; dx++){\n                this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1, QrCodeDataType.Alignment);\n            }\n        }\n    }\n    // Sets the color of a module and marks it as a function module.\n    // Only used by the constructor. Coordinates must be in bounds.\n    setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {\n        this.modules[y][x] = isDark;\n        this.types[y][x] = type;\n    }\n    /* -- Private helper methods for constructor: Codewords and masking -- */ // Returns a new byte string representing the given data with the appropriate error correction\n    // codewords appended to it, based on this object's version and error correction level.\n    addEccAndInterleave(data) {\n        const ver = this.version;\n        const ecl = this.ecc;\n        if (data.length !== getNumDataCodewords(ver, ecl)) throw new RangeError(\"Invalid argument\");\n        const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n        const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];\n        const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);\n        const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n        const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n        const blocks = [];\n        const rsDiv = reedSolomonComputeDivisor(blockEccLen);\n        for(let i = 0, k = 0; i < numBlocks; i++){\n            const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n            k += dat.length;\n            const ecc = reedSolomonComputeRemainder(dat, rsDiv);\n            if (i < numShortBlocks) dat.push(0);\n            blocks.push(dat.concat(ecc));\n        }\n        const result = [];\n        for(let i = 0; i < blocks[0].length; i++){\n            blocks.forEach((block, j)=>{\n                if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);\n            });\n        }\n        return result;\n    }\n    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n    // data area of this QR Code. Function modules need to be marked off before this is called.\n    drawCodewords(data) {\n        if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8)) throw new RangeError(\"Invalid argument\");\n        let i = 0;\n        for(let right = this.size - 1; right >= 1; right -= 2){\n            if (right === 6) right = 5;\n            for(let vert = 0; vert < this.size; vert++){\n                for(let j = 0; j < 2; j++){\n                    const x = right - j;\n                    const upward = (right + 1 & 2) === 0;\n                    const y = upward ? this.size - 1 - vert : vert;\n                    if (!this.types[y][x] && i < data.length * 8) {\n                        this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n    // XORs the codeword modules in this QR Code with the given mask pattern.\n    // The function modules must be marked and the codeword bits must be drawn\n    // before masking. Due to the arithmetic of XOR, calling applyMask() with\n    // the same mask value a second time will undo the mask. A final well-formed\n    // QR Code needs exactly one (not zero, two, etc.) mask applied.\n    applyMask(mask) {\n        if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n        for(let y = 0; y < this.size; y++){\n            for(let x = 0; x < this.size; x++){\n                let invert;\n                switch(mask){\n                    case 0:\n                        invert = (x + y) % 2 === 0;\n                        break;\n                    case 1:\n                        invert = y % 2 === 0;\n                        break;\n                    case 2:\n                        invert = x % 3 === 0;\n                        break;\n                    case 3:\n                        invert = (x + y) % 3 === 0;\n                        break;\n                    case 4:\n                        invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;\n                        break;\n                    case 5:\n                        invert = x * y % 2 + x * y % 3 === 0;\n                        break;\n                    case 6:\n                        invert = (x * y % 2 + x * y % 3) % 2 === 0;\n                        break;\n                    case 7:\n                        invert = ((x + y) % 2 + x * y % 3) % 2 === 0;\n                        break;\n                    default:\n                        throw new Error(\"Unreachable\");\n                }\n                if (!this.types[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n            }\n        }\n    }\n    // Calculates and returns the penalty score based on state of this QR Code's current modules.\n    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n    getPenaltyScore() {\n        let result = 0;\n        for(let y = 0; y < this.size; y++){\n            let runColor = false;\n            let runX = 0;\n            const runHistory = [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ];\n            for(let x = 0; x < this.size; x++){\n                if (this.modules[y][x] === runColor) {\n                    runX++;\n                    if (runX === 5) result += PENALTY_N1;\n                    else if (runX > 5) result++;\n                } else {\n                    this.finderPenaltyAddHistory(runX, runHistory);\n                    if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n                    runColor = this.modules[y][x];\n                    runX = 1;\n                }\n            }\n            result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n        }\n        for(let x = 0; x < this.size; x++){\n            let runColor = false;\n            let runY = 0;\n            const runHistory = [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ];\n            for(let y = 0; y < this.size; y++){\n                if (this.modules[y][x] === runColor) {\n                    runY++;\n                    if (runY === 5) result += PENALTY_N1;\n                    else if (runY > 5) result++;\n                } else {\n                    this.finderPenaltyAddHistory(runY, runHistory);\n                    if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n                    runColor = this.modules[y][x];\n                    runY = 1;\n                }\n            }\n            result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n        }\n        for(let y = 0; y < this.size - 1; y++){\n            for(let x = 0; x < this.size - 1; x++){\n                const color = this.modules[y][x];\n                if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1]) result += PENALTY_N2;\n            }\n        }\n        let dark = 0;\n        for (const row of this.modules)dark = row.reduce((sum, color)=>sum + (color ? 1 : 0), dark);\n        const total = this.size * this.size;\n        const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n        result += k * PENALTY_N4;\n        return result;\n    }\n    /* -- Private helper functions -- */ // Returns an ascending list of positions of alignment patterns for this version number.\n    // Each position is in the range [0,177), and are used on both the x and y axes.\n    // This could be implemented as lookup table of 40 variable-length lists of integers.\n    getAlignmentPatternPositions() {\n        if (this.version === 1) {\n            return [];\n        } else {\n            const numAlign = Math.floor(this.version / 7) + 2;\n            const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n            const result = [\n                6\n            ];\n            for(let pos = this.size - 7; result.length < numAlign; pos -= step)result.splice(1, 0, pos);\n            return result;\n        }\n    }\n    // Can only be called immediately after a light run is added, and\n    // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n    finderPenaltyCountPatterns(runHistory) {\n        const n = runHistory[1];\n        const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;\n        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n    }\n    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n        if (currentRunColor) {\n            this.finderPenaltyAddHistory(currentRunLength, runHistory);\n            currentRunLength = 0;\n        }\n        currentRunLength += this.size;\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        return this.finderPenaltyCountPatterns(runHistory);\n    }\n    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n    finderPenaltyAddHistory(currentRunLength, runHistory) {\n        if (runHistory[0] === 0) currentRunLength += this.size;\n        runHistory.pop();\n        runHistory.unshift(currentRunLength);\n    }\n}\nfunction appendBits(val, len, bb) {\n    if (len < 0 || len > 31 || val >>> len !== 0) throw new RangeError(\"Value out of range\");\n    for(let i = len - 1; i >= 0; i--)bb.push(val >>> i & 1);\n}\nfunction getBit(x, i) {\n    return (x >>> i & 1) !== 0;\n}\nclass QrSegment {\n    // Creates a new QR Code segment with the given attributes and data.\n    // The character count (numChars) must agree with the mode and the bit buffer length,\n    // but the constraint isn't checked. The given bit buffer is cloned and stored.\n    constructor(mode, numChars, bitData){\n        this.mode = mode;\n        this.numChars = numChars;\n        this.bitData = bitData;\n        if (numChars < 0) throw new RangeError(\"Invalid argument\");\n        this.bitData = bitData.slice();\n    }\n    /* -- Methods -- */ // Returns a new copy of the data bits of this segment.\n    getData() {\n        return this.bitData.slice();\n    }\n}\nconst MODE_NUMERIC = [\n    1,\n    10,\n    12,\n    14\n];\nconst MODE_ALPHANUMERIC = [\n    2,\n    9,\n    11,\n    13\n];\nconst MODE_BYTE = [\n    4,\n    8,\n    16,\n    16\n];\nfunction numCharCountBits(mode, ver) {\n    return mode[Math.floor((ver + 7) / 17) + 1];\n}\nfunction makeBytes(data) {\n    const bb = [];\n    for (const b of data)appendBits(b, 8, bb);\n    return new QrSegment(MODE_BYTE, data.length, bb);\n}\nfunction makeNumeric(digits) {\n    if (!isNumeric(digits)) throw new RangeError(\"String contains non-numeric characters\");\n    const bb = [];\n    for(let i = 0; i < digits.length;){\n        const n = Math.min(digits.length - i, 3);\n        appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n        i += n;\n    }\n    return new QrSegment(MODE_NUMERIC, digits.length, bb);\n}\nfunction makeAlphanumeric(text) {\n    if (!isAlphanumeric(text)) throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n    const bb = [];\n    let i;\n    for(i = 0; i + 2 <= text.length; i += 2){\n        let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n        temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n        appendBits(temp, 11, bb);\n    }\n    if (i < text.length) appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n    return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);\n}\nfunction makeSegments(text) {\n    if (text === \"\") return [];\n    else if (isNumeric(text)) return [\n        makeNumeric(text)\n    ];\n    else if (isAlphanumeric(text)) return [\n        makeAlphanumeric(text)\n    ];\n    else return [\n        makeBytes(toUtf8ByteArray(text))\n    ];\n}\nfunction isNumeric(text) {\n    return NUMERIC_REGEX.test(text);\n}\nfunction isAlphanumeric(text) {\n    return ALPHANUMERIC_REGEX.test(text);\n}\nfunction getTotalBits(segs, version) {\n    let result = 0;\n    for (const seg of segs){\n        const ccbits = numCharCountBits(seg.mode, version);\n        if (seg.numChars >= 1 << ccbits) return Number.POSITIVE_INFINITY;\n        result += 4 + ccbits + seg.bitData.length;\n    }\n    return result;\n}\nfunction toUtf8ByteArray(str) {\n    str = encodeURI(str);\n    const result = [];\n    for(let i = 0; i < str.length; i++){\n        if (str.charAt(i) !== \"%\") {\n            result.push(str.charCodeAt(i));\n        } else {\n            result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));\n            i += 2;\n        }\n    }\n    return result;\n}\nfunction getNumRawDataModules(ver) {\n    if (ver < MIN_VERSION || ver > MAX_VERSION) throw new RangeError(\"Version number out of range\");\n    let result = (16 * ver + 128) * ver + 64;\n    if (ver >= 2) {\n        const numAlign = Math.floor(ver / 7) + 2;\n        result -= (25 * numAlign - 10) * numAlign - 55;\n        if (ver >= 7) result -= 36;\n    }\n    return result;\n}\nfunction getNumDataCodewords(ver, ecl) {\n    return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n}\nfunction reedSolomonComputeDivisor(degree) {\n    if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n    const result = [];\n    for(let i = 0; i < degree - 1; i++)result.push(0);\n    result.push(1);\n    let root = 1;\n    for(let i = 0; i < degree; i++){\n        for(let j = 0; j < result.length; j++){\n            result[j] = reedSolomonMultiply(result[j], root);\n            if (j + 1 < result.length) result[j] ^= result[j + 1];\n        }\n        root = reedSolomonMultiply(root, 2);\n    }\n    return result;\n}\nfunction reedSolomonComputeRemainder(data, divisor) {\n    const result = divisor.map((_)=>0);\n    for (const b of data){\n        const factor = b ^ result.shift();\n        result.push(0);\n        divisor.forEach((coef, i)=>result[i] ^= reedSolomonMultiply(coef, factor));\n    }\n    return result;\n}\nfunction reedSolomonMultiply(x, y) {\n    if (x >>> 8 !== 0 || y >>> 8 !== 0) throw new RangeError(\"Byte out of range\");\n    let z = 0;\n    for(let i = 7; i >= 0; i--){\n        z = z << 1 ^ (z >>> 7) * 285;\n        z ^= (y >>> i & 1) * x;\n    }\n    return z;\n}\nfunction encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n    if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError(\"Invalid value\");\n    let version;\n    let dataUsedBits;\n    for(version = minVersion;; version++){\n        const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;\n        const usedBits = getTotalBits(segs, version);\n        if (usedBits <= dataCapacityBits2) {\n            dataUsedBits = usedBits;\n            break;\n        }\n        if (version >= maxVersion) throw new RangeError(\"Data too long\");\n    }\n    for (const newEcl of [\n        MEDIUM,\n        QUARTILE,\n        HIGH\n    ]){\n        if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n    }\n    const bb = [];\n    for (const seg of segs){\n        appendBits(seg.mode[0], 4, bb);\n        appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);\n        for (const b of seg.getData())bb.push(b);\n    }\n    const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n    appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n    appendBits(0, (8 - bb.length % 8) % 8, bb);\n    for(let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)appendBits(padByte, 8, bb);\n    const dataCodewords = Array.from({\n        length: Math.ceil(bb.length / 8)\n    }, ()=>0);\n    bb.forEach((b, i)=>dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n    return new QrCode(version, ecl, dataCodewords, mask);\n}\nfunction encode(data, options) {\n    const { ecc = \"L\", boostEcc = false, minVersion = 1, maxVersion = 40, maskPattern = -1, border = 1 } = options || {};\n    const segment = typeof data === \"string\" ? makeSegments(data) : Array.isArray(data) ? [\n        makeBytes(data)\n    ] : void 0;\n    if (!segment) throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);\n    const qr = encodeSegments(segment, EccMap[ecc], minVersion, maxVersion, maskPattern, boostEcc);\n    const result = addBorder({\n        version: qr.version,\n        maskPattern: qr.mask,\n        size: qr.size,\n        data: qr.modules,\n        types: qr.types\n    }, border);\n    if (options?.invert) result.data = result.data.map((row)=>row.map((mod)=>!mod));\n    options?.onEncoded?.(result);\n    return result;\n}\nfunction addBorder(input, border = 1) {\n    if (!border) return input;\n    const { size } = input;\n    const newSize = size + border * 2;\n    input.size = newSize;\n    input.data.forEach((row)=>{\n        for(let i = 0; i < border; i++){\n            row.unshift(false);\n            row.push(false);\n        }\n    });\n    for(let i = 0; i < border; i++){\n        input.data.unshift(Array.from({\n            length: newSize\n        }, (_)=>false));\n        input.data.push(Array.from({\n            length: newSize\n        }, (_)=>false));\n    }\n    const b = QrCodeDataType.Border;\n    input.types.forEach((row)=>{\n        for(let i = 0; i < border; i++){\n            row.unshift(b);\n            row.push(b);\n        }\n    });\n    for(let i = 0; i < border; i++){\n        input.types.unshift(Array.from({\n            length: newSize\n        }, (_)=>b));\n        input.types.push(Array.from({\n            length: newSize\n        }, (_)=>b));\n    }\n    return input;\n}\nfunction getDataAt(data, x, y, defaults = false) {\n    if (x < 0 || y < 0 || x >= data.length || y >= data.length) return defaults;\n    return data[y][x];\n}\nfunction renderUnicode(data, options = {}) {\n    const { whiteChar = \"█\", blackChar = \"░\" } = options;\n    const result = encode(data, options);\n    return result.data.map((row)=>{\n        return row.map((mod)=>mod ? blackChar : whiteChar).join(\"\");\n    }).join(\"\\n\");\n}\nfunction renderANSI(data, options = {}) {\n    return renderUnicode(data, {\n        ...options,\n        blackChar: \"\\x1b[40m　\\x1b[0m\",\n        whiteChar: \"\\x1b[47m　\\x1b[0m\"\n    });\n}\nfunction renderUnicodeCompact(data, options = {}) {\n    const platte = {\n        WHITE_ALL: \"█\",\n        WHITE_BLACK: \"▀\",\n        BLACK_WHITE: \"▄\",\n        BLACK_ALL: \" \"\n    };\n    const result = encode(data, options);\n    const WHITE = false;\n    const BLACK = true;\n    const at = (x, y)=>getDataAt(result.data, x, y, true);\n    const lines = [];\n    let line = \"\";\n    for(let row = 0; row < result.size; row += 2){\n        for(let col = 0; col < result.size; col++){\n            if (at(col, row) === WHITE && at(col, row + 1) === WHITE) line += platte.WHITE_ALL;\n            else if (at(col, row) === WHITE && at(col, row + 1) === BLACK) line += platte.WHITE_BLACK;\n            else if (at(col, row) === BLACK && at(col, row + 1) === WHITE) line += platte.BLACK_WHITE;\n            else line += platte.BLACK_ALL;\n        }\n        lines.push(line);\n        line = \"\";\n    }\n    return lines.join(\"\\n\");\n}\nfunction renderSVG(data, options = {}) {\n    const result = encode(data, options);\n    const { pixelSize = 10, whiteColor = \"white\", blackColor = \"black\" } = options;\n    const height = result.size * pixelSize;\n    const width = result.size * pixelSize;\n    let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\">`;\n    const pathes = [];\n    for(let row = 0; row < result.size; row++){\n        for(let col = 0; col < result.size; col++){\n            const x = col * pixelSize;\n            const y = row * pixelSize;\n            if (result.data[row][col]) pathes.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);\n        }\n    }\n    svg += `<rect fill=\"${whiteColor}\" width=\"${width}\" height=\"${height}\"/>`;\n    svg += `<path fill=\"${blackColor}\" d=\"${pathes.join(\"\")}\"/>`;\n    svg += \"</svg>\";\n    return svg;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IndlYnBhY2s6Ly93ZWIzZGV2Y291cnNlLy4vbm9kZV9tb2R1bGVzL3Vxci9kaXN0L2luZGV4Lm1qcz9mZDJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBRckNvZGVEYXRhVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFFyQ29kZURhdGFUeXBlMikgPT4ge1xuICBRckNvZGVEYXRhVHlwZTJbUXJDb2RlRGF0YVR5cGUyW1wiQm9yZGVyXCJdID0gLTFdID0gXCJCb3JkZXJcIjtcbiAgUXJDb2RlRGF0YVR5cGUyW1FyQ29kZURhdGFUeXBlMltcIkRhdGFcIl0gPSAwXSA9IFwiRGF0YVwiO1xuICBRckNvZGVEYXRhVHlwZTJbUXJDb2RlRGF0YVR5cGUyW1wiRnVuY3Rpb25cIl0gPSAxXSA9IFwiRnVuY3Rpb25cIjtcbiAgUXJDb2RlRGF0YVR5cGUyW1FyQ29kZURhdGFUeXBlMltcIlBvc2l0aW9uXCJdID0gMl0gPSBcIlBvc2l0aW9uXCI7XG4gIFFyQ29kZURhdGFUeXBlMltRckNvZGVEYXRhVHlwZTJbXCJUaW1pbmdcIl0gPSAzXSA9IFwiVGltaW5nXCI7XG4gIFFyQ29kZURhdGFUeXBlMltRckNvZGVEYXRhVHlwZTJbXCJBbGlnbm1lbnRcIl0gPSA0XSA9IFwiQWxpZ25tZW50XCI7XG4gIHJldHVybiBRckNvZGVEYXRhVHlwZTI7XG59KShRckNvZGVEYXRhVHlwZSB8fCB7fSk7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IExPVyA9IFswLCAxXTtcbmNvbnN0IE1FRElVTSA9IFsxLCAwXTtcbmNvbnN0IFFVQVJUSUxFID0gWzIsIDNdO1xuY29uc3QgSElHSCA9IFszLCAyXTtcbmNvbnN0IEVjY01hcCA9IHtcbiAgTDogTE9XLFxuICBNOiBNRURJVU0sXG4gIFE6IFFVQVJUSUxFLFxuICBIOiBISUdIXG59O1xuY29uc3QgTlVNRVJJQ19SRUdFWCA9IC9eWzAtOV0qJC87XG5jb25zdCBBTFBIQU5VTUVSSUNfUkVHRVggPSAvXltBLVowLTkgJCUqKy5cXC86LV0qJC87XG5jb25zdCBBTFBIQU5VTUVSSUNfQ0hBUlNFVCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86XCI7XG5jb25zdCBNSU5fVkVSU0lPTiA9IDE7XG5jb25zdCBNQVhfVkVSU0lPTiA9IDQwO1xuY29uc3QgUEVOQUxUWV9OMSA9IDM7XG5jb25zdCBQRU5BTFRZX04yID0gMztcbmNvbnN0IFBFTkFMVFlfTjMgPSA0MDtcbmNvbnN0IFBFTkFMVFlfTjQgPSAxMDtcbmNvbnN0IEVDQ19DT0RFV09SRFNfUEVSX0JMT0NLID0gW1xuICAvLyBWZXJzaW9uOiAobm90ZSB0aGF0IGluZGV4IDAgaXMgZm9yIHBhZGRpbmcsIGFuZCBpcyBzZXQgdG8gYW4gaWxsZWdhbCB2YWx1ZSlcbiAgLy8gMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAgICAgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICBbLTEsIDcsIDEwLCAxNSwgMjAsIDI2LCAxOCwgMjAsIDI0LCAzMCwgMTgsIDIwLCAyNCwgMjYsIDMwLCAyMiwgMjQsIDI4LCAzMCwgMjgsIDI4LCAyOCwgMjgsIDMwLCAzMCwgMjYsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdLFxuICAvLyBMb3dcbiAgWy0xLCAxMCwgMTYsIDI2LCAxOCwgMjQsIDE2LCAxOCwgMjIsIDIyLCAyNiwgMzAsIDIyLCAyMiwgMjQsIDI0LCAyOCwgMjgsIDI2LCAyNiwgMjYsIDI2LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOF0sXG4gIC8vIE1lZGl1bVxuICBbLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgLy8gUXVhcnRpbGVcbiAgWy0xLCAxNywgMjgsIDIyLCAxNiwgMjIsIDI4LCAyNiwgMjYsIDI0LCAyOCwgMjQsIDI4LCAyMiwgMjQsIDI0LCAzMCwgMjgsIDI4LCAyNiwgMjgsIDMwLCAyNCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF1cbiAgLy8gSGlnaFxuXTtcbmNvbnN0IE5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyA9IFtcbiAgLy8gVmVyc2lvbjogKG5vdGUgdGhhdCBpbmRleCAwIGlzIGZvciBwYWRkaW5nLCBhbmQgaXMgc2V0IHRvIGFuIGlsbGVnYWwgdmFsdWUpXG4gIC8vIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAgICAgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICBbLTEsIDEsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDQsIDQsIDQsIDQsIDQsIDYsIDYsIDYsIDYsIDcsIDgsIDgsIDksIDksIDEwLCAxMiwgMTIsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMTksIDIwLCAyMSwgMjIsIDI0LCAyNV0sXG4gIC8vIExvd1xuICBbLTEsIDEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gIC8vIE1lZGl1bVxuICBbLTEsIDEsIDEsIDIsIDIsIDQsIDQsIDYsIDYsIDgsIDgsIDgsIDEwLCAxMiwgMTYsIDEyLCAxNywgMTYsIDE4LCAyMSwgMjAsIDIzLCAyMywgMjUsIDI3LCAyOSwgMzQsIDM0LCAzNSwgMzgsIDQwLCA0MywgNDUsIDQ4LCA1MSwgNTMsIDU2LCA1OSwgNjIsIDY1LCA2OF0sXG4gIC8vIFF1YXJ0aWxlXG4gIFstMSwgMSwgMSwgMiwgNCwgNCwgNCwgNSwgNiwgOCwgOCwgMTEsIDExLCAxNiwgMTYsIDE4LCAxNiwgMTksIDIxLCAyNSwgMjUsIDI1LCAzNCwgMzAsIDMyLCAzNSwgMzcsIDQwLCA0MiwgNDUsIDQ4LCA1MSwgNTQsIDU3LCA2MCwgNjMsIDY2LCA3MCwgNzQsIDc3LCA4MV1cbiAgLy8gSGlnaFxuXTtcbmNsYXNzIFFyQ29kZSB7XG4gIC8qIC0tIENvbnN0cnVjdG9yIChsb3cgbGV2ZWwpIGFuZCBmaWVsZHMgLS0gKi9cbiAgLy8gQ3JlYXRlcyBhIG5ldyBRUiBDb2RlIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gbnVtYmVyLFxuICAvLyBlcnJvciBjb3JyZWN0aW9uIGxldmVsLCBkYXRhIGNvZGV3b3JkIGJ5dGVzLCBhbmQgbWFzayBudW1iZXIuXG4gIC8vIFRoaXMgaXMgYSBsb3ctbGV2ZWwgQVBJIHRoYXQgbW9zdCB1c2VycyBzaG91bGQgbm90IHVzZSBkaXJlY3RseS5cbiAgLy8gQSBtaWQtbGV2ZWwgQVBJIGlzIHRoZSBlbmNvZGVTZWdtZW50cygpIGZ1bmN0aW9uLlxuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBlY2MsIGRhdGFDb2Rld29yZHMsIG1zaykge1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5lY2MgPSBlY2M7XG4gICAgLyogLS0gRmllbGRzIC0tICovXG4gICAgLy8gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhpcyBRUiBDb2RlLCBtZWFzdXJlZCBpbiBtb2R1bGVzLCBiZXR3ZWVuXG4gICAgLy8gMjEgYW5kIDE3NyAoaW5jbHVzaXZlKS4gVGhpcyBpcyBlcXVhbCB0byB2ZXJzaW9uICogNCArIDE3LlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaXplXCIpO1xuICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgbWFzayBwYXR0ZXJuIHVzZWQgaW4gdGhpcyBRUiBDb2RlLCB3aGljaCBpcyBiZXR3ZWVuIDAgYW5kIDcgKGluY2x1c2l2ZSkuXG4gICAgLy8gRXZlbiBpZiBhIFFSIENvZGUgaXMgY3JlYXRlZCB3aXRoIGF1dG9tYXRpYyBtYXNraW5nIHJlcXVlc3RlZCAobWFzayA9IC0xKSxcbiAgICAvLyB0aGUgcmVzdWx0aW5nIG9iamVjdCBzdGlsbCBoYXMgYSBtYXNrIHZhbHVlIGJldHdlZW4gMCBhbmQgNy5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1wiKTtcbiAgICAvLyBUaGUgbW9kdWxlcyBvZiB0aGlzIFFSIENvZGUgKGZhbHNlID0gbGlnaHQsIHRydWUgPSBkYXJrKS5cbiAgICAvLyBJbW11dGFibGUgYWZ0ZXIgY29uc3RydWN0b3IgZmluaXNoZXMuIEFjY2Vzc2VkIHRocm91Z2ggZ2V0TW9kdWxlKCkuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vZHVsZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlc1wiLCBbXSk7XG4gICAgaWYgKHZlcnNpb24gPCBNSU5fVkVSU0lPTiB8fCB2ZXJzaW9uID4gTUFYX1ZFUlNJT04pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgIGlmIChtc2sgPCAtMSB8fCBtc2sgPiA3KVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICB0aGlzLnNpemUgPSB2ZXJzaW9uICogNCArIDE3O1xuICAgIGNvbnN0IHJvdyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMuc2l6ZSB9LCAoKSA9PiBmYWxzZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgdGhpcy5tb2R1bGVzLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgdGhpcy50eXBlcy5wdXNoKHJvdy5tYXAoKCkgPT4gMCkpO1xuICAgIH1cbiAgICB0aGlzLmRyYXdGdW5jdGlvblBhdHRlcm5zKCk7XG4gICAgY29uc3QgYWxsQ29kZXdvcmRzID0gdGhpcy5hZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGFDb2Rld29yZHMpO1xuICAgIHRoaXMuZHJhd0NvZGV3b3JkcyhhbGxDb2Rld29yZHMpO1xuICAgIGlmIChtc2sgPT09IC0xKSB7XG4gICAgICBsZXQgbWluUGVuYWx0eSA9IDFlOTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKGkpO1xuICAgICAgICBjb25zdCBwZW5hbHR5ID0gdGhpcy5nZXRQZW5hbHR5U2NvcmUoKTtcbiAgICAgICAgaWYgKHBlbmFsdHkgPCBtaW5QZW5hbHR5KSB7XG4gICAgICAgICAgbXNrID0gaTtcbiAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5TWFzayhpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXNrID0gbXNrO1xuICAgIHRoaXMuYXBwbHlNYXNrKG1zayk7XG4gICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhtc2spO1xuICB9XG4gIC8qIC0tIEFjY2Vzc29yIG1ldGhvZHMgLS0gKi9cbiAgLy8gUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIG1vZHVsZSAocGl4ZWwpIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcywgd2hpY2ggaXMgZmFsc2VcbiAgLy8gZm9yIGxpZ2h0IG9yIHRydWUgZm9yIGRhcmsuIFRoZSB0b3AgbGVmdCBjb3JuZXIgaGFzIHRoZSBjb29yZGluYXRlcyAoeD0wLCB5PTApLlxuICAvLyBJZiB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIG91dCBvZiBib3VuZHMsIHRoZW4gZmFsc2UgKGxpZ2h0KSBpcyByZXR1cm5lZC5cbiAgZ2V0TW9kdWxlKHgsIHkpIHtcbiAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLnNpemUgJiYgeSA+PSAwICYmIHkgPCB0aGlzLnNpemUgJiYgdGhpcy5tb2R1bGVzW3ldW3hdO1xuICB9XG4gIC8qIC0tIFByaXZhdGUgaGVscGVyIG1ldGhvZHMgZm9yIGNvbnN0cnVjdG9yOiBEcmF3aW5nIGZ1bmN0aW9uIG1vZHVsZXMgLS0gKi9cbiAgLy8gUmVhZHMgdGhpcyBvYmplY3QncyB2ZXJzaW9uIGZpZWxkLCBhbmQgZHJhd3MgYW5kIG1hcmtzIGFsbCBmdW5jdGlvbiBtb2R1bGVzLlxuICBkcmF3RnVuY3Rpb25QYXR0ZXJucygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDYsIGksIGkgJSAyID09PSAwLCBRckNvZGVEYXRhVHlwZS5UaW1pbmcpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShpLCA2LCBpICUgMiA9PT0gMCwgUXJDb2RlRGF0YVR5cGUuVGltaW5nKTtcbiAgICB9XG4gICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCAzKTtcbiAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKHRoaXMuc2l6ZSAtIDQsIDMpO1xuICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4oMywgdGhpcy5zaXplIC0gNCk7XG4gICAgY29uc3QgYWxpZ25QYXRQb3MgPSB0aGlzLmdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKTtcbiAgICBjb25zdCBudW1BbGlnbiA9IGFsaWduUGF0UG9zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUFsaWduOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQWxpZ247IGorKykge1xuICAgICAgICBpZiAoIShpID09PSAwICYmIGogPT09IDAgfHwgaSA9PT0gMCAmJiBqID09PSBudW1BbGlnbiAtIDEgfHwgaSA9PT0gbnVtQWxpZ24gLSAxICYmIGogPT09IDApKVxuICAgICAgICAgIHRoaXMuZHJhd0FsaWdubWVudFBhdHRlcm4oYWxpZ25QYXRQb3NbaV0sIGFsaWduUGF0UG9zW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kcmF3Rm9ybWF0Qml0cygwKTtcbiAgICB0aGlzLmRyYXdWZXJzaW9uKCk7XG4gIH1cbiAgLy8gRHJhd3MgdHdvIGNvcGllcyBvZiB0aGUgZm9ybWF0IGJpdHMgKHdpdGggaXRzIG93biBlcnJvciBjb3JyZWN0aW9uIGNvZGUpXG4gIC8vIGJhc2VkIG9uIHRoZSBnaXZlbiBtYXNrIGFuZCB0aGlzIG9iamVjdCdzIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgZmllbGQuXG4gIGRyYXdGb3JtYXRCaXRzKG1hc2spIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5lY2NbMV0gPDwgMyB8IG1hc2s7XG4gICAgbGV0IHJlbSA9IGRhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiA5KSAqIDEzMzU7XG4gICAgY29uc3QgYml0cyA9IChkYXRhIDw8IDEwIHwgcmVtKSBeIDIxNTIyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDU7IGkrKylcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgaSwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDcsIGdldEJpdChiaXRzLCA2KSk7XG4gICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCA4LCBnZXRCaXQoYml0cywgNykpO1xuICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNywgOCwgZ2V0Qml0KGJpdHMsIDgpKTtcbiAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDE0IC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUodGhpcy5zaXplIC0gMSAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgZm9yIChsZXQgaSA9IDg7IGkgPCAxNTsgaSsrKVxuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSAxNSArIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSA4LCB0cnVlKTtcbiAgfVxuICAvLyBEcmF3cyB0d28gY29waWVzIG9mIHRoZSB2ZXJzaW9uIGJpdHMgKHdpdGggaXRzIG93biBlcnJvciBjb3JyZWN0aW9uIGNvZGUpLFxuICAvLyBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIHZlcnNpb24gZmllbGQsIGlmZiA3IDw9IHZlcnNpb24gPD0gNDAuXG4gIGRyYXdWZXJzaW9uKCkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPCA3KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCByZW0gPSB0aGlzLnZlcnNpb247XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiAxMSkgKiA3OTczO1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZlcnNpb24gPDwgMTIgfCByZW07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldEJpdChiaXRzLCBpKTtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnNpemUgLSAxMSArIGkgJSAzO1xuICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShhLCBiLCBjb2xvcik7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGIsIGEsIGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgLy8gRHJhd3MgYSA5KjkgZmluZGVyIHBhdHRlcm4gaW5jbHVkaW5nIHRoZSBib3JkZXIgc2VwYXJhdG9yLFxuICAvLyB3aXRoIHRoZSBjZW50ZXIgbW9kdWxlIGF0ICh4LCB5KS4gTW9kdWxlcyBjYW4gYmUgb3V0IG9mIGJvdW5kcy5cbiAgZHJhd0ZpbmRlclBhdHRlcm4oeCwgeSkge1xuICAgIGZvciAobGV0IGR5ID0gLTQ7IGR5IDw9IDQ7IGR5KyspIHtcbiAgICAgIGZvciAobGV0IGR4ID0gLTQ7IGR4IDw9IDQ7IGR4KyspIHtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKTtcbiAgICAgICAgY29uc3QgeHggPSB4ICsgZHg7XG4gICAgICAgIGNvbnN0IHl5ID0geSArIGR5O1xuICAgICAgICBpZiAoeHggPj0gMCAmJiB4eCA8IHRoaXMuc2l6ZSAmJiB5eSA+PSAwICYmIHl5IDwgdGhpcy5zaXplKVxuICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeHgsIHl5LCBkaXN0ICE9PSAyICYmIGRpc3QgIT09IDQsIFFyQ29kZURhdGFUeXBlLlBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRHJhd3MgYSA1KjUgYWxpZ25tZW50IHBhdHRlcm4sIHdpdGggdGhlIGNlbnRlciBtb2R1bGVcbiAgLy8gYXQgKHgsIHkpLiBBbGwgbW9kdWxlcyBtdXN0IGJlIGluIGJvdW5kcy5cbiAgZHJhd0FsaWdubWVudFBhdHRlcm4oeCwgeSkge1xuICAgIGZvciAobGV0IGR5ID0gLTI7IGR5IDw9IDI7IGR5KyspIHtcbiAgICAgIGZvciAobGV0IGR4ID0gLTI7IGR4IDw9IDI7IGR4KyspIHtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShcbiAgICAgICAgICB4ICsgZHgsXG4gICAgICAgICAgeSArIGR5LFxuICAgICAgICAgIE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSAhPT0gMSxcbiAgICAgICAgICBRckNvZGVEYXRhVHlwZS5BbGlnbm1lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gU2V0cyB0aGUgY29sb3Igb2YgYSBtb2R1bGUgYW5kIG1hcmtzIGl0IGFzIGEgZnVuY3Rpb24gbW9kdWxlLlxuICAvLyBPbmx5IHVzZWQgYnkgdGhlIGNvbnN0cnVjdG9yLiBDb29yZGluYXRlcyBtdXN0IGJlIGluIGJvdW5kcy5cbiAgc2V0RnVuY3Rpb25Nb2R1bGUoeCwgeSwgaXNEYXJrLCB0eXBlID0gUXJDb2RlRGF0YVR5cGUuRnVuY3Rpb24pIHtcbiAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBpc0Rhcms7XG4gICAgdGhpcy50eXBlc1t5XVt4XSA9IHR5cGU7XG4gIH1cbiAgLyogLS0gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kcyBmb3IgY29uc3RydWN0b3I6IENvZGV3b3JkcyBhbmQgbWFza2luZyAtLSAqL1xuICAvLyBSZXR1cm5zIGEgbmV3IGJ5dGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoZSBhcHByb3ByaWF0ZSBlcnJvciBjb3JyZWN0aW9uXG4gIC8vIGNvZGV3b3JkcyBhcHBlbmRlZCB0byBpdCwgYmFzZWQgb24gdGhpcyBvYmplY3QncyB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICBhZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGEpIHtcbiAgICBjb25zdCB2ZXIgPSB0aGlzLnZlcnNpb247XG4gICAgY29uc3QgZWNsID0gdGhpcy5lY2M7XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSBnZXROdW1EYXRhQ29kZXdvcmRzKHZlciwgZWNsKSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICBjb25zdCBudW1CbG9ja3MgPSBOVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsWzBdXVt2ZXJdO1xuICAgIGNvbnN0IGJsb2NrRWNjTGVuID0gRUNDX0NPREVXT1JEU19QRVJfQkxPQ0tbZWNsWzBdXVt2ZXJdO1xuICAgIGNvbnN0IHJhd0NvZGV3b3JkcyA9IE1hdGguZmxvb3IoZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpO1xuICAgIGNvbnN0IG51bVNob3J0QmxvY2tzID0gbnVtQmxvY2tzIC0gcmF3Q29kZXdvcmRzICUgbnVtQmxvY2tzO1xuICAgIGNvbnN0IHNob3J0QmxvY2tMZW4gPSBNYXRoLmZsb29yKHJhd0NvZGV3b3JkcyAvIG51bUJsb2Nrcyk7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgY29uc3QgcnNEaXYgPSByZWVkU29sb21vbkNvbXB1dGVEaXZpc29yKGJsb2NrRWNjTGVuKTtcbiAgICBmb3IgKGxldCBpID0gMCwgayA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgY29uc3QgZGF0ID0gZGF0YS5zbGljZShrLCBrICsgc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuICsgKGkgPCBudW1TaG9ydEJsb2NrcyA/IDAgOiAxKSk7XG4gICAgICBrICs9IGRhdC5sZW5ndGg7XG4gICAgICBjb25zdCBlY2MgPSByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0LCByc0Rpdik7XG4gICAgICBpZiAoaSA8IG51bVNob3J0QmxvY2tzKVxuICAgICAgICBkYXQucHVzaCgwKTtcbiAgICAgIGJsb2Nrcy5wdXNoKGRhdC5jb25jYXQoZWNjKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGopID0+IHtcbiAgICAgICAgaWYgKGkgIT09IHNob3J0QmxvY2tMZW4gLSBibG9ja0VjY0xlbiB8fCBqID49IG51bVNob3J0QmxvY2tzKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGJsb2NrW2ldKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIERyYXdzIHRoZSBnaXZlbiBzZXF1ZW5jZSBvZiA4LWJpdCBjb2Rld29yZHMgKGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24pIG9udG8gdGhlIGVudGlyZVxuICAvLyBkYXRhIGFyZWEgb2YgdGhpcyBRUiBDb2RlLiBGdW5jdGlvbiBtb2R1bGVzIG5lZWQgdG8gYmUgbWFya2VkIG9mZiBiZWZvcmUgdGhpcyBpcyBjYWxsZWQuXG4gIGRyYXdDb2Rld29yZHMoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gTWF0aC5mbG9vcihnZXROdW1SYXdEYXRhTW9kdWxlcyh0aGlzLnZlcnNpb24pIC8gOCkpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHJpZ2h0ID0gdGhpcy5zaXplIC0gMTsgcmlnaHQgPj0gMTsgcmlnaHQgLT0gMikge1xuICAgICAgaWYgKHJpZ2h0ID09PSA2KVxuICAgICAgICByaWdodCA9IDU7XG4gICAgICBmb3IgKGxldCB2ZXJ0ID0gMDsgdmVydCA8IHRoaXMuc2l6ZTsgdmVydCsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHJpZ2h0IC0gajtcbiAgICAgICAgICBjb25zdCB1cHdhcmQgPSAocmlnaHQgKyAxICYgMikgPT09IDA7XG4gICAgICAgICAgY29uc3QgeSA9IHVwd2FyZCA/IHRoaXMuc2l6ZSAtIDEgLSB2ZXJ0IDogdmVydDtcbiAgICAgICAgICBpZiAoIXRoaXMudHlwZXNbeV1beF0gJiYgaSA8IGRhdGEubGVuZ3RoICogOCkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gZ2V0Qml0KGRhdGFbaSA+Pj4gM10sIDcgLSAoaSAmIDcpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gWE9ScyB0aGUgY29kZXdvcmQgbW9kdWxlcyBpbiB0aGlzIFFSIENvZGUgd2l0aCB0aGUgZ2l2ZW4gbWFzayBwYXR0ZXJuLlxuICAvLyBUaGUgZnVuY3Rpb24gbW9kdWxlcyBtdXN0IGJlIG1hcmtlZCBhbmQgdGhlIGNvZGV3b3JkIGJpdHMgbXVzdCBiZSBkcmF3blxuICAvLyBiZWZvcmUgbWFza2luZy4gRHVlIHRvIHRoZSBhcml0aG1ldGljIG9mIFhPUiwgY2FsbGluZyBhcHBseU1hc2soKSB3aXRoXG4gIC8vIHRoZSBzYW1lIG1hc2sgdmFsdWUgYSBzZWNvbmQgdGltZSB3aWxsIHVuZG8gdGhlIG1hc2suIEEgZmluYWwgd2VsbC1mb3JtZWRcbiAgLy8gUVIgQ29kZSBuZWVkcyBleGFjdGx5IG9uZSAobm90IHplcm8sIHR3bywgZXRjLikgbWFzayBhcHBsaWVkLlxuICBhcHBseU1hc2sobWFzaykge1xuICAgIGlmIChtYXNrIDwgMCB8fCBtYXNrID4gNylcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFzayB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICBsZXQgaW52ZXJ0O1xuICAgICAgICBzd2l0Y2ggKG1hc2spIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpbnZlcnQgPSAoeCArIHkpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGludmVydCA9IHkgJSAyID09PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaW52ZXJ0ID0geCAlIDMgPT09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpbnZlcnQgPSAoeCArIHkpICUgMyA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGludmVydCA9IChNYXRoLmZsb29yKHggLyAzKSArIE1hdGguZmxvb3IoeSAvIDIpKSAlIDIgPT09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbnZlcnQgPSB4ICogeSAlIDIgKyB4ICogeSAlIDMgPT09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpbnZlcnQgPSAoeCAqIHkgJSAyICsgeCAqIHkgJSAzKSAlIDIgPT09IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpbnZlcnQgPSAoKHggKyB5KSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHlwZXNbeV1beF0gJiYgaW52ZXJ0KVxuICAgICAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9ICF0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHBlbmFsdHkgc2NvcmUgYmFzZWQgb24gc3RhdGUgb2YgdGhpcyBRUiBDb2RlJ3MgY3VycmVudCBtb2R1bGVzLlxuICAvLyBUaGlzIGlzIHVzZWQgYnkgdGhlIGF1dG9tYXRpYyBtYXNrIGNob2ljZSBhbGdvcml0aG0gdG8gZmluZCB0aGUgbWFzayBwYXR0ZXJuIHRoYXQgeWllbGRzIHRoZSBsb3dlc3Qgc2NvcmUuXG4gIGdldFBlbmFsdHlTY29yZSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgIGxldCBydW5YID0gMDtcbiAgICAgIGNvbnN0IHJ1bkhpc3RvcnkgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT09IHJ1bkNvbG9yKSB7XG4gICAgICAgICAgcnVuWCsrO1xuICAgICAgICAgIGlmIChydW5YID09PSA1KVxuICAgICAgICAgICAgcmVzdWx0ICs9IFBFTkFMVFlfTjE7XG4gICAgICAgICAgZWxzZSBpZiAocnVuWCA+IDUpXG4gICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KHJ1blgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIFBFTkFMVFlfTjM7XG4gICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgcnVuWCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWCwgcnVuSGlzdG9yeSkgKiBQRU5BTFRZX04zO1xuICAgIH1cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgIGxldCBydW5ZID0gMDtcbiAgICAgIGNvbnN0IHJ1bkhpc3RvcnkgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT09IHJ1bkNvbG9yKSB7XG4gICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgIGlmIChydW5ZID09PSA1KVxuICAgICAgICAgICAgcmVzdWx0ICs9IFBFTkFMVFlfTjE7XG4gICAgICAgICAgZWxzZSBpZiAocnVuWSA+IDUpXG4gICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KHJ1blksIHJ1bkhpc3RvcnkpO1xuICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIFBFTkFMVFlfTjM7XG4gICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgcnVuWSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWSwgcnVuSGlzdG9yeSkgKiBQRU5BTFRZX04zO1xuICAgIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZSAtIDE7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemUgLSAxOyB4KyspIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgIGlmIChjb2xvciA9PT0gdGhpcy5tb2R1bGVzW3ldW3ggKyAxXSAmJiBjb2xvciA9PT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4XSAmJiBjb2xvciA9PT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4ICsgMV0pXG4gICAgICAgICAgcmVzdWx0ICs9IFBFTkFMVFlfTjI7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXJrID0gMDtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLm1vZHVsZXMpXG4gICAgICBkYXJrID0gcm93LnJlZHVjZSgoc3VtLCBjb2xvcikgPT4gc3VtICsgKGNvbG9yID8gMSA6IDApLCBkYXJrKTtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcbiAgICBjb25zdCBrID0gTWF0aC5jZWlsKE1hdGguYWJzKGRhcmsgKiAyMCAtIHRvdGFsICogMTApIC8gdG90YWwpIC0gMTtcbiAgICByZXN1bHQgKz0gayAqIFBFTkFMVFlfTjQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiAtLSBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgLS0gKi9cbiAgLy8gUmV0dXJucyBhbiBhc2NlbmRpbmcgbGlzdCBvZiBwb3NpdGlvbnMgb2YgYWxpZ25tZW50IHBhdHRlcm5zIGZvciB0aGlzIHZlcnNpb24gbnVtYmVyLlxuICAvLyBFYWNoIHBvc2l0aW9uIGlzIGluIHRoZSByYW5nZSBbMCwxNzcpLCBhbmQgYXJlIHVzZWQgb24gYm90aCB0aGUgeCBhbmQgeSBheGVzLlxuICAvLyBUaGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIGxvb2t1cCB0YWJsZSBvZiA0MCB2YXJpYWJsZS1sZW5ndGggbGlzdHMgb2YgaW50ZWdlcnMuXG4gIGdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1BbGlnbiA9IE1hdGguZmxvb3IodGhpcy52ZXJzaW9uIC8gNykgKyAyO1xuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMudmVyc2lvbiA9PT0gMzIgPyAyNiA6IE1hdGguY2VpbCgodGhpcy52ZXJzaW9uICogNCArIDQpIC8gKG51bUFsaWduICogMiAtIDIpKSAqIDI7XG4gICAgICBjb25zdCByZXN1bHQgPSBbNl07XG4gICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLnNpemUgLSA3OyByZXN1bHQubGVuZ3RoIDwgbnVtQWxpZ247IHBvcyAtPSBzdGVwKVxuICAgICAgICByZXN1bHQuc3BsaWNlKDEsIDAsIHBvcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICAvLyBDYW4gb25seSBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBsaWdodCBydW4gaXMgYWRkZWQsIGFuZFxuICAvLyByZXR1cm5zIGVpdGhlciAwLCAxLCBvciAyLiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0UGVuYWx0eVNjb3JlKCkuXG4gIGZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpIHtcbiAgICBjb25zdCBuID0gcnVuSGlzdG9yeVsxXTtcbiAgICBjb25zdCBjb3JlID0gbiA+IDAgJiYgcnVuSGlzdG9yeVsyXSA9PT0gbiAmJiBydW5IaXN0b3J5WzNdID09PSBuICogMyAmJiBydW5IaXN0b3J5WzRdID09PSBuICYmIHJ1bkhpc3RvcnlbNV0gPT09IG47XG4gICAgcmV0dXJuIChjb3JlICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiAqIDQgJiYgcnVuSGlzdG9yeVs2XSA+PSBuID8gMSA6IDApICsgKGNvcmUgJiYgcnVuSGlzdG9yeVs2XSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzBdID49IG4gPyAxIDogMCk7XG4gIH1cbiAgLy8gTXVzdCBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhIGxpbmUgKHJvdyBvciBjb2x1bW4pIG9mIG1vZHVsZXMuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXRQZW5hbHR5U2NvcmUoKS5cbiAgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvciwgY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgIGlmIChjdXJyZW50UnVuQ29sb3IpIHtcbiAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSk7XG4gICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgY3VycmVudFJ1bkxlbmd0aCArPSB0aGlzLnNpemU7XG4gICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICByZXR1cm4gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KTtcbiAgfVxuICAvLyBQdXNoZXMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBmcm9udCBhbmQgZHJvcHMgdGhlIGxhc3QgdmFsdWUuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXRQZW5hbHR5U2NvcmUoKS5cbiAgZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgIGlmIChydW5IaXN0b3J5WzBdID09PSAwKVxuICAgICAgY3VycmVudFJ1bkxlbmd0aCArPSB0aGlzLnNpemU7XG4gICAgcnVuSGlzdG9yeS5wb3AoKTtcbiAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEJpdHModmFsLCBsZW4sIGJiKSB7XG4gIGlmIChsZW4gPCAwIHx8IGxlbiA+IDMxIHx8IHZhbCA+Pj4gbGVuICE9PSAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgYmIucHVzaCh2YWwgPj4+IGkgJiAxKTtcbn1cbmZ1bmN0aW9uIGdldEJpdCh4LCBpKSB7XG4gIHJldHVybiAoeCA+Pj4gaSAmIDEpICE9PSAwO1xufVxuY2xhc3MgUXJTZWdtZW50IHtcbiAgLy8gQ3JlYXRlcyBhIG5ldyBRUiBDb2RlIHNlZ21lbnQgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhbmQgZGF0YS5cbiAgLy8gVGhlIGNoYXJhY3RlciBjb3VudCAobnVtQ2hhcnMpIG11c3QgYWdyZWUgd2l0aCB0aGUgbW9kZSBhbmQgdGhlIGJpdCBidWZmZXIgbGVuZ3RoLFxuICAvLyBidXQgdGhlIGNvbnN0cmFpbnQgaXNuJ3QgY2hlY2tlZC4gVGhlIGdpdmVuIGJpdCBidWZmZXIgaXMgY2xvbmVkIGFuZCBzdG9yZWQuXG4gIGNvbnN0cnVjdG9yKG1vZGUsIG51bUNoYXJzLCBiaXREYXRhKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLm51bUNoYXJzID0gbnVtQ2hhcnM7XG4gICAgdGhpcy5iaXREYXRhID0gYml0RGF0YTtcbiAgICBpZiAobnVtQ2hhcnMgPCAwKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgIHRoaXMuYml0RGF0YSA9IGJpdERhdGEuc2xpY2UoKTtcbiAgfVxuICAvKiAtLSBNZXRob2RzIC0tICovXG4gIC8vIFJldHVybnMgYSBuZXcgY29weSBvZiB0aGUgZGF0YSBiaXRzIG9mIHRoaXMgc2VnbWVudC5cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5iaXREYXRhLnNsaWNlKCk7XG4gIH1cbn1cbmNvbnN0IE1PREVfTlVNRVJJQyA9IFsxLCAxMCwgMTIsIDE0XTtcbmNvbnN0IE1PREVfQUxQSEFOVU1FUklDID0gWzIsIDksIDExLCAxM107XG5jb25zdCBNT0RFX0JZVEUgPSBbNCwgOCwgMTYsIDE2XTtcbmZ1bmN0aW9uIG51bUNoYXJDb3VudEJpdHMobW9kZSwgdmVyKSB7XG4gIHJldHVybiBtb2RlW01hdGguZmxvb3IoKHZlciArIDcpIC8gMTcpICsgMV07XG59XG5mdW5jdGlvbiBtYWtlQnl0ZXMoZGF0YSkge1xuICBjb25zdCBiYiA9IFtdO1xuICBmb3IgKGNvbnN0IGIgb2YgZGF0YSlcbiAgICBhcHBlbmRCaXRzKGIsIDgsIGJiKTtcbiAgcmV0dXJuIG5ldyBRclNlZ21lbnQoTU9ERV9CWVRFLCBkYXRhLmxlbmd0aCwgYmIpO1xufVxuZnVuY3Rpb24gbWFrZU51bWVyaWMoZGlnaXRzKSB7XG4gIGlmICghaXNOdW1lcmljKGRpZ2l0cykpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgbm9uLW51bWVyaWMgY2hhcmFjdGVyc1wiKTtcbiAgY29uc3QgYmIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHMubGVuZ3RoOyApIHtcbiAgICBjb25zdCBuID0gTWF0aC5taW4oZGlnaXRzLmxlbmd0aCAtIGksIDMpO1xuICAgIGFwcGVuZEJpdHMoTnVtYmVyLnBhcnNlSW50KGRpZ2l0cy5zdWJzdHJpbmcoaSwgaSArIG4pLCAxMCksIG4gKiAzICsgMSwgYmIpO1xuICAgIGkgKz0gbjtcbiAgfVxuICByZXR1cm4gbmV3IFFyU2VnbWVudChNT0RFX05VTUVSSUMsIGRpZ2l0cy5sZW5ndGgsIGJiKTtcbn1cbmZ1bmN0aW9uIG1ha2VBbHBoYW51bWVyaWModGV4dCkge1xuICBpZiAoIWlzQWxwaGFudW1lcmljKHRleHQpKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIHVuZW5jb2RhYmxlIGNoYXJhY3RlcnMgaW4gYWxwaGFudW1lcmljIG1vZGVcIik7XG4gIGNvbnN0IGJiID0gW107XG4gIGxldCBpO1xuICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgbGV0IHRlbXAgPSBBTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgIHRlbXAgKz0gQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpO1xuICAgIGFwcGVuZEJpdHModGVtcCwgMTEsIGJiKTtcbiAgfVxuICBpZiAoaSA8IHRleHQubGVuZ3RoKVxuICAgIGFwcGVuZEJpdHMoQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSksIDYsIGJiKTtcbiAgcmV0dXJuIG5ldyBRclNlZ21lbnQoTU9ERV9BTFBIQU5VTUVSSUMsIHRleHQubGVuZ3RoLCBiYik7XG59XG5mdW5jdGlvbiBtYWtlU2VnbWVudHModGV4dCkge1xuICBpZiAodGV4dCA9PT0gXCJcIilcbiAgICByZXR1cm4gW107XG4gIGVsc2UgaWYgKGlzTnVtZXJpYyh0ZXh0KSlcbiAgICByZXR1cm4gW21ha2VOdW1lcmljKHRleHQpXTtcbiAgZWxzZSBpZiAoaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgcmV0dXJuIFttYWtlQWxwaGFudW1lcmljKHRleHQpXTtcbiAgZWxzZVxuICAgIHJldHVybiBbbWFrZUJ5dGVzKHRvVXRmOEJ5dGVBcnJheSh0ZXh0KSldO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljKHRleHQpIHtcbiAgcmV0dXJuIE5VTUVSSUNfUkVHRVgudGVzdCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzQWxwaGFudW1lcmljKHRleHQpIHtcbiAgcmV0dXJuIEFMUEhBTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGZvciAoY29uc3Qgc2VnIG9mIHNlZ3MpIHtcbiAgICBjb25zdCBjY2JpdHMgPSBudW1DaGFyQ291bnRCaXRzKHNlZy5tb2RlLCB2ZXJzaW9uKTtcbiAgICBpZiAoc2VnLm51bUNoYXJzID49IDEgPDwgY2NiaXRzKVxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICByZXN1bHQgKz0gNCArIGNjYml0cyArIHNlZy5iaXREYXRhLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9VdGY4Qnl0ZUFycmF5KHN0cikge1xuICBzdHIgPSBlbmNvZGVVUkkoc3RyKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgIT09IFwiJVwiKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKE51bWJlci5wYXJzZUludChzdHIuc3Vic3RyaW5nKGkgKyAxLCBpICsgMyksIDE2KSk7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIHtcbiAgaWYgKHZlciA8IE1JTl9WRVJTSU9OIHx8IHZlciA+IE1BWF9WRVJTSU9OKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmVyc2lvbiBudW1iZXIgb3V0IG9mIHJhbmdlXCIpO1xuICBsZXQgcmVzdWx0ID0gKDE2ICogdmVyICsgMTI4KSAqIHZlciArIDY0O1xuICBpZiAodmVyID49IDIpIHtcbiAgICBjb25zdCBudW1BbGlnbiA9IE1hdGguZmxvb3IodmVyIC8gNykgKyAyO1xuICAgIHJlc3VsdCAtPSAoMjUgKiBudW1BbGlnbiAtIDEwKSAqIG51bUFsaWduIC0gNTU7XG4gICAgaWYgKHZlciA+PSA3KVxuICAgICAgcmVzdWx0IC09IDM2O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROdW1EYXRhQ29kZXdvcmRzKHZlciwgZWNsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGdldE51bVJhd0RhdGFNb2R1bGVzKHZlcikgLyA4KSAtIEVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbFswXV1bdmVyXSAqIE5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2xbMF1dW3Zlcl07XG59XG5mdW5jdGlvbiByZWVkU29sb21vbkNvbXB1dGVEaXZpc29yKGRlZ3JlZSkge1xuICBpZiAoZGVncmVlIDwgMSB8fCBkZWdyZWUgPiAyNTUpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWdyZWUgb3V0IG9mIHJhbmdlXCIpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWUgLSAxOyBpKyspXG4gICAgcmVzdWx0LnB1c2goMCk7XG4gIHJlc3VsdC5wdXNoKDEpO1xuICBsZXQgcm9vdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgcmVzdWx0W2pdID0gcmVlZFNvbG9tb25NdWx0aXBseShyZXN1bHRbal0sIHJvb3QpO1xuICAgICAgaWYgKGogKyAxIDwgcmVzdWx0Lmxlbmd0aClcbiAgICAgICAgcmVzdWx0W2pdIF49IHJlc3VsdFtqICsgMV07XG4gICAgfVxuICAgIHJvb3QgPSByZWVkU29sb21vbk11bHRpcGx5KHJvb3QsIDIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0YSwgZGl2aXNvcikge1xuICBjb25zdCByZXN1bHQgPSBkaXZpc29yLm1hcCgoXykgPT4gMCk7XG4gIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgY29uc3QgZmFjdG9yID0gYiBeIHJlc3VsdC5zaGlmdCgpO1xuICAgIHJlc3VsdC5wdXNoKDApO1xuICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gcmVzdWx0W2ldIF49IHJlZWRTb2xvbW9uTXVsdGlwbHkoY29lZiwgZmFjdG9yKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZWRTb2xvbW9uTXVsdGlwbHkoeCwgeSkge1xuICBpZiAoeCA+Pj4gOCAhPT0gMCB8fCB5ID4+PiA4ICE9PSAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQnl0ZSBvdXQgb2YgcmFuZ2VcIik7XG4gIGxldCB6ID0gMDtcbiAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgeiA9IHogPDwgMSBeICh6ID4+PiA3KSAqIDI4NTtcbiAgICB6IF49ICh5ID4+PiBpICYgMSkgKiB4O1xuICB9XG4gIHJldHVybiB6O1xufVxuZnVuY3Rpb24gZW5jb2RlU2VnbWVudHMoc2VncywgZWNsLCBtaW5WZXJzaW9uID0gMSwgbWF4VmVyc2lvbiA9IDQwLCBtYXNrID0gLTEsIGJvb3N0RWNsID0gdHJ1ZSkge1xuICBpZiAoIShNSU5fVkVSU0lPTiA8PSBtaW5WZXJzaW9uICYmIG1pblZlcnNpb24gPD0gbWF4VmVyc2lvbiAmJiBtYXhWZXJzaW9uIDw9IE1BWF9WRVJTSU9OKSB8fCBtYXNrIDwgLTEgfHwgbWFzayA+IDcpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlXCIpO1xuICBsZXQgdmVyc2lvbjtcbiAgbGV0IGRhdGFVc2VkQml0cztcbiAgZm9yICh2ZXJzaW9uID0gbWluVmVyc2lvbjsgOyB2ZXJzaW9uKyspIHtcbiAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzMiA9IGdldE51bURhdGFDb2Rld29yZHModmVyc2lvbiwgZWNsKSAqIDg7XG4gICAgY29uc3QgdXNlZEJpdHMgPSBnZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgaWYgKHVzZWRCaXRzIDw9IGRhdGFDYXBhY2l0eUJpdHMyKSB7XG4gICAgICBkYXRhVXNlZEJpdHMgPSB1c2VkQml0cztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA+PSBtYXhWZXJzaW9uKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRhIHRvbyBsb25nXCIpO1xuICB9XG4gIGZvciAoY29uc3QgbmV3RWNsIG9mIFtNRURJVU0sIFFVQVJUSUxFLCBISUdIXSkge1xuICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBuZXdFY2wpICogOClcbiAgICAgIGVjbCA9IG5ld0VjbDtcbiAgfVxuICBjb25zdCBiYiA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgYXBwZW5kQml0cyhzZWcubW9kZVswXSwgNCwgYmIpO1xuICAgIGFwcGVuZEJpdHMoc2VnLm51bUNoYXJzLCBudW1DaGFyQ291bnRCaXRzKHNlZy5tb2RlLCB2ZXJzaW9uKSwgYmIpO1xuICAgIGZvciAoY29uc3QgYiBvZiBzZWcuZ2V0RGF0YSgpKVxuICAgICAgYmIucHVzaChiKTtcbiAgfVxuICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzID0gZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgYXBwZW5kQml0cygwLCBNYXRoLm1pbig0LCBkYXRhQ2FwYWNpdHlCaXRzIC0gYmIubGVuZ3RoKSwgYmIpO1xuICBhcHBlbmRCaXRzKDAsICg4IC0gYmIubGVuZ3RoICUgOCkgJSA4LCBiYik7XG4gIGZvciAobGV0IHBhZEJ5dGUgPSAyMzY7IGJiLmxlbmd0aCA8IGRhdGFDYXBhY2l0eUJpdHM7IHBhZEJ5dGUgXj0gMjM2IF4gMTcpXG4gICAgYXBwZW5kQml0cyhwYWRCeXRlLCA4LCBiYik7XG4gIGNvbnN0IGRhdGFDb2Rld29yZHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBNYXRoLmNlaWwoYmIubGVuZ3RoIC8gOCkgfSwgKCkgPT4gMCk7XG4gIGJiLmZvckVhY2goKGIsIGkpID0+IGRhdGFDb2Rld29yZHNbaSA+Pj4gM10gfD0gYiA8PCA3IC0gKGkgJiA3KSk7XG4gIHJldHVybiBuZXcgUXJDb2RlKHZlcnNpb24sIGVjbCwgZGF0YUNvZGV3b3JkcywgbWFzayk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBlY2MgPSBcIkxcIixcbiAgICBib29zdEVjYyA9IGZhbHNlLFxuICAgIG1pblZlcnNpb24gPSAxLFxuICAgIG1heFZlcnNpb24gPSA0MCxcbiAgICBtYXNrUGF0dGVybiA9IC0xLFxuICAgIGJvcmRlciA9IDFcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNlZ21lbnQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG1ha2VTZWdtZW50cyhkYXRhKSA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBbbWFrZUJ5dGVzKGRhdGEpXSA6IHZvaWQgMDtcbiAgaWYgKCFzZWdtZW50KVxuICAgIHRocm93IG5ldyBFcnJvcihgdXFyIG9ubHkgc3VwcG9ydHMgZW5jb2Rpbmcgc3RyaW5nIGFuZCBiaW5hcnkgZGF0YSwgYnV0IGdvdDogJHt0eXBlb2YgZGF0YX1gKTtcbiAgY29uc3QgcXIgPSBlbmNvZGVTZWdtZW50cyhcbiAgICBzZWdtZW50LFxuICAgIEVjY01hcFtlY2NdLFxuICAgIG1pblZlcnNpb24sXG4gICAgbWF4VmVyc2lvbixcbiAgICBtYXNrUGF0dGVybixcbiAgICBib29zdEVjY1xuICApO1xuICBjb25zdCByZXN1bHQgPSBhZGRCb3JkZXIoe1xuICAgIHZlcnNpb246IHFyLnZlcnNpb24sXG4gICAgbWFza1BhdHRlcm46IHFyLm1hc2ssXG4gICAgc2l6ZTogcXIuc2l6ZSxcbiAgICBkYXRhOiBxci5tb2R1bGVzLFxuICAgIHR5cGVzOiBxci50eXBlc1xuICB9LCBib3JkZXIpO1xuICBpZiAob3B0aW9ucz8uaW52ZXJ0KVxuICAgIHJlc3VsdC5kYXRhID0gcmVzdWx0LmRhdGEubWFwKChyb3cpID0+IHJvdy5tYXAoKG1vZCkgPT4gIW1vZCkpO1xuICBvcHRpb25zPy5vbkVuY29kZWQ/LihyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWRkQm9yZGVyKGlucHV0LCBib3JkZXIgPSAxKSB7XG4gIGlmICghYm9yZGVyKVxuICAgIHJldHVybiBpbnB1dDtcbiAgY29uc3QgeyBzaXplIH0gPSBpbnB1dDtcbiAgY29uc3QgbmV3U2l6ZSA9IHNpemUgKyBib3JkZXIgKiAyO1xuICBpbnB1dC5zaXplID0gbmV3U2l6ZTtcbiAgaW5wdXQuZGF0YS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvcmRlcjsgaSsrKSB7XG4gICAgICByb3cudW5zaGlmdChmYWxzZSk7XG4gICAgICByb3cucHVzaChmYWxzZSk7XG4gICAgfVxuICB9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3JkZXI7IGkrKykge1xuICAgIGlucHV0LmRhdGEudW5zaGlmdChBcnJheS5mcm9tKHsgbGVuZ3RoOiBuZXdTaXplIH0sIChfKSA9PiBmYWxzZSkpO1xuICAgIGlucHV0LmRhdGEucHVzaChBcnJheS5mcm9tKHsgbGVuZ3RoOiBuZXdTaXplIH0sIChfKSA9PiBmYWxzZSkpO1xuICB9XG4gIGNvbnN0IGIgPSBRckNvZGVEYXRhVHlwZS5Cb3JkZXI7XG4gIGlucHV0LnR5cGVzLmZvckVhY2goKHJvdykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9yZGVyOyBpKyspIHtcbiAgICAgIHJvdy51bnNoaWZ0KGIpO1xuICAgICAgcm93LnB1c2goYik7XG4gICAgfVxuICB9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3JkZXI7IGkrKykge1xuICAgIGlucHV0LnR5cGVzLnVuc2hpZnQoQXJyYXkuZnJvbSh7IGxlbmd0aDogbmV3U2l6ZSB9LCAoXykgPT4gYikpO1xuICAgIGlucHV0LnR5cGVzLnB1c2goQXJyYXkuZnJvbSh7IGxlbmd0aDogbmV3U2l6ZSB9LCAoXykgPT4gYikpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cbmZ1bmN0aW9uIGdldERhdGFBdChkYXRhLCB4LCB5LCBkZWZhdWx0cyA9IGZhbHNlKSB7XG4gIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IGRhdGEubGVuZ3RoIHx8IHkgPj0gZGF0YS5sZW5ndGgpXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICByZXR1cm4gZGF0YVt5XVt4XTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVW5pY29kZShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdoaXRlQ2hhciA9IFwiXFx1MjU4OFwiLFxuICAgIGJsYWNrQ2hhciA9IFwiXFx1MjU5MVwiXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXN1bHQgPSBlbmNvZGUoZGF0YSwgb3B0aW9ucyk7XG4gIHJldHVybiByZXN1bHQuZGF0YS5tYXAoKHJvdykgPT4ge1xuICAgIHJldHVybiByb3cubWFwKChtb2QpID0+IG1vZCA/IGJsYWNrQ2hhciA6IHdoaXRlQ2hhcikuam9pbihcIlwiKTtcbiAgfSkuam9pbihcIlxcblwiKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckFOU0koZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiByZW5kZXJVbmljb2RlKGRhdGEsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGJsYWNrQ2hhcjogXCJcXHgxQls0MG1cXHUzMDAwXFx4MUJbMG1cIixcbiAgICB3aGl0ZUNoYXI6IFwiXFx4MUJbNDdtXFx1MzAwMFxceDFCWzBtXCJcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJVbmljb2RlQ29tcGFjdChkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcGxhdHRlID0ge1xuICAgIFdISVRFX0FMTDogXCJcXHUyNTg4XCIsXG4gICAgV0hJVEVfQkxBQ0s6IFwiXFx1MjU4MFwiLFxuICAgIEJMQUNLX1dISVRFOiBcIlxcdTI1ODRcIixcbiAgICBCTEFDS19BTEw6IFwiIFwiXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IGVuY29kZShkYXRhLCBvcHRpb25zKTtcbiAgY29uc3QgV0hJVEUgPSBmYWxzZTtcbiAgY29uc3QgQkxBQ0sgPSB0cnVlO1xuICBjb25zdCBhdCA9ICh4LCB5KSA9PiBnZXREYXRhQXQocmVzdWx0LmRhdGEsIHgsIHksIHRydWUpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBsZXQgbGluZSA9IFwiXCI7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJlc3VsdC5zaXplOyByb3cgKz0gMikge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJlc3VsdC5zaXplOyBjb2wrKykge1xuICAgICAgaWYgKGF0KGNvbCwgcm93KSA9PT0gV0hJVEUgJiYgYXQoY29sLCByb3cgKyAxKSA9PT0gV0hJVEUpXG4gICAgICAgIGxpbmUgKz0gcGxhdHRlLldISVRFX0FMTDtcbiAgICAgIGVsc2UgaWYgKGF0KGNvbCwgcm93KSA9PT0gV0hJVEUgJiYgYXQoY29sLCByb3cgKyAxKSA9PT0gQkxBQ0spXG4gICAgICAgIGxpbmUgKz0gcGxhdHRlLldISVRFX0JMQUNLO1xuICAgICAgZWxzZSBpZiAoYXQoY29sLCByb3cpID09PSBCTEFDSyAmJiBhdChjb2wsIHJvdyArIDEpID09PSBXSElURSlcbiAgICAgICAgbGluZSArPSBwbGF0dGUuQkxBQ0tfV0hJVEU7XG4gICAgICBlbHNlXG4gICAgICAgIGxpbmUgKz0gcGxhdHRlLkJMQUNLX0FMTDtcbiAgICB9XG4gICAgbGluZXMucHVzaChsaW5lKTtcbiAgICBsaW5lID0gXCJcIjtcbiAgfVxuICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU1ZHKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSBlbmNvZGUoZGF0YSwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICBwaXhlbFNpemUgPSAxMCxcbiAgICB3aGl0ZUNvbG9yID0gXCJ3aGl0ZVwiLFxuICAgIGJsYWNrQ29sb3IgPSBcImJsYWNrXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGhlaWdodCA9IHJlc3VsdC5zaXplICogcGl4ZWxTaXplO1xuICBjb25zdCB3aWR0aCA9IHJlc3VsdC5zaXplICogcGl4ZWxTaXplO1xuICBsZXQgc3ZnID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgJHt3aWR0aH0gJHtoZWlnaHR9XCI+YDtcbiAgY29uc3QgcGF0aGVzID0gW107XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJlc3VsdC5zaXplOyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHJlc3VsdC5zaXplOyBjb2wrKykge1xuICAgICAgY29uc3QgeCA9IGNvbCAqIHBpeGVsU2l6ZTtcbiAgICAgIGNvbnN0IHkgPSByb3cgKiBwaXhlbFNpemU7XG4gICAgICBpZiAocmVzdWx0LmRhdGFbcm93XVtjb2xdKVxuICAgICAgICBwYXRoZXMucHVzaChgTSR7eH0sJHt5fWgke3BpeGVsU2l6ZX12JHtwaXhlbFNpemV9aC0ke3BpeGVsU2l6ZX16YCk7XG4gICAgfVxuICB9XG4gIHN2ZyArPSBgPHJlY3QgZmlsbD1cIiR7d2hpdGVDb2xvcn1cIiB3aWR0aD1cIiR7d2lkdGh9XCIgaGVpZ2h0PVwiJHtoZWlnaHR9XCIvPmA7XG4gIHN2ZyArPSBgPHBhdGggZmlsbD1cIiR7YmxhY2tDb2xvcn1cIiBkPVwiJHtwYXRoZXMuam9pbihcIlwiKX1cIi8+YDtcbiAgc3ZnICs9IFwiPC9zdmc+XCI7XG4gIHJldHVybiBzdmc7XG59XG5cbmV4cG9ydCB7IFFyQ29kZURhdGFUeXBlLCBlbmNvZGUsIHJlbmRlckFOU0ksIHJlbmRlclNWRywgcmVuZGVyVW5pY29kZSwgcmVuZGVyVW5pY29kZUNvbXBhY3QgfTtcbiJdLCJuYW1lcyI6WyJRckNvZGVEYXRhVHlwZSIsIlFyQ29kZURhdGFUeXBlMiIsIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkIiwiTE9XIiwiTUVESVVNIiwiUVVBUlRJTEUiLCJISUdIIiwiRWNjTWFwIiwiTCIsIk0iLCJRIiwiSCIsIk5VTUVSSUNfUkVHRVgiLCJBTFBIQU5VTUVSSUNfUkVHRVgiLCJBTFBIQU5VTUVSSUNfQ0hBUlNFVCIsIk1JTl9WRVJTSU9OIiwiTUFYX1ZFUlNJT04iLCJQRU5BTFRZX04xIiwiUEVOQUxUWV9OMiIsIlBFTkFMVFlfTjMiLCJQRU5BTFRZX040IiwiRUNDX0NPREVXT1JEU19QRVJfQkxPQ0siLCJOVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1MiLCJRckNvZGUiLCJjb25zdHJ1Y3RvciIsInZlcnNpb24iLCJlY2MiLCJkYXRhQ29kZXdvcmRzIiwibXNrIiwiUmFuZ2VFcnJvciIsInNpemUiLCJyb3ciLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJpIiwibW9kdWxlcyIsInB1c2giLCJzbGljZSIsInR5cGVzIiwibWFwIiwiZHJhd0Z1bmN0aW9uUGF0dGVybnMiLCJhbGxDb2Rld29yZHMiLCJhZGRFY2NBbmRJbnRlcmxlYXZlIiwiZHJhd0NvZGV3b3JkcyIsIm1pblBlbmFsdHkiLCJhcHBseU1hc2siLCJkcmF3Rm9ybWF0Qml0cyIsInBlbmFsdHkiLCJnZXRQZW5hbHR5U2NvcmUiLCJtYXNrIiwiZ2V0TW9kdWxlIiwieCIsInkiLCJzZXRGdW5jdGlvbk1vZHVsZSIsIlRpbWluZyIsImRyYXdGaW5kZXJQYXR0ZXJuIiwiYWxpZ25QYXRQb3MiLCJnZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zIiwibnVtQWxpZ24iLCJqIiwiZHJhd0FsaWdubWVudFBhdHRlcm4iLCJkcmF3VmVyc2lvbiIsImRhdGEiLCJyZW0iLCJiaXRzIiwiZ2V0Qml0IiwiY29sb3IiLCJhIiwiYiIsIk1hdGgiLCJmbG9vciIsImR5IiwiZHgiLCJkaXN0IiwibWF4IiwiYWJzIiwieHgiLCJ5eSIsIlBvc2l0aW9uIiwiQWxpZ25tZW50IiwiaXNEYXJrIiwidHlwZSIsIkZ1bmN0aW9uIiwidmVyIiwiZWNsIiwiZ2V0TnVtRGF0YUNvZGV3b3JkcyIsIm51bUJsb2NrcyIsImJsb2NrRWNjTGVuIiwicmF3Q29kZXdvcmRzIiwiZ2V0TnVtUmF3RGF0YU1vZHVsZXMiLCJudW1TaG9ydEJsb2NrcyIsInNob3J0QmxvY2tMZW4iLCJibG9ja3MiLCJyc0RpdiIsInJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IiLCJrIiwiZGF0IiwicmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyIiwiY29uY2F0IiwicmVzdWx0IiwiZm9yRWFjaCIsImJsb2NrIiwicmlnaHQiLCJ2ZXJ0IiwidXB3YXJkIiwiaW52ZXJ0IiwiRXJyb3IiLCJydW5Db2xvciIsInJ1blgiLCJydW5IaXN0b3J5IiwiZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkiLCJmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyIsImZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudCIsInJ1blkiLCJkYXJrIiwicmVkdWNlIiwic3VtIiwidG90YWwiLCJjZWlsIiwic3RlcCIsInBvcyIsInNwbGljZSIsIm4iLCJjb3JlIiwiY3VycmVudFJ1bkNvbG9yIiwiY3VycmVudFJ1bkxlbmd0aCIsInBvcCIsInVuc2hpZnQiLCJhcHBlbmRCaXRzIiwidmFsIiwibGVuIiwiYmIiLCJRclNlZ21lbnQiLCJtb2RlIiwibnVtQ2hhcnMiLCJiaXREYXRhIiwiZ2V0RGF0YSIsIk1PREVfTlVNRVJJQyIsIk1PREVfQUxQSEFOVU1FUklDIiwiTU9ERV9CWVRFIiwibnVtQ2hhckNvdW50Qml0cyIsIm1ha2VCeXRlcyIsIm1ha2VOdW1lcmljIiwiZGlnaXRzIiwiaXNOdW1lcmljIiwibWluIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJtYWtlQWxwaGFudW1lcmljIiwidGV4dCIsImlzQWxwaGFudW1lcmljIiwidGVtcCIsImluZGV4T2YiLCJjaGFyQXQiLCJtYWtlU2VnbWVudHMiLCJ0b1V0ZjhCeXRlQXJyYXkiLCJ0ZXN0IiwiZ2V0VG90YWxCaXRzIiwic2VncyIsInNlZyIsImNjYml0cyIsIlBPU0lUSVZFX0lORklOSVRZIiwic3RyIiwiZW5jb2RlVVJJIiwiY2hhckNvZGVBdCIsImRlZ3JlZSIsInJvb3QiLCJyZWVkU29sb21vbk11bHRpcGx5IiwiZGl2aXNvciIsIl8iLCJmYWN0b3IiLCJzaGlmdCIsImNvZWYiLCJ6IiwiZW5jb2RlU2VnbWVudHMiLCJtaW5WZXJzaW9uIiwibWF4VmVyc2lvbiIsImJvb3N0RWNsIiwiZGF0YVVzZWRCaXRzIiwiZGF0YUNhcGFjaXR5Qml0czIiLCJ1c2VkQml0cyIsIm5ld0VjbCIsImRhdGFDYXBhY2l0eUJpdHMiLCJwYWRCeXRlIiwiZW5jb2RlIiwib3B0aW9ucyIsImJvb3N0RWNjIiwibWFza1BhdHRlcm4iLCJib3JkZXIiLCJzZWdtZW50IiwiaXNBcnJheSIsInFyIiwiYWRkQm9yZGVyIiwibW9kIiwib25FbmNvZGVkIiwiaW5wdXQiLCJuZXdTaXplIiwiQm9yZGVyIiwiZ2V0RGF0YUF0IiwiZGVmYXVsdHMiLCJyZW5kZXJVbmljb2RlIiwid2hpdGVDaGFyIiwiYmxhY2tDaGFyIiwiam9pbiIsInJlbmRlckFOU0kiLCJyZW5kZXJVbmljb2RlQ29tcGFjdCIsInBsYXR0ZSIsIldISVRFX0FMTCIsIldISVRFX0JMQUNLIiwiQkxBQ0tfV0hJVEUiLCJCTEFDS19BTEwiLCJXSElURSIsIkJMQUNLIiwiYXQiLCJsaW5lcyIsImxpbmUiLCJjb2wiLCJyZW5kZXJTVkciLCJwaXhlbFNpemUiLCJ3aGl0ZUNvbG9yIiwiYmxhY2tDb2xvciIsImhlaWdodCIsIndpZHRoIiwic3ZnIiwicGF0aGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uqr/dist/index.mjs\n");

/***/ })

};
;