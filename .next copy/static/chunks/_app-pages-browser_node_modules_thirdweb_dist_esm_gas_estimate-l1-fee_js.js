"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_gas_estimate-l1-fee_js"],{

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: function(key) {\n            for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                msgs[_key - 1] = arguments[_key];\n            }\n            return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs));\n        },\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQzFCO0FBQ3FCO0FBQ1A7QUFDeEQsMENBQTBDLEdBQ25DLFNBQVNJLFFBQVFDLElBQUk7SUFDeEIsT0FBTztRQUNIQTtRQUNBTCxNQUFNLFNBQUNNOzZDQUFRQztnQkFBQUE7O21CQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNOztRQUN2REwsV0FBV0EsOERBQUFBO0lBQ2Y7QUFDSjtBQUNPLFNBQVNNLFlBQVlDLFFBQVEsRUFBRUMsT0FBTztJQUN6QyxNQUFNQyxTQUFTLENBQUNOLE9BQVNGLHFFQUFXQSxDQUFDO1lBQUUsR0FBR00sUUFBUTtZQUFFLEdBQUdMLFFBQVFDLEtBQUs7UUFBQztJQUNyRSxPQUFPO1FBQUUsR0FBR00sT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3hDLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzP2YyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: function() { return /* binding */ pippenger; },\n/* harmony export */   precomputeMSMUnsafe: function() { return /* binding */ precomputeMSMUnsafe; },\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n        windows,\n        windowSize\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n) {\n            let acc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : c.ZERO;\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                if (n === _0n) break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0) continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0) curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length) throw new Error(\"arrays of points and scalars must have equal length\");\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < scalars.length; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Qsb0VBQW9FLEdBQ2Q7QUFDRjtBQUNwRCxNQUFNSSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsU0FBU0UsZ0JBQWdCQyxTQUFTLEVBQUVDLElBQUk7SUFDcEMsTUFBTUMsTUFBTUQsS0FBS0UsTUFBTTtJQUN2QixPQUFPSCxZQUFZRSxNQUFNRDtBQUM3QjtBQUNBLFNBQVNHLFVBQVVDLENBQUMsRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0gsTUFBTUEsS0FBSyxLQUFLQSxJQUFJQyxNQUMxQyxNQUFNLElBQUlHLE1BQU0sdUNBQXVDSCxPQUFPLGNBQWNEO0FBQ3BGO0FBQ0EsU0FBU0ssVUFBVUwsQ0FBQyxFQUFFQyxJQUFJO0lBQ3RCRixVQUFVQyxHQUFHQztJQUNiLE1BQU1LLFVBQVVDLEtBQUtDLElBQUksQ0FBQ1AsT0FBT0QsS0FBSyxHQUFHLGNBQWM7SUFDdkQsTUFBTVMsYUFBYSxLQUFNVCxDQUFBQSxJQUFJLElBQUksMEJBQTBCO0lBQzNELE9BQU87UUFBRU07UUFBU0c7SUFBVztBQUNqQztBQUNBLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxDQUFDO0lBQ2hDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSCxTQUNmLE1BQU0sSUFBSVAsTUFBTTtJQUNwQk8sT0FBT0ksT0FBTyxDQUFDLENBQUNDLEdBQUdDO1FBQ2YsSUFBSSxDQUFFRCxDQUFBQSxhQUFhSixDQUFBQSxHQUNmLE1BQU0sSUFBSVIsTUFBTSw0QkFBNEJhO0lBQ3BEO0FBQ0o7QUFDQSxTQUFTQyxtQkFBbUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ0ssVUFDZixNQUFNLElBQUlmLE1B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RyxvREFBT0EsQ0FBQ3NHLE1BQU14RCxDQUFDLEVBQUV3RCxNQUFNSyxVQUFVLENBQUM7UUFDckMsR0FBR0wsS0FBSztRQUNSLEdBQUc7WUFBRXpFLEdBQUd5RSxNQUFNQyxFQUFFLENBQUNRLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzYxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNZXRob2RzIGZvciBlbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBieSBzY2FsYXJzLlxuICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYml0TGVuLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgYml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXNcbmNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcG9pbnRXaW5kb3dTaXplcyA9IG5ldyBXZWFrTWFwKCk7IC8vIFRoaXMgYWxsb3dzIHVzZSBtYWtlIHBvaW50cyBpbW11dGFibGUgKG5vdGhpbmcgY2hhbmdlcyBpbnNpZGUpXG5mdW5jdGlvbiBnZXRXKFApIHtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbi8qKlxuICogRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuICogU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4gKiBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbiAqIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuICogLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuICogLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuICogLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4gKiAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4gKiAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuICpcbiAqIEB0b2RvIFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy5cbiAqIFRoaXMgd291bGQgYWxsb3cgd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICBoYXNQcmVjb21wdXRlcyhlbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IGMuWkVSTykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBnbyBvdmVyIGVtcHR5IHNjYWxhclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IHByZWNvbXB1dGVzW29mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDFdOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGJ5IHJlLXVzaW5nIGFjYywgd2UgY2FuIHNhdmUgYSBsb3Qgb2YgYWRkaXRpb25zIGluIGNhc2Ugb2YgTVNNXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWRVbnNhZmUoUCwgbiwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB3aXRoIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlwcGVuZ2VyKGMsIGZpZWxkTiwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggIT09IHNjYWxhcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBvaW50cy5sZW5ndGgpKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gd2JpdHMgPiAxMiA/IHdiaXRzIC0gMyA6IHdiaXRzID4gNCA/IHdiaXRzIC0gMiA6IHdiaXRzID8gMiA6IDE7IC8vIGluIGJpdHNcbiAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTUFTSyArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICBjb25zdCB3Yml0cyA9IE51bWJlcigoc2NhbGFyID4+IEJpZ0ludChpKSkgJiBCaWdJbnQoTUFTSykpO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gQmlnSW50KCgxIDw8IHdpbmRvd1NpemUpIC0gMSk7XG4gICAgY29uc3QgdGFibGVzID0gcG9pbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFjYyA9IHA7IGkgPCB0YWJsZVNpemU7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2goYWNjKTtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gKHNjYWxhcnMpID0+IHtcbiAgICAgICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgICAgIGlmIChzY2FsYXJzLmxlbmd0aCA+IHBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG9mIHNjYWxhcnMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYXJyYXkgb2YgcG9pbnRzJyk7XG4gICAgICAgIGxldCByZXMgPSB6ZXJvO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGRvdWJsZSBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCB6ZXJvLlxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gemVybylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmRvdWJsZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChjaHVua3MgKiB3aW5kb3dTaXplIC0gKGkgKyAxKSAqIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigobiA+PiBzaGlmdEJ5KSAmIE1BU0spO1xuICAgICAgICAgICAgICAgIGlmICghY3VycilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgemVybyBzY2FsYXJzIGNodW5rc1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQodGFibGVzW2pdW2N1cnIgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJiaXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwiYml0cyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNhbGNXT3B0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ2YWxpZGF0ZU1TTVBvaW50cyIsInBvaW50cyIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicCIsImkiLCJ2YWxpZGF0ZU1TTVNjYWxhcnMiLCJzY2FsYXJzIiwiZmllbGQiLCJzIiwiaXNWYWxpZCIsInBvaW50UHJlY29tcHV0ZXMiLCJXZWFrTWFwIiwicG9pbnRXaW5kb3dTaXplcyIsImdldFciLCJQIiwiZ2V0Iiwid05BRiIsImhhc1ByZWNvbXB1dGVzIiwiZWxtIiwidW5zYWZlTGFkZGVyIiwibiIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGVW5zYWZlIiwiYWNjIiwiY3VyciIsImdldFByZWNvbXB1dGVzIiwidHJhbnNmb3JtIiwiY29tcCIsInNldCIsIndOQUZDYWNoZWQiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwicHJldiIsInNldFdpbmRvd1NpemUiLCJkZWxldGUiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJsZW5ndGgiLCJ6ZXJvIiwiTUFTSyIsImJ1Y2tldHMiLCJmaWxsIiwibGFzdEJpdHMiLCJmbG9vciIsIkJJVFMiLCJzdW0iLCJqIiwic2NhbGFyIiwicmVzSSIsInN1bUkiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiRnAiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsIk9iamVjdCIsImZyZWV6ZSIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"mapToCurve: expected array of bigints\");\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0YsNkZBQTZGO0FBQzdGLE1BQU1NLFFBQVFKLHNEQUFlQTtBQUM3Qiw0Q0FBNEM7QUFDNUMsU0FBU0ssTUFBTUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3hCQyxLQUFLRjtJQUNMRSxLQUFLRDtJQUNMLElBQUlELFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlDLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJIO0lBQzlDLE1BQU1JLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1IsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUyxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU1gsS0FBS1ksSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlYLE1BQU07QUFDeEI7QUFDQTs7O0NBR0MsR0FDTSxTQUFTYyxtQkFBbUJDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxVQUFVLEVBQUVDLENBQUM7SUFDdEQ1QixpREFBTUEsQ0FBQ3lCO0lBQ1B6QixpREFBTUEsQ0FBQzBCO0lBQ1BqQixLQUFLa0I7SUFDTCx1REFBdUQ7SUFDdkQsSUFBSUQsSUFBSWxCLE1BQU0sR0FBRyxLQUNia0IsTUFBTUUsRUFBRTFCLHNEQUFXQSxDQUFDQyxzREFBV0EsQ0FBQyxzQkFBc0J1QjtJQUMxRCxNQUFNLEVBQUVHLFdBQVdDLFVBQVUsRUFBRUMsVUFBVUMsVUFBVSxFQUFFLEdBQUdKO0lBQ3hELE1BQU1LLE1BQU1DLEtBQUtDLElBQUksQ0FBQ1IsYUFBYUc7SUFDbkMsSUFBSUgsYUFBYSxTQUFTTSxNQUFNLEtBQzVCLE1BQU0sSUFBSXZCLE1BQU07SUFDcEIsTUFBTTBCLFlBQVlsQyxzREFBV0EsQ0FBQ3dCLEtBQUtwQixNQUFNb0IsSUFBSWxCLE1BQU0sRUFBRTtJQUNyRCxNQUFNNkIsUUFBUS9CLE1BQU0sR0FBRzBCO0lBQ3ZCLE1BQU1NLFlBQVloQyxNQUFNcUIsWUFBWSxJQUFJLG1CQUFtQjtJQUMzRCxNQUFNUixJQUFJLElBQUlQLE1BQU1xQjtJQUNwQixNQUFNTSxNQUFNWCxFQUFFMUIsc0RBQVdBLENBQUNtQyxPQUFPWixLQUFLYSxXQUFXaEMsTUFBTSxHQUFHLElBQUk4QjtJQUM5RGpCLENBQUMsQ0FBQyxFQUFFLEdBQUdTLEVBQUUxQixzREFBV0EsQ0FBQ3FDLEtBQUtqQyxNQUFNLEdBQUcsSUFBSThCO0lBQ3ZDLElBQUssSUFBSXJCLElBQUksR0FBR0EsS0FBS2tCLEtBQUtsQixJQUFLO1FBQzNCLE1BQU15QixPQUFPO1lBQUN2QixPQUFPc0IsS0FBS3BCLENBQUMsQ0FBQ0osSUFBSSxFQUFFO1lBQUdULE1BQU1TLElBQUksR0FBRztZQUFJcUI7U0FBVTtRQUNoRWpCLENBQUMsQ0FBQ0osRUFBRSxHQUFHYSxFQUFFMUIsc0RBQVdBLElBQUlzQztJQUM1QjtJQUNBLE1BQU1DLHNCQUFzQnZDLHNEQUFXQSxJQUFJaUI7SUFDM0MsT0FBT3NCLG9CQUFvQkMsS0FBSyxDQUFDLEdBQUdmO0FBQ3hDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU2dCLG1CQUFtQmxCLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxVQUFVLEVBQUVpQixDQUFDLEVBQUVoQixDQUFDO0lBQ3pENUIsaURBQU1BLENBQUN5QjtJQUNQekIsaURBQU1BLENBQUMwQjtJQUNQakIsS0FBS2tCO0lBQ0wsdURBQXVEO0lBQ3ZELG9GQUFvRjtJQUNwRixJQUFJRCxJQUFJbEIsTUFBTSxHQUFHLEtBQUs7UUFDbEIsTUFBTXFDLFFBQVFYLEtBQUtDLElBQUksQ0FBQyxJQUFLUyxJQUFLO1FBQ2xDbEIsTUFBTUUsRUFBRWtCLE1BQU0sQ0FBQztZQUFFRDtRQUFNLEdBQUdFLE1BQU0sQ0FBQzVDLHNEQUFXQSxDQUFDLHNCQUFzQjRDLE1BQU0sQ0FBQ3JCLEtBQUtzQixNQUFNO0lBQ3pGO0lBQ0EsSUFBSXJCLGFBQWEsU0FBU0QsSUFBSWxCLE1BQU0sR0FBRyxLQUNuQyxNQUFNLElBQUlFLE1BQU07SUFDcEIsT0FBUWtCLEVBQUVrQixNQUFNLENBQUM7UUFBRUQsT0FBT2xCO0lBQVcsR0FDaENvQixNQUFNLENBQUN0QixLQUNQc0IsTUFBTSxDQUFDekMsTUFBTXFCLFlBQVksR0FDMUIsMkNBQTJDO0tBQzFDb0IsTUFBTSxDQUFDckIsS0FDUHFCLE1BQU0sQ0FBQ3pDLE1BQU1vQixJQUFJbEIsTUFBTSxFQUFFLElBQ3pCd0MsTUFBTTtBQUNmO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNDLGNBQWN4QixHQUFHLEVBQUV5QixLQUFLLEVBQUVDLE9BQU87SUFDN0MvQyx5REFBY0EsQ0FBQytDLFNBQVM7UUFDcEJ6QixLQUFLO1FBQ0wwQixHQUFHO1FBQ0hDLEdBQUc7UUFDSFQsR0FBRztRQUNIVSxNQUFNO0lBQ1Y7SUFDQSxNQUFNLEVBQUVGLENBQUMsRUFBRVIsQ0FBQyxFQUFFUyxDQUFDLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFN0IsS0FBSzhCLElBQUksRUFBRSxHQUFHTDtJQUM3Q25ELGlEQUFNQSxDQUFDeUI7SUFDUGhCLEtBQUt5QztJQUNMLE1BQU14QixNQUFNLE9BQU84QixTQUFTLFdBQVdyRCxzREFBV0EsQ0FBQ3FELFFBQVFBO0lBQzNELE1BQU1DLFFBQVFMLEVBQUVNLFFBQVEsQ0FBQyxHQUFHbEQsTUFBTTtJQUNsQyxNQUFNbUQsSUFBSXpCLEtBQUtDLElBQUksQ0FBQyxDQUFDc0IsUUFBUWIsQ0FBQUEsSUFBSyxJQUFJLHVDQUF1QztJQUM3RSxNQUFNZ0IsZUFBZVYsUUFBUUcsSUFBSU07SUFDakMsSUFBSUUsS0FBSyxzQkFBc0I7SUFDL0IsSUFBSU4sV0FBVyxPQUFPO1FBQ2xCTSxNQUFNckMsbUJBQW1CQyxLQUFLQyxLQUFLa0MsY0FBY047SUFDckQsT0FDSyxJQUFJQyxXQUFXLE9BQU87UUFDdkJNLE1BQU1sQixtQkFBbUJsQixLQUFLQyxLQUFLa0MsY0FBY2hCLEdBQUdVO0lBQ3hELE9BQ0ssSUFBSUMsV0FBVyxrQkFBa0I7UUFDbEMsMEJBQTBCO1FBQzFCTSxNQUFNcEM7SUFDVixPQUNLO1FBQ0QsTUFBTSxJQUFJZixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW9ELElBQUksSUFBSWxELE1BQU1zQztJQUNwQixJQUFLLElBQUluQyxJQUFJLEdBQUdBLElBQUltQyxPQUFPbkMsSUFBSztRQUM1QixNQUFNZ0QsSUFBSSxJQUFJbkQsTUFBTXlDO1FBQ3BCLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJWCxHQUFHVyxJQUFLO1lBQ3hCLE1BQU1DLGFBQWFOLElBQUtLLENBQUFBLElBQUlqRCxJQUFJc0MsQ0FBQUE7WUFDaEMsTUFBTWEsS0FBS0wsSUFBSU0sUUFBUSxDQUFDRixZQUFZQSxhQUFhTjtZQUNqREksQ0FBQyxDQUFDQyxFQUFFLEdBQUdqRSxnREFBR0EsQ0FBQ00sTUFBTTZELEtBQUtkO1FBQzFCO1FBQ0FVLENBQUMsQ0FBQy9DLEVBQUUsR0FBR2dEO0lBQ1g7SUFDQSxPQUFPRDtBQUNYO0FBQ08sU0FBU00sV0FBV0MsS0FBSyxFQUFFQyxHQUFHO0lBQ2pDLDZCQUE2QjtJQUM3QixNQUFNQyxRQUFRRCxJQUFJQSxHQUFHLENBQUMsQ0FBQ3ZELElBQU1ILE1BQU1DLElBQUksQ0FBQ0UsR0FBR3lELE9BQU87SUFDbEQsT0FBTyxDQUFDQyxHQUFHQztRQUNQLE1BQU0sQ0FBQ0MsTUFBTUMsTUFBTUMsTUFBTUMsS0FBSyxHQUFHUCxNQUFNRCxHQUFHLENBQUMsQ0FBQ1MsTUFBUUEsSUFBSUMsTUFBTSxDQUFDLENBQUNDLEtBQUtsRSxJQUFNc0QsTUFBTWEsR0FBRyxDQUFDYixNQUFNYyxHQUFHLENBQUNGLEtBQUtSLElBQUkxRDtRQUN4RzBELElBQUlKLE1BQU1lLEdBQUcsQ0FBQ1QsTUFBTUMsT0FBTyxjQUFjO1FBQ3pDRixJQUFJTCxNQUFNYyxHQUFHLENBQUNULEdBQUdMLE1BQU1lLEdBQUcsQ0FBQ1AsTUFBTUMsUUFBUSxvQkFBb0I7UUFDN0QsT0FBTztZQUFFTCxHQUFHQTtZQUFHQyxHQUFHQTtRQUFFO0lBQ3hCO0FBQ0o7QUFDQSx5RUFBeUUsR0FDbEUsU0FBU1csYUFBYUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEdBQUc7SUFDL0MsSUFBSSxPQUFPRCxlQUFlLFlBQ3RCLE1BQU0sSUFBSTdFLE1BQU07SUFDcEIsT0FBTztRQUNILHlDQUF5QztRQUN6QyxzRUFBc0U7UUFDdEUrRSxhQUFZaEUsR0FBRyxFQUFFMEIsT0FBTztZQUNwQixNQUFNVyxJQUFJYixjQUFjeEIsS0FBSyxHQUFHO2dCQUFFLEdBQUcrRCxHQUFHO2dCQUFFOUQsS0FBSzhELElBQUk5RCxHQUFHO2dCQUFFLEdBQUd5QixPQUFPO1lBQUM7WUFDbkUsTUFBTXVDLEtBQUtKLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFO1lBQzNDLE1BQU04QixLQUFLTixNQUFNSyxVQUFVLENBQUNKLFdBQVd6QixDQUFDLENBQUMsRUFBRTtZQUMzQyxNQUFNK0IsSUFBSUgsR0FBR1IsR0FBRyxDQUFDVSxJQUFJRSxhQUFhO1lBQ2xDRCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7UUFDQSx5Q0FBeUM7UUFDekMsd0VBQXdFO1FBQ3hFRyxlQUFjdkUsR0FBRyxFQUFFMEIsT0FBTztZQUN0QixNQUFNVyxJQUFJYixjQUFjeEIsS0FBSyxHQUFHO2dCQUFFLEdBQUcrRCxHQUFHO2dCQUFFOUQsS0FBSzhELElBQUlTLFNBQVM7Z0JBQUUsR0FBRzlDLE9BQU87WUFBQztZQUN6RSxNQUFNMEMsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUUsR0FBR2dDLGFBQWE7WUFDMURELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtRQUNBLDBDQUEwQztRQUMxQ04sWUFBV1csT0FBTztZQUNkLElBQUksQ0FBQ3RGLE1BQU11RixPQUFPLENBQUNELFVBQ2YsTUFBTSxJQUFJeEYsTUFBTTtZQUNwQixLQUFLLE1BQU1LLEtBQUttRixRQUNaLElBQUksT0FBT25GLE1BQU0sVUFDYixNQUFNLElBQUlMLE1BQU07WUFDeEIsTUFBTW1GLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV1csVUFBVUosYUFBYTtZQUM3REQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8yMGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cbiAqIFtSRkMgOTM4MCA1LjMuMV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShzY2FsYXJzKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsImFieXRlcyIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJ2YWxpZGF0ZU9iamVjdCIsIm9zMmlwIiwiaTJvc3AiLCJ2YWx1ZSIsImxlbmd0aCIsImFudW0iLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiaXRlbSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJtc2ciLCJEU1QiLCJsZW5JbkJ5dGVzIiwiSCIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImhhc2hfdG9fZmllbGQiLCJjb3VudCIsIm9wdGlvbnMiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJfRFNUIiwibG9nMnAiLCJ0b1N0cmluZyIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJ1IiwiZSIsImoiLCJlbG1fb2Zmc2V0IiwidHYiLCJzdWJhcnJheSIsImlzb2dlbnlNYXAiLCJmaWVsZCIsIm1hcCIsIkNPRUZGIiwicmV2ZXJzZSIsIngiLCJ5IiwieE51bSIsInhEZW4iLCJ5TnVtIiwieURlbiIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsImRpdiIsImNyZWF0ZUhhc2hlciIsIlBvaW50IiwibWFwVG9DdXJ2ZSIsImRlZiIsImhhc2hUb0N1cnZlIiwidTAiLCJmcm9tQWZmaW5lIiwidTEiLCJQIiwiY2xlYXJDb2ZhY3RvciIsImFzc2VydFZhbGlkaXR5IiwiZW5jb2RlVG9DdXJ2ZSIsImVuY29kZURTVCIsInNjYWxhcnMiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpLegendre: function() { return /* binding */ FpLegendre; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (modulo <= _0n) throw new Error(\"invalid modulus\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++){\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000) throw new Error(\"Cannot find square root: likely non-prime P\");\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. P ‚â° 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n_c = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n_c1 = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\n_c2 = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n_c3 = FpDiv;\n/**\n * Legendre symbol.\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x)=>f.pow(x, legendreConst);\n}\n_c4 = FpLegendre;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x)=>{\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n_c5 = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, redef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\n_c6 = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n_c7 = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n_c8 = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"FpSqrt\");\n$RefreshReg$(_c1, \"FpPow\");\n$RefreshReg$(_c2, \"FpInvertBatch\");\n$RefreshReg$(_c3, \"FpDiv\");\n$RefreshReg$(_c4, \"FpLegendre\");\n$RefreshReg$(_c5, \"FpIsSquare\");\n$RefreshReg$(_c6, \"Field\");\n$RefreshReg$(_c7, \"FpSqrtOdd\");\n$RefreshReg$(_c8, \"FpSqrtEven\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNELG9FQUFvRSxHQUNtRTtBQUN2SSxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU0sYUFBYSxHQUFHRixPQUFPLElBQUlHLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ3RHLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNLGFBQWEsR0FBR0osT0FBTyxJQUFJSyxNQUFNLGFBQWEsR0FBR0wsT0FBTyxJQUFJTSxNQUFNLGFBQWEsR0FBR04sT0FBTztBQUNyRyxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTSxhQUFhLEdBQUdQLE9BQU8sSUFBSVEsT0FBTyxhQUFhLEdBQUdSLE9BQU87QUFDckUsd0JBQXdCO0FBQ2pCLFNBQVNTLElBQUlDLENBQUMsRUFBRUMsQ0FBQztJQUNwQixNQUFNQyxTQUFTRixJQUFJQztJQUNuQixPQUFPQyxVQUFVYixNQUFNYSxTQUFTRCxJQUFJQztBQUN4QztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLElBQUlELFFBQVFoQixLQUNSLE1BQU0sSUFBSWtCLE1BQU07SUFDcEIsSUFBSUQsVUFBVWpCLEtBQ1YsTUFBTSxJQUFJa0IsTUFBTTtJQUNwQixJQUFJRCxXQUFXZixLQUNYLE9BQU9GO0lBQ1gsSUFBSW1CLE1BQU1qQjtJQUNWLE1BQU9jLFFBQVFoQixJQUFLO1FBQ2hCLElBQUlnQixRQUFRZCxLQUNSaUIsTUFBTSxNQUFPSixNQUFPRTtRQUN4QkYsTUFBTSxNQUFPQSxNQUFPRTtRQUNwQkQsVUFBVWQ7SUFDZDtJQUNBLE9BQU9pQjtBQUNYO0FBQ0EsMERBQTBELEdBQ25ELFNBQVNDLEtBQUtD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REFBZUEsQ0FBQ29KO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVdkksSUFBSUssS0FBSzJILGFBQWF4SSxPQUFPQTtJQUM3QyxPQUFPeUcsT0FBTzdHLDBEQUFlQSxDQUFDbUosU0FBU0QsWUFBWW5KLDBEQUFlQSxDQUFDb0osU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/MGNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaW5pdGUgZmllbGRzLlxuICogQSBmaW5pdGUgZmllbGQgb3ZlciAxMSBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpLCBfM24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpLCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDkpLCBfMTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQHRvZG8gdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2R1bHVzJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKykge1xuICAgICAgICAvLyBDcmFzaCBpbnN0ZWFkIG9mIGluZmluaXR5IGxvb3AsIHdlIGNhbm5vdCByZWFzb25hYmxlIGNvdW50IHVudGlsIFAuXG4gICAgICAgIGlmIChaID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IGxpa2VseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIEl0IHdpbGwgdHJ5IHRvIGNoZWNrIGlmIG9wdGltaXphdGlvbnMgYXJlIGFwcGxpY2FibGUgYW5kIGZhbGwgYmFjayB0byA0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLyoqXG4gKiBMZWdlbmRyZSBzeW1ib2wuXG4gKiAqIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyBub24gcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBMZWdlbmRyZShvcmRlcikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAob3JkZXIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKGYsIHgpID0+IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmUgPSBGcExlZ2VuZHJlKGYuT1JERVIpO1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gbGVnZW5kcmUoZiwgeCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBpc0xFLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIEJZVEVTICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJiaXRNYXNrIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl84biIsIl85biIsIl8xNm4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRXJyb3IiLCJyZXMiLCJwb3cyIiwieCIsImludmVydCIsIm51bWJlciIsInkiLCJ1IiwidiIsInEiLCJyIiwibSIsIm4iLCJnY2QiLCJ0b25lbGxpU2hhbmtzIiwiUCIsImxlZ2VuZHJlQyIsIlEiLCJTIiwiWiIsInAxZGl2NCIsInRvbmVsbGlGYXN0IiwiRnAiLCJyb290IiwiZXFsIiwic3FyIiwiUTFkaXYyIiwidG9uZWxsaVNsb3ciLCJuZWciLCJPTkUiLCJnIiwibXVsIiwiWkVSTyIsInQyIiwiZ2UiLCJGcFNxcnQiLCJzcXJ0M21vZDQiLCJjMSIsInNxcnQ1bW9kOCIsIm4yIiwibnYiLCJpIiwic3ViIiwiaXNOZWdhdGl2ZUxFIiwiRklFTERfRklFTERTIiwidmFsaWRhdGVGaWVsZCIsImZpZWxkIiwiaW5pdGlhbCIsIk9SREVSIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJGcFBvdyIsImYiLCJwIiwiZCIsIkZwSW52ZXJ0QmF0Y2giLCJudW1zIiwidG1wIiwiQXJyYXkiLCJsZW5ndGgiLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImlzMCIsImludmVydGVkIiwiaW52IiwicmVkdWNlUmlnaHQiLCJGcERpdiIsImxocyIsInJocyIsIkZwTGVnZW5kcmUiLCJvcmRlciIsImxlZ2VuZHJlQ29uc3QiLCJGcElzU3F1YXJlIiwibGVnZW5kcmUiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiRmllbGQiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   DERErr: function() { return /* binding */ DERErr; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endomorphism, can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"invalid endomorphism, expected beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(len.length / 2 | 128) : \"\";\n            const t = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return b2n(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ‚àã (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            Object.freeze(this);\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"r\", this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"s\", this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute () {\n            let windowSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Point.BASE;\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey) {\n        let isCompressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB) {\n        let isCompressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\"\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"num < 2^\" + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultVerOpts;\n        var _Point_BASE_multiplyAndAddUnsafe;\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = (_Point_BASE_multiplyAndAddUnsafe = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point_BASE_multiplyAndAddUnsafe === void 0 ? void 0 : _Point_BASE_multiplyAndAddUnsafe.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n_c = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\nvar _c;\n$RefreshReg$(_c, \"SWUFpSqrtRatio\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELG9FQUFvRSxHQUNQO0FBQ3VDO0FBQ25FO0FBQ3lCO0FBQzFELFNBQVNhLG1CQUFtQkMsSUFBSTtJQUM1QixJQUFJQSxLQUFLQyxJQUFJLEtBQUtDLFdBQ2ROLGdEQUFLQSxDQUFDLFFBQVFJLEtBQUtDLElBQUk7SUFDM0IsSUFBSUQsS0FBS0csT0FBTyxLQUFLRCxXQUNqQk4sZ0RBQUtBLENBQUMsV0FBV0ksS0FBS0csT0FBTztBQUNyQztBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNTCxPQUFPYix3REFBYUEsQ0FBQ2tCO0lBQzNCVixxREFBaUIsQ0FBQ0ssTUFBTTtRQUNwQk8sR0FBRztRQUNIQyxHQUFHO0lBQ1AsR0FBRztRQUNDQywwQkFBMEI7UUFDMUJDLGdCQUFnQjtRQUNoQkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLG9CQUFvQjtRQUNwQkMsV0FBVztRQUNYQyxTQUFTO0lBQ2I7SUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFVixDQUFDLEVBQUUsR0FBR1A7SUFDeEIsSUFBSWdCLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHeEIsSUFBSTtJQUFDO0FBQ25DO0FBQ0EsTUFBTSxFQUFFeUIs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UUFDOUNELE1BQU1oVSxHQUFHcUYsR0FBRyxDQUFDc1AsS0FBSzVWLEtBQUsyVixDQUFDLEdBQUcsb0JBQW9CO1FBQy9DWixNQUFNOVQsR0FBR3NGLEdBQUcsQ0FBQ3dPLEtBQUtFLE1BQU0sc0JBQXNCO1FBQzlDcFAsSUFBSTVFLEdBQUdxRixHQUFHLENBQUN3TyxLQUFLRSxNQUFNLHNCQUFzQjtRQUM1QyxNQUFNLEVBQUV4TSxPQUFPLEVBQUUrTSxLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2EsTUFBTSxpREFBaUQ7UUFDakc5UCxJQUFJN0UsR0FBR3FGLEdBQUcsQ0FBQ3dPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEL08sSUFBSTdFLEdBQUdxRixHQUFHLENBQUNSLEdBQUd5UCxRQUFRLG1CQUFtQjtRQUN6QzFQLElBQUk1RSxHQUFHbVUsSUFBSSxDQUFDdlAsR0FBR21QLEtBQUt4TSxVQUFVLHdDQUF3QztRQUN0RTFDLElBQUk3RSxHQUFHbVUsSUFBSSxDQUFDdFAsR0FBR3lQLE9BQU8vTSxVQUFVLHVDQUF1QztRQUN2RSxNQUFNOE0sS0FBS3JVLEdBQUcrSSxLQUFLLENBQUM2SyxPQUFPNVQsR0FBRytJLEtBQUssQ0FBQ2xFLElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0UsR0FBR21VLElBQUksQ0FBQ25VLEdBQUcwSixHQUFHLENBQUM3RSxJQUFJQSxHQUFHd1AsS0FBSyw0QkFBNEI7UUFDM0R6UCxJQUFJNUUsR0FBRzRVLEdBQUcsQ0FBQ2hRLEdBQUdxUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVyUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2I1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiLlxuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHBpcHBlbmdlciwgdmFsaWRhdGVCYXNpYywgd05BRiwgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBnZXRNaW5IYXNoTGVuZ3RoLCBpbnZlcnQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQsIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYWJvb2wsIGVuc3VyZUJ5dGVzLCBtZW1vaXplZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcbiAgICBpZiAob3B0cy5sb3dTICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdsb3dTJywgb3B0cy5sb3dTKTtcbiAgICBpZiAob3B0cy5wcmVoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBleHBlY3RlZCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyB1dC5udW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAxMjgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKG51bSk7XG4gICAgICAgICAgICAvLyBQYWQgd2l0aCB6ZXJvIGJ5dGUgaWYgbmVnYXRpdmUgZmxhZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuICAgICAgICAgICAgICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBiMm4oZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB1dC5pblJhbmdlKG51bSwgXzFuLCBDVVJWRS5uKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG46IE4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleSwgZXhwZWN0ZWQgaGV4IG9yICcgKyBuQnl0ZUxlbmd0aCArICcgYnl0ZXMsIGdvdCAnICsgdHlwZW9mIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kKG51bSwgTik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICB1dC5hSW5SYW5nZSgncHJpdmF0ZSBrZXknLCBudW0sIF8xbiwgTik7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2MsIF8wbiwgTik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIC8vIENhc2UgYTogbm8gZW5kb21vcnBoaXNtLiBDYXNlIGI6IGhhcyBwcmVjb21wdXRlcy5cbiAgICAgICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICAgICAgLy8gQ2FzZSBjOiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlIG1ldGhvZHMgZm9yIGl0LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEZpZWxkIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbiAqIC8vIEJlZm9yZSB0aGF0LCBkZWZpbmUgQmlnSW50LXM6IGEsIGIsIHAsIG4sIEd4LCBHeVxuICogY29uc3QgY3VydmUgPSB3ZWllcnN0cmFzcyh7IGEsIGIsIEZwOiBGaWVsZChwKSwgbiwgR3gsIEd5LCBoOiAxbiB9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXV0LmluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncicsIHRoaXMuciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncycsIHRoaXMucywgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHMgaW4gWzEuLk5dXG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIlxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgdXQuYUluUmFuZ2UoJ251bSA8IDJeJyArIENVUlZFLm5CaXRMZW5ndGgsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGludmFsaWQgYXQgbGVhc3QgZm9yIFA1MjEuIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IG9wdHM7XG4gICAgICAgIC8vIFZlcmlmeSBvcHRzLCBkZWR1Y2Ugc2lnbmF0dXJlIGZvcm1hdFxuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgIT09ICdjb21wYWN0JyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgbXVzdCBiZSBjb21wYWN0IG9yIGRlcicpO1xuICAgICAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZyk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gIWlzSGV4ICYmXG4gICAgICAgICAgICAhZm9ybWF0ICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIGlmICghaXNIZXggJiYgIWlzT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgVWludDhBcnJheSwgaGV4IHN0cmluZyBvciBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzT2JqKVxuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xuICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gJ2NvbXBhY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9zaWcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbInBpcHBlbmdlciIsInZhbGlkYXRlQmFzaWMiLCJ3TkFGIiwiRmllbGQiLCJnZXRNaW5IYXNoTGVuZ3RoIiwiaW52ZXJ0IiwibWFwSGFzaFRvRmllbGQiLCJtb2QiLCJ2YWxpZGF0ZUZpZWxkIiwidXQiLCJhYm9vbCIsImVuc3VyZUJ5dGVzIiwibWVtb2l6ZWQiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJvcHRzIiwibG93UyIsInVuZGVmaW5lZCIsInByZWhhc2giLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwidmFsaWRhdGVPYmplY3QiLCJhIiwiYiIsImFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyIsIndyYXBQcml2YXRlS2V5IiwiaXNUb3JzaW9uRnJlZSIsImNsZWFyQ29mYWN0b3IiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJmcm9tQnl0ZXMiLCJ0b0J5dGVzIiwiZW5kbyIsIkZwIiwiZXFsIiwiWkVSTyIsIkVycm9yIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiT2JqZWN0IiwiZnJlZXplIiwiYnl0ZXNUb051bWJlckJFIiwiYjJuIiwiaGV4VG9CeXRlcyIsImgyYiIsIkRFUkVyciIsImNvbnN0cnVjdG9yIiwibSIsIkRFUiIsIkVyciIsIl90bHYiLCJlbmNvZGUiLCJ0YWciLCJkYXRhIiwiRSIsImxlbmd0aCIsImRhdGFMZW4iLCJsZW4iLCJudW1iZXJUb0hleFVucGFkZGVkIiwibGVuTGVuIiwidCIsImRlY29kZSIsInBvcyIsImZpcnN0IiwiaXNMb25nIiwibGVuZ3RoQnl0ZXMiLCJzdWJhcnJheSIsInYiLCJsIiwiX2ludCIsIm51bSIsIl8wbiIsImhleCIsIk51bWJlciIsInBhcnNlSW50IiwidG9TaWciLCJpbnQiLCJ0bHYiLCJhYnl0ZXMiLCJzZXFCeXRlcyIsInNlcUxlZnRCeXRlcyIsInJCeXRlcyIsInJMZWZ0Qnl0ZXMiLCJzQnl0ZXMiLCJzTGVmdEJ5dGVzIiwiciIsInMiLCJoZXhGcm9tU2lnIiwic2lnIiwicnMiLCJzcyIsInNlcSIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIndlaWVyc3RyYXNzUG9pbnRzIiwiQ1VSVkUiLCJGbiIsIm4iLCJuQml0TGVuZ3RoIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiVWludDhBcnJheSIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwiaW5SYW5nZSIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJrZXkiLCJsZW5ndGhzIiwibkJ5dGVMZW5ndGgiLCJOIiwiaXNCeXRlcyIsImJ5dGVzVG9IZXgiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZXJyb3IiLCJhSW5SYW5nZSIsImFzc2VydFByalBvaW50Iiwib3RoZXIiLCJQb2ludCIsInRvQWZmaW5lTWVtbyIsInAiLCJpeiIsInB4IiwicHkiLCJweiIsInoiLCJPTkUiLCJpczAiLCJpbnYiLCJheCIsImF5IiwienoiLCJhc3NlcnRWYWxpZE1lbW8iLCJpc1ZhbGlkIiwibGVmdCIsInJpZ2h0IiwiZnJvbUFmZmluZSIsImkiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJtc20iLCJzY2FsYXJzIiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwid25hZiIsInNldFdpbmRvd1NpemUiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3TkFGQ2FjaGVkIiwibXVsdGlwbHlVbnNhZmUiLCJzYyIsIkkiLCJoYXNQcmVjb21wdXRlcyIsIndOQUZDYWNoZWRVbnNhZmUiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsImQiLCJzY2FsYXIiLCJmYWtlIiwiZiIsImYxcCIsImYycCIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwiUSIsIkciLCJzdW0iLCJoIiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwiaXNDb21wcmVzc2VkIiwidG9IZXgiLCJfYml0cyIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJtb2ROIiwiaW52TiIsImNhdCIsImhlYWQiLCJPUkRFUiIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJjbCIsInVsIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJzbGljZSIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlcnkiLCJyZWNvdmVyUHVibGljS2V5IiwibXNnSGFzaCIsInJlYyIsInJhZGoiLCJwcmVmaXgiLCJSIiwiaXIiLCJ1MSIsInUyIiwiaGFzSGlnaFMiLCJ0b0RFUlJhd0J5dGVzIiwidG9ERVJIZXgiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJyYW5kb21Qcml2YXRlS2V5IiwicHJlY29tcHV0ZSIsImdldFB1YmxpY0tleSIsImlzUHJvYlB1YiIsIml0ZW0iLCJhcnIiLCJzdHIiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJiaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJrIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwic2VlZCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJxIiwibm9ybVMiLCJkZWZhdWx0VmVyT3B0cyIsInNpZ24iLCJwcml2S2V5IiwiQyIsImRyYmciLCJjcmVhdGVIbWFjRHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiZm9ybWF0IiwiaXNIZXgiLCJpc09iaiIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJwb3ciLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag) {\n    for(var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        messages[_key - 1] = arguments[_key];\n    }\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n_c = GmulAdd;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */ const schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */ const hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */ const encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\nvar _c;\n$RefreshReg$(_c, \"GmulAdd\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG9FQUFvRSxHQUN0QjtBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRSxNQUFNZSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJVjtJQUNWLGtCQUFrQjtJQUNsQixNQUFNVyxNQUFNVixPQUFPLElBQUlXLE1BQU1YLE9BQU8sSUFBSVksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNYyxPQUFPZCxPQUFPLEtBQUtlLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPO0lBQzFELE1BQU1pQixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFBVTtJQUN0QyxNQUFNUyxLQUFLLEtBQU1ELEtBQUtULElBQUtDLEdBQUcsTUFBTTtJQUNwQyxNQUFNVSxLQUFLLDJEQUFNRCxJQUFJUixLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNVyxLQUFLLDJEQUFNRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNWSxNQUFNLDJEQUFNRCxJQUFJakIsS0FBS00sS0FBS1EsS0FBTVI7SUFDdEMsTUFBTWEsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUgsS0FBS1ksTUFBT1o7SUFDekMsTUFBTWMsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUosS0FBS2EsTUFBT2I7SUFDekMsTUFBTWUsTUFBTSwy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QUNDb0ksS0FBSztRQUNMQyxXQUFXO1FBQ1hyRCxHQUFHekQsS0FBSytHLEtBQUs7UUFDYnRDLEdBQUc7UUFDSHpELEdBQUc7UUFDSGdHLFFBQVE7UUFDUkMsTUFBTWhLLHdEQUFNQTtJQUNoQixFQUFDO0FBQ0QscUZBQXFGLEdBQzlFLE1BQU1pSyxjQUE4QixhQUFILEdBQUksS0FBTVAsSUFBSU8sV0FBVyxJQUFJO0FBQ3JFLHVGQUF1RixHQUNoRixNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1SLElBQUlRLGFBQWEsSUFBSSxDQUN6RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz9kMTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTklTVCBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogU2VlbXMgdG8gYmUgcmlnaWQgKG5vdCBiYWNrZG9vcmVkKVxuICogW2FzIHBlciBkaXNjdXNzaW9uXShodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NSkuXG4gKlxuICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICogW1NlZSBleHBsYW5hdGlvbl0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2KS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFJblJhbmdlLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgaW5SYW5nZSwgbnVtYmVyVG9CeXRlc0JFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBpdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICpcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLCAvLyBlcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnA6IEZwazEsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG4gICAgbjogc2VjcDI1NmsxTiwgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gQ29mYWN0b3JcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGFJblJhbmdlKCd4JywgeCwgXzFuLCBzZWNwMjU2azFQKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWluUmFuZ2UociwgXzFuLCBzZWNwMjU2azFQKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghaW5SYW5nZShzLCBfMW4sIHNlY3AyNTZrMU4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKi9cbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogc2VjcDI1NmsxIGhhc2gtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuLyoqIHNlY3AyNTZrMSBlbmNvZGUtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDdXJ2ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJGaWVsZCIsIm1vZCIsInBvdzIiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJpblJhbmdlIiwibnVtYmVyVG9CeXRlc0JFIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnBrMSIsImVxbCIsInNxciIsIkVycm9yIiwidW5kZWZpbmVkIiwic3FydCIsInNlY3AyNTZrMSIsIkZwIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImVuZG8iLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJrIiwiYTEiLCJiMSIsImEyIiwiUE9XXzJfMTI4IiwiYzEiLCJjMiIsImsxIiwiazIiLCJrMW5lZyIsImsybmVnIiwiXzBuIiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJwb2ludFRvQnl0ZXMiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJzbGljZSIsIm51bVRvMzJiIiwibW9kUCIsIngiLCJtb2ROIiwiUG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJHbXVsQWRkIiwiUSIsIkJBU0UiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInNjaG5vcnJHZXRFeHRQdWJLZXkiLCJwcml2IiwiZF8iLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJwIiwiZnJvbVByaXZhdGVLZXkiLCJzY2FsYXIiLCJoYXNFdmVuWSIsImJ5dGVzIiwibGlmdF94IiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsIm51bSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJzY2hub3JyIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDcUQ7QUFDWDtBQUNwQyxNQUFNSyxhQUFhRiwyQ0FBSUE7SUEyQjFCRyxPQUFPQyxHQUFHLEVBQUU7UUFDUk4sbURBQU9BLENBQUMsSUFBSTtRQUNaLElBQUksQ0FBQ08sS0FBSyxDQUFDRixNQUFNLENBQUNDO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FFLFdBQVdDLEdBQUcsRUFBRTtRQUNaVCxtREFBT0EsQ0FBQyxJQUFJO1FBQ1pELGtEQUFNQSxDQUFDVSxLQUFLLElBQUksQ0FBQ0MsU0FBUztRQUMxQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNKLEtBQUssQ0FBQ0MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNHLEtBQUssQ0FBQ1AsTUFBTSxDQUFDSTtRQUNsQixJQUFJLENBQUNHLEtBQUssQ0FBQ0osVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNJLE9BQU87SUFDaEI7SUFDQUMsU0FBUztRQUNMLE1BQU1MLE1BQU0sSUFBSU0sV0FBVyxJQUFJLENBQUNILEtBQUssQ0FBQ0YsU0FBUztRQUMvQyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBTyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFUixLQUFLLEVBQUVMLEtBQUssRUFBRUksUUFBUSxFQUFFVSxTQUFTLEVBQUVDLFFBQVEsRUFBRVosU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RU8sS0FBS0E7UUFDTEEsR0FBR04sUUFBUSxHQUFHQTtRQUNkTSxHQUFHSSxTQUFTLEdBQUdBO1FBQ2ZKLEdBQUdLLFFBQVEsR0FBR0E7UUFDZEwsR0FBR1AsU0FBUyxHQUFHQTtRQUNmTyxHQUFHTCxLQUFLLEdBQUdBLE1BQU1JLFVBQVUsQ0FBQ0MsR0FBR0wsS0FBSztRQUNwQ0ssR0FBR1YsS0FBSyxHQUFHQSxNQUFNUyxVQUFVLENBQUNDLEdBQUdWLEtBQUs7UUFDcEMsT0FBT1U7SUFDWDtJQUNBSixVQUFVO1FBQ04sSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDVCxLQUFLLENBQUNDLE9BQU87UUFDbEIsSUFBSSxDQUFDTixLQUFLLENBQUNNLE9BQU87SUFDdEI7SUE5REFVLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNkLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLFNBQVMsR0FBRztRQUNqQnBCLGlEQUFLQSxDQUFDdUI7UUFDTixNQUFNRSxNQUFNdkIsa0RBQU9BLENBQUNzQjtRQUNwQixJQUFJLENBQUNsQixLQUFLLEdBQUdpQixLQUFLTCxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNaLEtBQUssQ0FBQ0YsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSXNCLE1BQU07UUFDcEIsSUFBSSxDQUFDTCxRQUFRLEdBQUcsSUFBSSxDQUFDZixLQUFLLENBQUNlLFFBQVE7UUFDbkMsSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDSCxLQUFLLENBQUNHLFNBQVM7UUFDckMsTUFBTVksV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTU0sTUFBTSxJQUFJYixXQUFXTztRQUMzQix3Q0FBd0M7UUFDeENNLElBQUlDLEdBQUcsQ0FBQ0gsSUFBSUksTUFBTSxHQUFHUixXQUFXRSxLQUFLTCxNQUFNLEdBQUdkLE1BQU0sQ0FBQ3FCLEtBQUtaLE1BQU0sS0FBS1k7UUFDckUsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlILElBQUlFLE1BQU0sRUFBRUMsSUFDNUJILEdBQUcsQ0FBQ0csRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDeEIsS0FBSyxDQUFDRixNQUFNLENBQUN1QjtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDaEIsS0FBSyxHQUFHWSxLQUFLTCxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUgsSUFBSUUsTUFBTSxFQUFFQyxJQUM1QkgsR0FBRyxDQUFDRyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNuQixLQUFLLENBQUNQLE1BQU0sQ0FBQ3VCO1FBQ2xCQSxJQUFJSSxJQUFJLENBQUM7SUFDYjtBQXNDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLE9BQU8sQ0FBQ1QsTUFBTUUsS0FBS1EsVUFBWSxJQUFJOUIsS0FBS29CLE1BQU1FLEtBQUtyQixNQUFNLENBQUM2QixTQUFTcEIsTUFBTSxHQUFHO0FBQ3pGbUIsS0FBS2QsTUFBTSxHQUFHLENBQUNLLE1BQU1FLE1BQVEsSUFBSXRCLEtBQUtvQixNQUFNRSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/MGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFleGlzdHMiLCJhaGFzaCIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsInVwZGF0ZSIsImJ1ZiIsImlIYXNoIiwiZGlnZXN0SW50byIsIm91dCIsIm91dHB1dExlbiIsImZpbmlzaGVkIiwib0hhc2giLCJkZXN0cm95IiwiZGlnZXN0IiwiVWludDhBcnJheSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwiZGVzdHJveWVkIiwiYmxvY2tMZW4iLCJjb25zdHJ1Y3RvciIsImhhc2giLCJfa2V5Iiwia2V5IiwiRXJyb3IiLCJwYWQiLCJzZXQiLCJsZW5ndGgiLCJpIiwiZmlsbCIsImhtYWMiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/AccessList.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: function() { return /* binding */ InvalidStorageKeySizeError; },\n/* harmony export */   fromTupleList: function() { return /* binding */ fromTupleList; },\n/* harmony export */   toTupleList: function() { return /* binding */ toTupleList; }\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */ function fromTupleList(accessList) {\n    const list = [];\n    for(let i = 0; i < accessList.length; i++){\n        const [address, storageKeys] = accessList[i];\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key)=>_Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key))\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */ function toTupleList(accessList) {\n    if (!accessList || accessList.length === 0) return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList){\n        for(let j = 0; j < storageKeys.length; j++)if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32) throw new InvalidStorageKeySizeError({\n            storageKey: storageKeys[j]\n        });\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        tuple.push([\n            address,\n            storageKeys\n        ]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */ class InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }){\n        super('Size for storage key \"'.concat(storageKey, '\" is invalid. Expected 32 bytes. Got ').concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey), \" bytes.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AccessList.InvalidStorageKeySizeError\"\n        });\n    }\n} //# sourceMappingURL=AccessList.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWNjZXNzTGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDSjtBQUNGO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNJLGNBQWNDLFVBQVU7SUFDcEMsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFdBQVdHLE1BQU0sRUFBRUQsSUFBSztRQUN4QyxNQUFNLENBQUNFLFNBQVNDLFlBQVksR0FBR0wsVUFBVSxDQUFDRSxFQUFFO1FBQzVDLElBQUlFLFNBQ0FULCtDQUFjLENBQUNTLFNBQVM7WUFBRUcsUUFBUTtRQUFNO1FBQzVDTixLQUFLTyxJQUFJLENBQUM7WUFDTkosU0FBU0E7WUFDVEMsYUFBYUEsWUFBWUksR0FBRyxDQUFDLENBQUNDLE1BQVFiLDhDQUFhLENBQUNhLE9BQU9BLE1BQU1aLDZDQUFZLENBQUNZO1FBQ2xGO0lBQ0o7SUFDQSxPQUFPVDtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDTSxTQUFTWSxZQUFZYixVQUFVO0lBQ2xDLElBQUksQ0FBQ0EsY0FBY0EsV0FBV0csTUFBTSxLQUFLLEdBQ3JDLE9BQU8sRUFBRTtJQUNiLE1BQU1XLFFBQVEsRUFBRTtJQUNoQixLQUFLLE1BQU0sRUFBRVYsT0FBTyxFQUFFQyxXQUFXLEVBQUUsSUFBSUwsV0FBWTtRQUMvQyxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSVYsWUFBWUYsTUFBTSxFQUFFWSxJQUNwQyxJQUFJakIseUNBQVEsQ0FBQ08sV0FBVyxDQUFDVSxFQUFFLE1BQU0sSUFDN0IsTUFBTSxJQUFJRSwyQkFBMkI7WUFDakNDLFlBQVliLFdBQVcsQ0FBQ1UsRUFBRTtRQUM5QjtRQUNSLElBQUlYLFNBQ0FULCtDQUFjLENBQUNTLFNBQVM7WUFBRUcsUUFBUTtRQUFNO1FBQzVDTyxNQUFNTixJQUFJLENBQUM7WUFBQ0o7WUFBU0M7U0FBWTtJQUNyQztJQUNBLE9BQU9TO0FBQ1g7QUFDQSxzREFBc0QsR0FDL0MsTUFBTUcsbUNBQW1DckIsaURBQWdCO0lBQzVEd0IsWUFBWSxFQUFFRixVQUFVLEVBQUUsQ0FBRTtRQUN4QixLQUFLLENBQUMseUJBQTJFcEIsT0FBbERvQixZQUFXLHlDQUE0RCxPQUFyQnBCLHlDQUFRLENBQUNvQixhQUFZO1FBQ3RHRyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BY2Nlc3NMaXN0LmpzPzJkYWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBBY2Nlc3MgTGlzdCB0dXBsZXMgaW50byBhIG9iamVjdC1mb3JtYXR0ZWQgbGlzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KFtcbiAqICAgW1xuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIFtcbiAqICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgICAgJzB4NjBmZGQyOWZmOTEyY2U4ODBjZDNlZGFmOWY5MzJkYzYxZDNkYWU4MjNlYTc3ZTAzMjNmOTRhZGI5ZjZhNzJmZScsXG4gKiAgICAgXSxcbiAqICAgXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBzdG9yYWdlS2V5czogW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBMaXN0IG9mIHR1cGxlcy5cbiAqIEByZXR1cm5zIEFjY2VzcyBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbYWRkcmVzcywgc3RvcmFnZUtleXNdID0gYWNjZXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoa2V5KSA9PiBIYXNoLnZhbGlkYXRlKGtleSkgPyBrZXkgOiBIZXgudHJpbUxlZnQoa2V5KSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBzdHJ1Y3R1cmVkIEFjY2VzcyBMaXN0IGludG8gYSBsaXN0IG9mIHR1cGxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChbXG4gKiAgIHtcbiAqICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICBzdG9yYWdlS2V5czogW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJ10sXG4gKiAgIH0sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBbXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgICAgW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBBY2Nlc3MgbGlzdC5cbiAqIEByZXR1cm5zIExpc3Qgb2YgdHVwbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QoYWNjZXNzTGlzdCkge1xuICAgIGlmICghYWNjZXNzTGlzdCB8fCBhY2Nlc3NMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlID0gW107XG4gICAgZm9yIChjb25zdCB7IGFkZHJlc3MsIHN0b3JhZ2VLZXlzIH0gb2YgYWNjZXNzTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JhZ2VLZXlzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgaWYgKEhleC5zaXplKHN0b3JhZ2VLZXlzW2pdKSAhPT0gMzIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleXNbal0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZGRyZXNzKVxuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICB0dXBsZS5wdXNoKFthZGRyZXNzLCBzdG9yYWdlS2V5c10pO1xuICAgIH1cbiAgICByZXR1cm4gdHVwbGU7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgYSBzdG9yYWdlIGtleSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzdG9yYWdlS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgZm9yIHN0b3JhZ2Uga2V5IFwiJHtzdG9yYWdlS2V5fVwiIGlzIGludmFsaWQuIEV4cGVjdGVkIDMyIGJ5dGVzLiBHb3QgJHtIZXguc2l6ZShzdG9yYWdlS2V5KX0gYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBY2Nlc3NMaXN0LkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NMaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJBZGRyZXNzIiwiRXJyb3JzIiwiSGFzaCIsIkhleCIsImZyb21UdXBsZUxpc3QiLCJhY2Nlc3NMaXN0IiwibGlzdCIsImkiLCJsZW5ndGgiLCJhZGRyZXNzIiwic3RvcmFnZUtleXMiLCJhc3NlcnQiLCJzdHJpY3QiLCJwdXNoIiwibWFwIiwia2V5IiwidmFsaWRhdGUiLCJ0cmltTGVmdCIsInRvVHVwbGVMaXN0IiwidHVwbGUiLCJqIiwic2l6ZSIsIkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIiwic3RvcmFnZUtleSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromRpc: function() { return /* binding */ fromRpc; },\n/* harmony export */   fromRpcList: function() { return /* binding */ fromRpcList; },\n/* harmony export */   fromTuple: function() { return /* binding */ fromTuple; },\n/* harmony export */   fromTupleList: function() { return /* binding */ fromTupleList; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   toRpcList: function() { return /* binding */ toRpcList; },\n/* harmony export */   toTuple: function() { return /* binding */ toTuple; },\n/* harmony export */   toTupleList: function() { return /* binding */ toTupleList; }\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function from(authorization) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    return {\n        ...authorization,\n        ...options.signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */ function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */ function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    const signature = yParity && r && s ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    return from({\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    });\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */ function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */ function hash(authorization) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(\"0x05\", _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature)\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */ function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : \"0x\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */ function toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=Authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRjtBQUNBO0FBQ1k7QUFDNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBDQyxHQUNNLFNBQVNJLEtBQUtDLGFBQWE7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUMzQyxJQUFJLE9BQU9ELGNBQWNFLE9BQU8sS0FBSyxVQUNqQyxPQUFPQyxRQUFRSDtJQUNuQixPQUFPO1FBQUUsR0FBR0EsYUFBYTtRQUFFLEdBQUdDLFFBQVFHLFNBQVM7SUFBQztBQUNwRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU0QsUUFBUUgsYUFBYTtJQUNqQyxNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR047SUFDcEMsTUFBTUksWUFBWU4sa0RBQWlCLENBQUNFO0lBQ3BDLE9BQU87UUFDSEs7UUFDQUgsU0FBU00sT0FBT047UUFDaEJJLE9BQU9HLE9BQU9IO1FBQ2QsR0FBR0YsU0FBUztJQUNoQjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTTSxZQUFZQyxpQkFBaUI7SUFDekMsT0FBT0Esa0JBQWtCQyxHQUFHLENBQUNUO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUNNLFNBQVNVLFVBQVVDLEtBQUs7SUFDM0IsTUFBTSxDQUFDWixTQUFTRyxTQUFTQyxPQUFPUyxTQUFTQyxHQUFHQyxFQUFFLEdBQUdIO0lBQ2pELE1BQU1WLFlBQVlXLFdBQVdDLEtBQUtDLElBQUluQixvREFBbUIsQ0FBQztRQUFDaUI7UUFBU0M7UUFBR0M7S0FBRSxJQUFJQztJQUM3RSxPQUFPbkIsS0FBSztRQUNSTTtRQUNBSCxTQUFTTSxPQUFPTjtRQUNoQkksT0FBT0csT0FBT0g7UUFDZCxHQUFHRixTQUFTO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeURDLEdBQ00sU0FBU2UsY0FBY0MsU0FBUztJQUNuQyxNQUFNQyxPQUFPLEVBQUU7SUFDZixLQUFLLE1BQU1QLFNBQVNNLFVBQ2hCQyxLQUFLQyxJQUFJLENBQUNULFVBQVVDO0lBQ3hCLE9BQU9PO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FDTSxTQUFTRSxlQUFldkIsYUFBYTtJQUN4QyxPQUFPd0IsS0FBS3hCO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVN3QixLQUFLeEIsYUFBYTtJQUM5QixPQUFPTCwrQ0FBYyxDQUFDQywyQ0FBVSxDQUFDLFFBQVFDLDRDQUFXLENBQUMrQixRQUFRNUI7QUFDakU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVM2QixNQUFNN0IsYUFBYTtJQUMvQixNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR0YsV0FBVyxHQUFHSjtJQUNsRCxPQUFPO1FBQ0hLO1FBQ0FILFNBQVNOLCtDQUFjLENBQUNNO1FBQ3hCSSxPQUFPViwrQ0FBYyxDQUFDVTtRQUN0QixHQUFHUixnREFBZSxDQUFDTSxVQUFVO0lBQ2pDO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVMyQixVQUFVcEIsaUJBQWlCO0lBQ3ZDLE9BQU9BLGtCQUFrQkMsR0FBRyxDQUFDaUI7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTRCxRQUFRNUIsYUFBYTtJQUNqQyxNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR047SUFDcEMsTUFBTUksWUFBWU4sa0RBQWlCLENBQUNFO0lBQ3BDLE9BQU87UUFDSEUsVUFBVU4sK0NBQWMsQ0FBQ00sV0FBVztRQUNwQ0c7UUFDQUMsUUFBUVYsK0NBQWMsQ0FBQ1UsU0FBUztXQUM1QkYsWUFBWU4sa0RBQWlCLENBQUNNLGFBQWEsRUFBRTtLQUNwRDtBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBQ00sU0FBUzRCLFlBQVlYLElBQUk7SUFDNUIsSUFBSSxDQUFDQSxRQUFRQSxLQUFLWSxNQUFNLEtBQUssR0FDekIsT0FBTyxFQUFFO0lBQ2IsTUFBTWIsWUFBWSxFQUFFO0lBQ3BCLEtBQUssTUFBTXBCLGlCQUFpQnFCLEtBQ3hCRCxVQUFVRSxJQUFJLENBQUNNLFFBQVE1QjtJQUMzQixPQUFPb0I7QUFDWCxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanM/MmZiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIEF1dGhvcml6YXRpb24gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGNhbiBiZSBhdHRhY2hlZCB3aXRoIHRoZSBgc2lnbmF0dXJlYCBvcHRpb24uIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBzaWduaW5nXG4gKiBhbiBBdXRob3JpemF0aW9uIHdpdGgge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBdXRob3JpemF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHsgLi4uYXV0aG9yaXphdGlvbiwgLi4ub3B0aW9ucy5zaWduYXR1cmUgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVJwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKGZyb21ScGMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJ1xuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwZW5kIGEgU2lnbmF0dXJlIHR1cGxlIHRvIHRoZSBlbmQgb2YgYW4gQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MycsXG4gKiAgICcweDEnLFxuICogICAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyxcbiAqICAgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcsXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzcywgbm9uY2UsIHlQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0geVBhcml0eSAmJiByICYmIHMgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJ10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0JywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGVMaXN0IC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKiBAcmV0dXJucyBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZUxpc3QodHVwbGVMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHVwbGUgb2YgdHVwbGVMaXN0KVxuICAgICAgICBsaXN0LnB1c2goZnJvbVR1cGxlKHR1cGxlKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGNvbXB1dGluZyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS4gVGhpcyBwYXlsb2FkXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8gc2lnbmluZyBmdW5jdGlvbnMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZCxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUoYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJmcm9tIiwiYXV0aG9yaXphdGlvbiIsIm9wdGlvbnMiLCJjaGFpbklkIiwiZnJvbVJwYyIsInNpZ25hdHVyZSIsImFkZHJlc3MiLCJub25jZSIsImV4dHJhY3QiLCJOdW1iZXIiLCJCaWdJbnQiLCJmcm9tUnBjTGlzdCIsImF1dGhvcml6YXRpb25MaXN0IiwibWFwIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ5UGFyaXR5IiwiciIsInMiLCJ1bmRlZmluZWQiLCJmcm9tVHVwbGVMaXN0IiwidHVwbGVMaXN0IiwibGlzdCIsInB1c2giLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJmcm9tSGV4IiwidG9UdXBsZSIsInRvUnBjIiwiZnJvbU51bWJlciIsInRvUnBjTGlzdCIsInRvVHVwbGVMaXN0IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: function() { return /* binding */ decodeRlpCursor; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   readLength: function() { return /* binding */ readLength; },\n/* harmony export */   readList: function() { return /* binding */ readList; },\n/* harmony export */   to: function() { return /* binding */ to; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; }\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */ function toBytes(value) {\n    return to(value, \"Bytes\");\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */ function toHex(value) {\n    return to(value, \"Hex\");\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */ function to(value, to) {\n    const to_ = to !== null && to !== void 0 ? to : typeof value === \"string\" ? \"Hex\" : \"Bytes\";\n    const bytes = (()=>{\n        if (typeof value === \"string\") {\n            if (value.length > 3 && value.length % 2 !== 0) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */ /** @internal */ function decodeRlpCursor(cursor) {\n    let to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"Hex\";\n    if (cursor.bytes.length === 0) return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes;\n    const prefix = cursor.readByte();\n    if (prefix < 0x80) cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes;\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */ function readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80) return 1;\n    if (prefix <= offset + 55) return prefix - offset;\n    if (prefix === offset + 55 + 1) return cursor.readUint8();\n    if (prefix === offset + 55 + 2) return cursor.readUint16();\n    if (prefix === offset + 55 + 3) return cursor.readUint24();\n    if (prefix === offset + 55 + 4) return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Invalid RLP prefix\");\n}\n/** @internal */ function readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while(cursor.position - position < length)value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromBytes(bytes) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { as = \"Bytes\" } = options;\n    return from(bytes, {\n        as\n    });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromHex(hex) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { as = \"Hex\" } = options;\n    return from(hex, {\n        as\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (()=>{\n        if (bodyLength <= 55) return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            } else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);\n                else cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list){\n                encode(cursor);\n            }\n        }\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (()=>{\n        if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n        if (bytes.length <= 55) return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            } else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            } else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);\n                else cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        }\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8) return 1;\n    if (length < 2 ** 16) return 2;\n    if (length < 2 ** 24) return 3;\n    if (length < 2 ** 32) return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Length is too large.\");\n} //# sourceMappingURL=Rlp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ2U7QUFDL0M7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0ksUUFBUUMsS0FBSztJQUN6QixPQUFPQyxHQUFHRCxPQUFPO0FBQ3JCO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0UsTUFBTUYsS0FBSztJQUN2QixPQUFPQyxHQUFHRCxPQUFPO0FBQ3JCO0FBQ0EsaUZBQWlGO0FBQ2pGLFdBQVc7QUFDWCxpRkFBaUY7QUFDakYsY0FBYyxHQUNQLFNBQVNDLEdBQUdELEtBQUssRUFBRUMsRUFBRTtJQUN4QixNQUFNRSxNQUFNRixlQUFBQSxnQkFBQUEsS0FBTyxPQUFPRCxVQUFVLFdBQVcsUUFBUTtJQUN2RCxNQUFNSSxRQUFRLENBQUM7UUFDWCxJQUFJLE9BQU9KLFVBQVUsVUFBVTtZQUMzQixJQUFJQSxNQUFNSyxNQUFNLEdBQUcsS0FBS0wsTUFBTUssTUFBTSxHQUFHLE1BQU0sR0FDekMsTUFBTSxJQUFJUix1REFBc0IsQ0FBQ0c7WUFDckMsT0FBT0wsOENBQWEsQ0FBQ0s7UUFDekI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsTUFBTVEsU0FBU1YsdURBQWEsQ0FBQ00sT0FBTztRQUNoQ00sb0JBQW9CQyxPQUFPQyxpQkFBaUI7SUFDaEQ7SUFDQSxNQUFNQyxTQUFTQyxnQkFBZ0JOLFFBQVFMO0lBQ3ZDLE9BQU9VO0FBQ1g7QUFDQSxjQUFjLEdBQ2QsY0FBYyxHQUNQLFNBQVNDLGdCQUFnQk4sTUFBTTtRQUFFUCxLQUFBQSxpRUFBSztJQUN6QyxJQUFJTyxPQUFPSixLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUN4QixPQUFRSixPQUFPLFFBQVFKLDhDQUFhLENBQUNXLE9BQU9KLEtBQUssSUFBSUksT0FBT0osS0FBSztJQUNyRSxNQUFNWSxTQUFTUixPQUFPUyxRQUFRO0lBQzlC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QU07Z0JBQ25DRyxPQUFPaUQsU0FBUyxDQUFDckQ7WUFDckIsT0FDSztnQkFDREksT0FBTzBDLFFBQVEsQ0FBQyxPQUFPLEtBQUtNO2dCQUM1QixJQUFJQSxzQkFBc0IsR0FDdEJoRCxPQUFPMkMsU0FBUyxDQUFDL0MsTUFBTUMsTUFBTTtxQkFDNUIsSUFBSW1ELHNCQUFzQixHQUMzQmhELE9BQU80QyxVQUFVLENBQUNoRCxNQUFNQyxNQUFNO3FCQUM3QixJQUFJbUQsc0JBQXNCLEdBQzNCaEQsT0FBTzZDLFVBQVUsQ0FBQ2pELE1BQU1DLE1BQU07cUJBRTlCRyxPQUFPOEMsVUFBVSxDQUFDbEQsTUFBTUMsTUFBTTtnQkFDbENHLE9BQU9pRCxTQUFTLENBQUNyRDtZQUNyQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVM2QyxnQkFBZ0I1QyxNQUFNO0lBQzNCLElBQUlBLFNBQVMsS0FBSyxHQUNkLE9BQU87SUFDWCxJQUFJQSxTQUFTLEtBQUssSUFDZCxPQUFPO0lBQ1gsSUFBSUEsU0FBUyxLQUFLLElBQ2QsT0FBTztJQUNYLElBQUlBLFNBQVMsS0FBSyxJQUNkLE9BQU87SUFDWCxNQUFNLElBQUlULGlEQUFnQixDQUFDO0FBQy9CLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzPzg2YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPCAyICoqIDgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChsZW5ndGggPCAyICoqIDE2KVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiAyNClcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKGxlbmd0aCA8IDIgKiogMzIpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdMZW5ndGggaXMgdG9vIGxhcmdlLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmxwLmpzLm1hcCJdLCJuYW1lcyI6WyJCeXRlcyIsIkVycm9ycyIsIkhleCIsIkN1cnNvciIsInRvQnl0ZXMiLCJ2YWx1ZSIsInRvIiwidG9IZXgiLCJ0b18iLCJieXRlcyIsImxlbmd0aCIsIkludmFsaWRMZW5ndGhFcnJvciIsImZyb21IZXgiLCJjdXJzb3IiLCJjcmVhdGUiLCJyZWN1cnNpdmVSZWFkTGltaXQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInJlc3VsdCIsImRlY29kZVJscEN1cnNvciIsImZyb21CeXRlcyIsInByZWZpeCIsInJlYWRCeXRlIiwiZGVjcmVtZW50UG9zaXRpb24iLCJyZWFkTGVuZ3RoIiwicmVhZEJ5dGVzIiwicmVhZExpc3QiLCJvZmZzZXQiLCJyZWFkVWludDgiLCJyZWFkVWludDE2IiwicmVhZFVpbnQyNCIsInJlYWRVaW50MzIiLCJCYXNlRXJyb3IiLCJwb3NpdGlvbiIsInB1c2giLCJmcm9tIiwib3B0aW9ucyIsImFzIiwiZW5jb2RhYmxlIiwiZ2V0RW5jb2RhYmxlIiwiVWludDhBcnJheSIsImVuY29kZSIsImhleCIsIkFycmF5IiwiaXNBcnJheSIsImdldEVuY29kYWJsZUxpc3QiLCJtYXAiLCJ4IiwiZ2V0RW5jb2RhYmxlQnl0ZXMiLCJsaXN0IiwiYm9keUxlbmd0aCIsInJlZHVjZSIsImFjYyIsInNpemVPZkJvZHlMZW5ndGgiLCJnZXRTaXplT2ZMZW5ndGgiLCJwdXNoQnl0ZSIsInB1c2hVaW50OCIsInB1c2hVaW50MTYiLCJwdXNoVWludDI0IiwicHVzaFVpbnQzMiIsImJ5dGVzT3JIZXgiLCJzaXplT2ZCeXRlc0xlbmd0aCIsInB1c2hCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: function() { return /* binding */ InvalidRError; },\n/* harmony export */   InvalidSError: function() { return /* binding */ InvalidSError; },\n/* harmony export */   InvalidSerializedSizeError: function() { return /* binding */ InvalidSerializedSizeError; },\n/* harmony export */   InvalidVError: function() { return /* binding */ InvalidVError; },\n/* harmony export */   InvalidYParityError: function() { return /* binding */ InvalidYParityError; },\n/* harmony export */   MissingPropertiesError: function() { return /* binding */ MissingPropertiesError; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   extract: function() { return /* binding */ extract; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; },\n/* harmony export */   fromDerBytes: function() { return /* binding */ fromDerBytes; },\n/* harmony export */   fromDerHex: function() { return /* binding */ fromDerHex; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   fromLegacy: function() { return /* binding */ fromLegacy; },\n/* harmony export */   fromRpc: function() { return /* binding */ fromRpc; },\n/* harmony export */   fromTuple: function() { return /* binding */ fromTuple; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   toDerBytes: function() { return /* binding */ toDerBytes; },\n/* harmony export */   toDerHex: function() { return /* binding */ toDerHex; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   toLegacy: function() { return /* binding */ toLegacy; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   toTuple: function() { return /* binding */ toTuple; },\n/* harmony export */   vToYParity: function() { return /* binding */ vToYParity; },\n/* harmony export */   validate: function() { return /* binding */ validate; },\n/* harmony export */   yParityToV: function() { return /* binding */ yParityToV; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */ function assert(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(\"0x\".concat(signature.slice(130)));\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch (e) {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */ function extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */ function from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n        size: 32\n    }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n        size: 32\n    }), // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return \"0x\".concat(sig.toDERHex());\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */ function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */ function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n            size: 32\n        }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */ function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s))\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */ function validate(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        assert(signature, options);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */ function vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */ function yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\n/** Thrown when the serialized signature is of an invalid size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Value `\".concat(signature, \"` is an invalid signature size.\"), {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                \"Received \".concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature)), \" bytes.\")\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */ class MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Signature `\".concat(_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature), \"` is missing either an `r`, `s`, or `yParity` property.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */ class InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid r value. r must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */ class InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid s value. s must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */ class InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid y-parity value. Y-parity must be 0 or 1.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */ class InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid v value. v must be 27, 28 or >=35.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n} //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2hCO0FBQ0U7QUFDTjtBQUNFO0FBQ1E7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNNLE9BQU9DLFNBQVM7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUN6QyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRDtJQUN0QixJQUFJLE9BQU9ELFVBQVVHLENBQUMsS0FBSyxhQUN2QixNQUFNLElBQUlDLHVCQUF1QjtRQUFFSjtJQUFVO0lBQ2pELElBQUksT0FBT0EsVUFBVUssQ0FBQyxLQUFLLGFBQ3ZCLE1BQU0sSUFBSUQsdUJBQXVCO1FBQUVKO0lBQVU7SUFDakQsSUFBSUUsYUFBYSxPQUFPRixVQUFVTSxPQUFPLEtBQUssYUFDMUMsTUFBTSxJQUFJRix1QkFBdUI7UUFBRUo7SUFBVTtJQUNqRCxJQUFJQSxVQUFVRyxDQUFDLEdBQUcsRUFBRSxJQUFJSCxVQUFVRyxDQUFDLEdBQUdMLG9EQUFtQixFQUNyRCxNQUFNLElBQUlVLGNBQWM7UUFBRUMsT0FBT1QsVUFBVUcsQ0FBQztJQUFDO0lBQ2pELElBQUlILFVBQVVLLENBQUMsR0FBRyxFQUFFLElBQUlMLFVBQVVLLENBQUMsR0FBR1Asb0RBQW1CLEVBQ3JELE1BQU0sSUFBSVksY0FBYztRQUFFRCxPQUFPVCxVQUFVSyxDQUFDO0lBQUM7SUFDakQsSUFBSSxPQUFPTCxVQUFVTSxPQUFPLEtBQUssWUFDN0JOLFVBQVVNLE9BQU8sS0FBSyxLQUN0Qk4sVUFBVU0sT0FBTyxLQUFLLEdBQ3RCLE1BQU0sSUFBSUssb0JBQW9CO1FBQUVGLE9BQU9ULFVBQVVNLE9BQU87SUFBQztBQUNqRTtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU00sVUFBVVosU0FBUztJQUMvQixPQUFPYSxRQUFRakIsOENBQWEsQ0FBQ0k7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU2EsUUFBUWIsU0FBUztJQUM3QixJQUFJQSxVQUFVYyxNQUFNLEtBQUssT0FBT2QsVUFBVWMsTUFBTSxLQUFLLEtBQ2pELE1BQU0sSUFBSUMsMkJBQTJCO1FBQUVmO0lBQVU7SUFDckQsTUFBTUcsSUFBSWEsT0FBT3BCLDBDQUFTLENBQUNJLFdBQVcsR0FBRztJQUN6QyxNQUFNSyxJQUFJVyxPQUFPcEIsMENBQVMsQ0FBQ0ksV0FBVyxJQUFJO0lBQzFDLE1BQU1NLFVBQVUsQ0FBQztRQUNiLE1BQU1BLFVBQVVZLE9BQU8sS0FBMEIsT0FBckJsQixVQUFVaUIsS0FBSyxDQUFDO1FBQzVDLElBQUlDLE9BQU9DLEtBQUssQ0FBQ2IsVUFDYixPQUFPYztRQUNYLElBQUk7WUFDQSxPQUFPQyxXQUFXZjtRQUN0QixFQUNBLFVBQU07WUFDRixNQUFNLElBQUlLLG9CQUFvQjtnQkFBRUYsT0FBT0g7WUFBUTtRQUNuRDtJQUNKO0lBQ0EsSUFBSSxPQUFPQSxZQUFZLGFBQ25CLE9BQU87UUFDSEg7UUFDQUU7SUFDSjtJQUNKLE9BQU87UUFDSEY7UUFDQUU7UUFDQUM7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxTQUFTZ0IsUUFBUWIsS0FBSztJQUN6QixJQUFJLE9BQU9BLE1BQU1OLENBQUMsS0FBSyxhQUNuQixPQUFPaUI7SUFDWCxJQUFJLE9BQU9YLE1BQU1KLENBQUMsS0FBSyxhQUNuQixPQUFPZTtJQUNYLE9BQU9HLEtBQUtkO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcURDLEdBQ00sU0FBU2MsS0FBS3ZCLFNBQVM7SUFDMUIsTUFBTXdCLGFBQWEsQ0FBQztRQUNoQixJQUFJLE9BQU94QixjQUFjLFVBQ3JCLE9BQU9hLFFBQVFiO1FBQ25CLElBQUlBLHFCQUFxQnlCLFlBQ3JCLE9BQU9iLFVBQVVaO1FBQ3JCLElBQUksT0FBT0EsVUFBVUcsQ0FBQyxLQUFLLFVBQ3ZCLE9BQU91QixRQUFRMUI7UUFDbkIsSUFBSUEsVUFBVTJCLENBQUMsRUFDWCxPQUFPQyxXQUFXNUI7UUFDdEIsT0FBTztZQUNIRyxHQUFHSCxVQUFVRyxDQUFDO1lBQ2RFLEdBQUdMLFVBQVVLLENBQUM7WUFDZCxHQUFJLE9BQU9MLFVBQVVNLE9BQU8sS0FBSyxjQUMzQjtnQkFBRUEsU0FBU04sVUFBVU0sT0FBTztZQUFDLElBQzdCLENBQUMsQ0FBQztRQUNaO0lBQ0o7SUFDQVAsT0FBT3lCO0lBQ1AsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNLLGFBQWE3QixTQUFTO0lBQ2xDLE9BQU84QixXQUFXbEMsOENBQWEsQ0FBQ0k7QUFDcEM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVM4QixXQUFXOUIsU0FBUztJQUNoQyxNQUFNLEVBQUVHLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdaLDhEQUFTQSxDQUFDc0MsU0FBUyxDQUFDQyxPQUFPLENBQUNwQyx5Q0FBUSxDQUFDSSxXQUFXaUIsS0FBSyxDQUFDO0lBQ3ZFLE9BQU87UUFBRWQ7UUFBR0U7SUFBRTtBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTdUIsV0FBVzVCLFNBQVM7SUFDaEMsT0FBTztRQUNIRyxHQUFHSCxVQUFVRyxDQUFDO1FBQ2RFLEdBQUdMLFVBQVVLLENBQUM7UUFDZEMsU0FBU2UsV0FBV3JCLFVBQVUyQixDQUFDO0lBQ25DO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVNELFFBQVExQixTQUFTO0lBQzdCLE1BQU1NLFVBQVUsQ0FBQztRQUNiLE1BQU1xQixJQUFJM0IsVUFBVTJCLENBQUMsR0FBR1QsT0FBT2xCLFVBQVUyQixDQUFDLElBQUlQO1FBQzlDLElBQUlkLFVBQVVOLFVBQVVNLE9BQU8sR0FBR1ksT0FBT2xCLFVBQVVNLE9BQU8sSUFBSWM7UUFDOUQsSUFBSSxPQUFPTyxNQUFNLFlBQVksT0FBT3JCLFlBQVksVUFDNUNBLFVBQVVlLFdBQVdNO1FBQ3pCLElBQUksT0FBT3JCLFlBQVksVUFDbkIsTUFBTSxJQUFJSyxvQkFBb0I7WUFBRUYsT0FBT1QsVUFBVU0sT0FBTztRQUFDO1FBQzdELE9BQU9BO0lBQ1g7SUFDQSxPQUFPO1FBQ0hILEdBQUdhLE9BQU9oQixVQUFVRyxDQUFDO1FBQ3JCRSxHQUFHVyxPQUFPaEIsVUFBVUssQ0FBQztRQUNyQkM7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBUzJCLFVBQVVDLEtBQUs7SUFDM0IsTUFBTSxDQUFDNUIsU0FBU0gsR0FBR0UsRUFBRSxHQUFHNkI7SUFDeEIsT0FBT1gsS0FBSztRQUNScEIsR0FBR0EsTUFBTSxPQUFPLEVBQUUsR0FBR2EsT0FBT2I7UUFDNUJFLEdBQUdBLE1BQU0sT0FBTyxFQUFFLEdBQUdXLE9BQU9YO1FBQzVCQyxTQUFTQSxZQUFZLE9BQU8sSUFBSVksT0FBT1o7SUFDM0M7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVM2QixRQUFRbkMsU0FBUztJQUM3QixPQUFPTiw4Q0FBYSxDQUFDMEMsTUFBTXBDO0FBQy9CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU29DLE1BQU1wQyxTQUFTO0lBQzNCRCxPQUFPQztJQUNQLE1BQU1HLElBQUlILFVBQVVHLENBQUM7SUFDckIsTUFBTUUsSUFBSUwsVUFBVUssQ0FBQztJQUNyQixNQUFNbUIsYUFBYTVCLDJDQUFVLENBQUNBLCtDQUFjLENBQUNPLEdBQUc7UUFBRW9DLE1BQU07SUFBRyxJQUFJM0MsK0NBQWMsQ0FBQ1MsR0FBRztRQUFFa0MsTUFBTTtJQUFHLElBQzVGLHlFQUF5RTtJQUN6RSxPQUFPdkMsVUFBVU0sT0FBTyxLQUFLLFdBQ3ZCViwrQ0FBYyxDQUFDNEMsV0FBV3hDLFVBQVVNLE9BQU8sR0FBRztRQUFFaUMsTUFBTTtJQUFFLEtBQ3hEO0lBQ04sT0FBT2Y7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTaUIsV0FBV3pDLFNBQVM7SUFDaEMsTUFBTTBDLE1BQU0sSUFBSWpELDhEQUFTQSxDQUFDc0MsU0FBUyxDQUFDL0IsVUFBVUcsQ0FBQyxFQUFFSCxVQUFVSyxDQUFDO0lBQzVELE9BQU9xQyxJQUFJQyxhQUFhO0FBQzVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNDLFNBQVM1QyxTQUFTO0lBQzlCLE1BQU0wQyxNQUFNLElBQUlqRCw4REFBU0EsQ0FBQ3NDLFNBQVMsQ0FBQy9CLFVBQVVHLENBQUMsRUFBRUgsVUFBVUssQ0FBQztJQUM1RCxPQUFPLEtBQW9CLE9BQWZxQyxJQUFJRyxRQUFRO0FBQzVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNDLFNBQVM5QyxTQUFTO0lBQzlCLE9BQU87UUFDSEcsR0FBR0gsVUFBVUcsQ0FBQztRQUNkRSxHQUFHTCxVQUFVSyxDQUFDO1FBQ2RzQixHQUFHYSxXQUFXeEMsVUFBVU0sT0FBTztJQUNuQztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTeUMsTUFBTS9DLFNBQVM7SUFDM0IsTUFBTSxFQUFFRyxDQUFDLEVBQUVFLENBQUMsRUFBRUMsT0FBTyxFQUFFLEdBQUdOO0lBQzFCLE9BQU87UUFDSEcsR0FBR1AsK0NBQWMsQ0FBQ08sR0FBRztZQUFFb0MsTUFBTTtRQUFHO1FBQ2hDbEMsR0FBR1QsK0NBQWMsQ0FBQ1MsR0FBRztZQUFFa0MsTUFBTTtRQUFHO1FBQ2hDakMsU0FBU0EsWUFBWSxJQUFJLFFBQVE7SUFDckM7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVMwQyxRQUFRaEQsU0FBUztJQUM3QixNQUFNLEVBQUVHLENBQUMsRUFBRUUsQ0FBQyxFQUFFQyxPQUFPLEVBQUUsR0FBR047SUFDMUIsT0FBTztRQUNITSxVQUFVLFNBQVM7UUFDbkJILE1BQU0sRUFBRSxHQUFHLE9BQU9QLDZDQUFZLENBQUNBLCtDQUFjLENBQUNPO1FBQzlDRSxNQUFNLEVBQUUsR0FBRyxPQUFPVCw2Q0FBWSxDQUFDQSwrQ0FBYyxDQUFDUztLQUNqRDtBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTNkMsU0FBU2xELFNBQVM7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUMzQyxJQUFJO1FBQ0FGLE9BQU9DLFdBQVdDO1FBQ2xCLE9BQU87SUFDWCxFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTb0IsV0FBV00sQ0FBQztJQUN4QixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sSUFDakIsT0FBTztJQUNYLElBQUlBLE1BQU0sS0FBS0EsTUFBTSxJQUNqQixPQUFPO0lBQ1gsSUFBSUEsS0FBSyxJQUNMLE9BQU9BLElBQUksTUFBTSxJQUFJLElBQUk7SUFDN0IsTUFBTSxJQUFJd0IsY0FBYztRQUFFMUMsT0FBT2tCO0lBQUU7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU2EsV0FBV2xDLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxHQUNaLE9BQU87SUFDWCxJQUFJQSxZQUFZLEdBQ1osT0FBTztJQUNYLE1BQU0sSUFBSUssb0JBQW9CO1FBQUVGLE9BQU9IO0lBQVE7QUFDbkQ7QUFDQSxnRUFBZ0UsR0FDekQsTUFBTVMsbUNBQW1DcEIsaURBQWdCO0lBQzVEMEQsWUFBWSxFQUFFckQsU0FBUyxFQUFFLENBQUU7UUFDdkIsS0FBSyxDQUFDLFVBQXFCLE9BQVZBLFdBQVUsb0NBQW1DO1lBQzFEc0QsY0FBYztnQkFDVjtnQkFDQyxZQUF5QyxPQUE5QjFELHlDQUFRLENBQUNBLHlDQUFRLENBQUNJLGFBQVk7YUFDN0M7UUFDTDtRQUNBdUQsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbEQsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLG9GQUFvRixHQUM3RSxNQUFNTCwrQkFBK0JULGlEQUFnQjtJQUN4RDBELFlBQVksRUFBRXJELFNBQVMsRUFBRSxDQUFFO1FBQ3ZCLEtBQUssQ0FBQyxjQUF5QyxPQUExQkgsK0NBQWMsQ0FBQ0csWUFBVztRQUMvQ3VELE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSx3REFBd0QsR0FDakQsTUFBTUQsc0JBQXNCYixpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsVUFBaUIsT0FBTkEsT0FBTTtRQUN2QjhDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSx3REFBd0QsR0FDakQsTUFBTUMsc0JBQXNCZixpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsVUFBaUIsT0FBTkEsT0FBTTtRQUN2QjhDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSw4REFBOEQsR0FDdkQsTUFBTUUsNEJBQTRCaEIsaURBQWdCO0lBQ3JEMEQsWUFBWSxFQUFFNUMsS0FBSyxFQUFFLENBQUU7UUFDbkIsS0FBSyxDQUFDLFVBQWlCLE9BQU5BLE9BQU07UUFDdkI4QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0Esd0RBQXdELEdBQ2pELE1BQU0wQyxzQkFBc0J4RCxpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsVUFBaUIsT0FBTkEsT0FBTTtRQUN2QjhDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaWduYXR1cmUuanM/ZWRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIFNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5hc3NlcnQoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBJbnZhbGlkU2lnbmF0dXJlUkVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgLTU0OS4uLm5gIGlzIGFuIGludmFsaWQgciB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByZWNvdmVyZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAocmVjb3ZlcmVkICYmIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChzaWduYXR1cmUuciA8IDBuIHx8IHNpZ25hdHVyZS5yID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnIgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5zIDwgMG4gfHwgc2lnbmF0dXJlLnMgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUucyB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMCAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheShbMTI4LCAzLCAxMzEsIC4uLl0pKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNIZXguSGV4fSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21IZXgoJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYycpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwICYmIHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMCwgMzIpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDMyLCA2NCkpO1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB5UGFyaXR5ID0gTnVtYmVyKGAweCR7c2lnbmF0dXJlLnNsaWNlKDEzMCl9YCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeVBhcml0eSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZUb1lQYXJpdHkoeVBhcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgaWYgKHR5cGVvZiB5UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzLFxuICAgICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gZnJvbSBhbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgbWF5IGluY2x1ZGUgc2lnbmF0dXJlIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5leHRyYWN0KHtcbiAqICAgYmF6OiAnYmFycnknLFxuICogICBmb286ICdiYXInLFxuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqICAgemVicmE6ICdzdHJpcGVzJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJiaXRyYXJ5IG9iamVjdCB0byBleHRyYWN0IHRoZSBzaWduYXR1cmUgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHR5cGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBvYmplY3QgZnJvbSBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSwge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MDEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBMZWdhY3lcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqICAgdjogMjcsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAvLyBAbG9nOiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdmFsdWUgdG8gaW5zdGFudGlhdGUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFudGlhdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tUnBjKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUudilcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGVnYWN5KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgeVBhcml0eTogc2lnbmF0dXJlLnlQYXJpdHkgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZV8pO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJCeXRlcyhuZXcgVWludDhBcnJheShbMTMyLCA1MSwgMjMsIC4uLl0pKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tRGVySGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJIZXgoJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbURFUihIZXguZnJvbShzaWduYXR1cmUpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4geyByLCBzIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUuZnJvbUxlZ2FjeSh7IHI6IDFuLCBzOiAybiwgdjogMjggfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB5UGFyaXR5OiB2VG9ZUGFyaXR5KHNpZ25hdHVyZS52KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ScGMoe1xuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUudiA/IE51bWJlcihzaWduYXR1cmUudikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB5UGFyaXR5ID0gc2lnbmF0dXJlLnlQYXJpdHkgPyBOdW1iZXIoc2lnbmF0dXJlLnlQYXJpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInICYmIHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHlQYXJpdHkgPSB2VG9ZUGFyaXR5KHYpO1xuICAgICAgICBpZiAodHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG4gICAgICAgIHJldHVybiB5UGFyaXR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogQmlnSW50KHNpZ25hdHVyZS5yKSxcbiAgICAgICAgczogQmlnSW50KHNpZ25hdHVyZS5zKSxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21UdXBsZShbJzB4MDEnLCAnMHg3YicsICcweDFjOCddKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiAxMjNuLFxuICogLy8gQGxvZzogICBzOiA0NTZuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW3lQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICByOiByID09PSAnMHgnID8gMG4gOiBCaWdJbnQociksXG4gICAgICAgIHM6IHMgPT09ICcweCcgPyAwbiA6IEJpZ0ludChzKSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoeVBhcml0eSksXG4gICAgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0J5dGVzKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMDIsIDE2LCAxMCwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9IZXgoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6ICcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlKTtcbiAgICBjb25zdCByID0gc2lnbmF0dXJlLnI7XG4gICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBIZXguY29uY2F0KEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksIFxuICAgIC8vIElmIHRoZSBzaWduYXR1cmUgaXMgcmVjb3ZlcmVkLCBhZGQgdGhlIHJlY292ZXJ5IGJ5dGUgdG8gdGhlIHNpZ25hdHVyZS5cbiAgICB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInXG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIoeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksIHsgc2l6ZTogMSB9KVxuICAgICAgICA6ICcweCcpO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVyQnl0ZXMoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTMyLCA1MSwgMjMsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBzaWcudG9ERVJSYXdCeXRlcygpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVySGV4KHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6ICcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBgMHgke3NpZy50b0RFUkhleCgpfWA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUudG9MZWdhY3koeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHY6IHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9ScGMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHM6IEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09IDAgPyAnMHgwJyA6ICcweDEnLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGEgc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBiZSB1c2VkIGZvciBzaWduYXR1cmVzIGluIFRyYW5zYWN0aW9uIEVudmVsb3BlcywgRUlQLTc3MDIgQXV0aG9yaXphdGlvbiBMaXN0cywgZXRjLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlVHVwbGUgPSBTaWduYXR1cmUudG9UdXBsZSh7XG4gKiAgIHI6IDEyM24sXG4gKiAgIHM6IDQ1Nm4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogW3lQYXJpdHk6ICcweDAxJywgcjogJzB4N2InLCBzOiAnMHgxYzgnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeVBhcml0eSA/ICcweDAxJyA6ICcweCcsXG4gICAgICAgIHIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihyKSksXG4gICAgICAgIHMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzKSksXG4gICAgXTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlLnZhbGlkYXRlKHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB5UGFyaXR5ID0gU2lnbmF0dXJlLnZUb1lQYXJpdHkoMjgpXG4gKiAvLyBAbG9nOiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSBFQ0RTQSBgdmAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgeVBhcml0eWAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2VG9ZUGFyaXR5KHYpIHtcbiAgICBpZiAodiA9PT0gMCB8fCB2ID09PSAyNylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHYgPT09IDEgfHwgdiA9PT0gMjgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh2ID49IDM1KVxuICAgICAgICByZXR1cm4gdiAlIDIgPT09IDAgPyAxIDogMDtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFZFcnJvcih7IHZhbHVlOiB2IH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHYgPSBTaWduYXR1cmUueVBhcml0eVRvVigxKVxuICogLy8gQGxvZzogMjhcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB5UGFyaXR5IC0gVGhlIEVDRFNBIGB5UGFyaXR5YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB2YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlQYXJpdHlUb1YoeVBhcml0eSkge1xuICAgIGlmICh5UGFyaXR5ID09PSAwKVxuICAgICAgICByZXR1cm4gMjc7XG4gICAgaWYgKHlQYXJpdHkgPT09IDEpXG4gICAgICAgIHJldHVybiAyODtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xufVxuLyoqIFRocm93biB3aGVuIHRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZSBpcyBvZiBhbiBpbnZhbGlkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3NpZ25hdHVyZX1cXGAgaXMgYW4gaW52YWxpZCBzaWduYXR1cmUgc2l6ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQ6IDY0IGJ5dGVzIG9yIDY1IGJ5dGVzLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20oc2lnbmF0dXJlKSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaXMgbWlzc2luZyBlaXRoZXIgYW4gYHJgLCBgc2AsIG9yIGB5UGFyaXR5YCBwcm9wZXJ0eS4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nUHJvcGVydGllc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgU2lnbmF0dXJlIFxcYCR7SnNvbi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1cXGAgaXMgbWlzc2luZyBlaXRoZXIgYW4gXFxgclxcYCwgXFxgc1xcYCwgb3IgXFxgeVBhcml0eVxcYCBwcm9wZXJ0eS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5NaXNzaW5nUHJvcGVydGllc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgcmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCByIHZhbHVlLiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkUkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgc2AgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBzIHZhbHVlLiBzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgeVBhcml0eWAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFlQYXJpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB5LXBhcml0eSB2YWx1ZS4gWS1wYXJpdHkgbXVzdCBiZSAwIG9yIDEuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFlQYXJpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHZgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRWRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgdiB2YWx1ZS4gdiBtdXN0IGJlIDI3LCAyOCBvciA+PTM1LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRWRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiU29saWRpdHkiLCJhc3NlcnQiLCJzaWduYXR1cmUiLCJvcHRpb25zIiwicmVjb3ZlcmVkIiwiciIsIk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IiLCJzIiwieVBhcml0eSIsIm1heFVpbnQyNTYiLCJJbnZhbGlkUkVycm9yIiwidmFsdWUiLCJJbnZhbGlkU0Vycm9yIiwiSW52YWxpZFlQYXJpdHlFcnJvciIsImZyb21CeXRlcyIsImZyb21IZXgiLCJsZW5ndGgiLCJJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciIsIkJpZ0ludCIsInNsaWNlIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmRlZmluZWQiLCJ2VG9ZUGFyaXR5IiwiZXh0cmFjdCIsImZyb20iLCJzaWduYXR1cmVfIiwiVWludDhBcnJheSIsImZyb21ScGMiLCJ2IiwiZnJvbUxlZ2FjeSIsImZyb21EZXJCeXRlcyIsImZyb21EZXJIZXgiLCJTaWduYXR1cmUiLCJmcm9tREVSIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ0b0J5dGVzIiwidG9IZXgiLCJjb25jYXQiLCJmcm9tTnVtYmVyIiwic2l6ZSIsInlQYXJpdHlUb1YiLCJ0b0RlckJ5dGVzIiwic2lnIiwidG9ERVJSYXdCeXRlcyIsInRvRGVySGV4IiwidG9ERVJIZXgiLCJ0b0xlZ2FjeSIsInRvUnBjIiwidG9UdXBsZSIsInRyaW1MZWZ0IiwidmFsaWRhdGUiLCJJbnZhbGlkVkVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelope.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: function() { return /* binding */ FeeCapTooHighError; },\n/* harmony export */   GasPriceTooHighError: function() { return /* binding */ GasPriceTooHighError; },\n/* harmony export */   InvalidChainIdError: function() { return /* binding */ InvalidChainIdError; },\n/* harmony export */   InvalidSerializedError: function() { return /* binding */ InvalidSerializedError; },\n/* harmony export */   TipAboveFeeCapError: function() { return /* binding */ TipAboveFeeCapError; }\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap } = {}){\n        super(\"The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas`\".concat(feeCap ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap), \" gwei\") : \"\", \") cannot be higher than the maximum allowed value (2^256-1).\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.FeeCapTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice } = {}){\n        super(\"The gas price (`gasPrice`\".concat(gasPrice ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice), \" gwei\") : \"\", \") cannot be higher than the maximum allowed value (2^256-1).\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.GasPriceTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */ class InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }){\n        super(typeof chainId !== \"undefined\" ? 'Chain ID \"'.concat(chainId, '\" is invalid.') : \"Chain ID is invalid.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidChainIdError\"\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */ class InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type }){\n        const missing = Object.entries(attributes).map((param)=>{\n            let [key, value] = param;\n            return typeof value === \"undefined\" ? key : undefined;\n        }).filter(Boolean);\n        super('Invalid serialized transaction of type \"'.concat(type, '\" was provided.'), {\n            metaMessages: [\n                'Serialized Transaction: \"'.concat(serialized, '\"'),\n                missing.length > 0 ? \"Missing Attributes: \".concat(missing.join(\", \")) : \"\"\n            ].filter(Boolean)\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidSerializedError\"\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */ class TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}){\n        super([\n            \"The provided tip (`maxPriorityFeePerGas`\".concat(maxPriorityFeePerGas ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas), \" gwei\") : \"\", \") cannot be higher than the fee cap (`maxFeePerGas`\").concat(maxFeePerGas ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas), \" gwei\") : \"\", \").\")\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.TipAboveFeeCapError\"\n        });\n    }\n} //# sourceMappingURL=TransactionEnvelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNDO0FBQ0Y7QUFDcEM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1FLDJCQUEyQkYsaURBQWdCO0lBQ3BESSxZQUFZLEVBQUVDLE1BQU0sRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzFCLEtBQUssQ0FBQyxxREFBNkcsT0FBcERBLFNBQVMsTUFBK0IsT0FBekJKLGlEQUFnQixDQUFDSSxTQUFRLFdBQVMsSUFBRztRQUNuSEUsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1DLDZCQUE2QmIsaURBQWdCO0lBQ3RESSxZQUFZLEVBQUVVLFFBQVEsRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzVCLEtBQUssQ0FBQyw0QkFBc0YsT0FBeERBLFdBQVcsTUFBaUMsT0FBM0JiLGlEQUFnQixDQUFDYSxXQUFVLFdBQVMsSUFBRztRQUM1RlAsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1HLDRCQUE0QmYsaURBQWdCO0lBQ3JESSxZQUFZLEVBQUVZLE9BQU8sRUFBRSxDQUFFO1FBQ3JCLEtBQUssQ0FBQyxPQUFPQSxZQUFZLGNBQ25CLGFBQXFCLE9BQVJBLFNBQVEsbUJBQ3JCO1FBQ05ULE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1LLCtCQUErQmpCLGlEQUFnQjtJQUN4REksWUFBWSxFQUFFYyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDM0MsTUFBTUMsVUFBVWQsT0FBT2UsT0FBTyxDQUFDSixZQUMxQkssR0FBRyxDQUFDO2dCQUFDLENBQUNDLEtBQUtaLE1BQU07bUJBQU0sT0FBT0EsVUFBVSxjQUFjWSxNQUFNQztXQUM1REMsTUFBTSxDQUFDQztRQUNaLEtBQUssQ0FBQywyQ0FBZ0QsT0FBTFAsTUFBSyxvQkFBa0I7WUFDcEVRLGNBQWM7Z0JBQ1QsNEJBQXNDLE9BQVhULFlBQVc7Z0JBQ3ZDRSxRQUFRUSxNQUFNLEdBQUcsSUFBSSx1QkFBMEMsT0FBbkJSLFFBQVFTLElBQUksQ0FBQyxTQUFVO2FBQ3RFLENBQUNKLE1BQU0sQ0FBQ0M7UUFDYjtRQUNBcEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNbUIsNEJBQTRCL0IsaURBQWdCO0lBQ3JESSxZQUFZLEVBQUU0QixvQkFBb0IsRUFBRUMsWUFBWSxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEQsS0FBSyxDQUFDO1lBQ0QsMkNBRStEQSxPQUZuQkQsdUJBQ3ZDLE1BQTZDLE9BQXZDL0IsaURBQWdCLENBQUMrQix1QkFBc0IsV0FDN0MsSUFBRyx1REFBdUgsT0FBaEVDLGVBQWUsTUFBcUMsT0FBL0JoQyxpREFBZ0IsQ0FBQ2dDLGVBQWMsV0FBUyxJQUFHO1NBQ25JLENBQUNILElBQUksQ0FBQztRQUNQdkIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZS5qcz8yMjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBWYWx1ZSBmcm9tICcuL1ZhbHVlLmpzJztcbi8qKlxuICogVGhyb3duIHdoZW4gYSBmZWUgY2FwIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3I6IFRoZSBmZWUgY2FwIChgbWF4RmVlUGVyR2FzYC9gbWF4UHJpb3JpdHlGZWVQZXJHYXNgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzLjEyOTYzOTkzNiBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZlZUNhcFRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZmVlQ2FwLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoYFRoZSBmZWUgY2FwIChcXGBtYXhGZWVQZXJHYXNcXGAvXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke2ZlZUNhcCA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkoZmVlQ2FwKX0gZ3dlaWAgOiAnJ30pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuRmVlQ2FwVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgZ2FzIHByaWNlIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMy4xMjk2Mzk5MzYgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNQcmljZVRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2FzUHJpY2UsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihgVGhlIGdhcyBwcmljZSAoXFxgZ2FzUHJpY2VcXGAke2dhc1ByaWNlID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShnYXNQcmljZSl9IGd3ZWlgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgY2hhaW4gSUQgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHsgY2hhaW5JZDogMCB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3I6IENoYWluIElEIFwiMFwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGFpbklkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQgfSkge1xuICAgICAgICBzdXBlcih0eXBlb2YgY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gYENoYWluIElEIFwiJHtjaGFpbklkfVwiIGlzIGludmFsaWQuYFxuICAgICAgICAgICAgOiAnQ2hhaW4gSUQgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJjMCcpXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcjogSW52YWxpZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgXCJlaXAxNTU5XCIgd2FzIHByb3ZpZGVkLlxuICogLy8gQGVycm9yOiBTZXJpYWxpemVkIFRyYW5zYWN0aW9uOiBcIjB4MDJjMFwiXG4gKiAvLyBAZXJyb3I6IE1pc3NpbmcgQXR0cmlidXRlczogY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGF0dHJpYnV0ZXMsIHNlcmlhbGl6ZWQsIHR5cGUsIH0pIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8ga2V5IDogdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb2YgdHlwZSBcIiR7dHlwZX1cIiB3YXMgcHJvdmlkZWQuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFNlcmlhbGl6ZWQgVHJhbnNhY3Rpb246IFwiJHtzZXJpYWxpemVkfVwiYCxcbiAgICAgICAgICAgICAgICBtaXNzaW5nLmxlbmd0aCA+IDAgPyBgTWlzc2luZyBBdHRyaWJ1dGVzOiAke21pc3Npbmcuam9pbignLCAnKX1gIDogJycsXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB0aXAgaXMgaGlnaGVyIHRoYW4gYSBmZWUgY2FwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IDEwbixcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDExbixcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuVGlwQWJvdmVGZWVDYXBFcnJvcjogVGhlIHByb3ZpZGVkIHRpcCAoYG1heFByaW9yaXR5RmVlUGVyR2FzYCA9IDExIGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgZmVlIGNhcCAoYG1heEZlZVBlckdhc2AgPSAxMCBnd2VpKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVGlwQWJvdmVGZWVDYXBFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIGBUaGUgcHJvdmlkZWQgdGlwIChcXGBtYXhQcmlvcml0eUZlZVBlckdhc1xcYCR7bWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkobWF4UHJpb3JpdHlGZWVQZXJHYXMpfSBnd2VpYFxuICAgICAgICAgICAgICAgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIGZlZSBjYXAgKFxcYG1heEZlZVBlckdhc1xcYCR7bWF4RmVlUGVyR2FzID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShtYXhGZWVQZXJHYXMpfSBnd2VpYCA6ICcnfSkuYCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uRW52ZWxvcGUuanMubWFwIl0sIm5hbWVzIjpbIkVycm9ycyIsIlZhbHVlIiwiRmVlQ2FwVG9vSGlnaEVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJmZWVDYXAiLCJmb3JtYXRHd2VpIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIkdhc1ByaWNlVG9vSGlnaEVycm9yIiwiZ2FzUHJpY2UiLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwiY2hhaW5JZCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwic2VyaWFsaXplZCIsInR5cGUiLCJtaXNzaW5nIiwiZW50cmllcyIsIm1hcCIsImtleSIsInVuZGVmaW5lZCIsImZpbHRlciIsIkJvb2xlYW4iLCJtZXRhTWVzc2FnZXMiLCJsZW5ndGgiLCJqb2luIiwiVGlwQWJvdmVGZWVDYXBFcnJvciIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = \"0x02\";\nconst type = \"eip1559\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope;\n    if (chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({\n        chainId\n    });\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, {\n        strict: false\n    });\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.FeeCapTooHighError({\n        feeCap: maxFeePerGas\n    });\n    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.TipAboveFeeCapError({\n        maxFeePerGas,\n        maxPriorityFeePerGas\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            maxPriorityFeePerGas,\n            maxFeePerGas,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            ...transactionArray.length > 9 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== \"0x\") transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== \"0x\") transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TransactionEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {},\n        type: \"eip1559\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} to an {@link ox#TransactionEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        type: \"0x2\",\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.maxFeePerGas === \"bigint\" ? {\n            maxFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxFeePerGas)\n        } : {},\n        ...typeof envelope.maxPriorityFeePerGas === \"bigint\" ? {\n            maxPriorityFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxPriorityFeePerGas)\n        } : {},\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip1559.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pELE1BQU1PLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0IsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLG9CQUFvQixFQUFFQyxZQUFZLEVBQUVDLEVBQUUsRUFBRSxHQUFHSjtJQUM1RCxJQUFJQyxXQUFXLEdBQ1gsTUFBTSxJQUFJTCx3RUFBdUMsQ0FBQztRQUFFSztJQUFRO0lBQ2hFLElBQUlHLElBQ0FiLCtDQUFjLENBQUNhLElBQUk7UUFBRUUsUUFBUTtJQUFNO0lBQ3ZDLElBQUlILGdCQUFnQkksT0FBT0osZ0JBQWdCLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxFQUN0RCxNQUFNLElBQUlQLHVFQUFzQyxDQUFDO1FBQUVhLFFBQVFOO0lBQWE7SUFDNUUsSUFBSUQsd0JBQ0FDLGdCQUNBRCx1QkFBdUJDLGNBQ3ZCLE1BQU0sSUFBSVAsd0VBQXVDLENBQUM7UUFDOUNPO1FBQ0FEO0lBQ0o7QUFDUjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLFNBQVNTLFlBQVlDLFVBQVU7SUFDbEMsTUFBTUMsbUJBQW1CbkIsMENBQVMsQ0FBQ0QsMENBQVMsQ0FBQ21CLFlBQVk7SUFDekQsTUFBTSxDQUFDWCxTQUFTZSxPQUFPZCxzQkFBc0JDLGNBQWNjLEtBQUtiLElBQUljLE9BQU9DLE1BQU1DLFlBQVlDLFNBQVNDLEdBQUdDLEVBQUcsR0FBR1Y7SUFDL0csSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJXLE1BQU0sS0FBSyxLQUFLWCxpQkFBaUJXLE1BQU0sS0FBSyxFQUFD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Q08sU0FBU2lCLEdBQUc7UUFBRSxJQUNwQyxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9qQixTQUFTZ0IsS0FBSyxLQUFLLFdBQ3hCO1lBQUVBLE9BQU92QiwrQ0FBYyxDQUFDTyxTQUFTZ0IsS0FBSztRQUFFLElBQ3hDLENBQUMsQ0FBQztRQUNSLEdBQUksT0FBT2hCLFNBQVNrQixLQUFLLEtBQUssV0FDeEI7WUFBRUEsT0FBT3pCLCtDQUFjLENBQUNPLFNBQVNrQixLQUFLO1FBQUUsSUFDeEMsQ0FBQyxDQUFDO1FBQ1IsR0FBSSxPQUFPbEIsU0FBU0csWUFBWSxLQUFLLFdBQy9CO1lBQUVBLGNBQWNWLCtDQUFjLENBQUNPLFNBQVNHLFlBQVk7UUFBRSxJQUN0RCxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9ILFNBQVNFLG9CQUFvQixLQUFLLFdBQ3ZDO1lBQ0VBLHNCQUFzQlQsK0NBQWMsQ0FBQ08sU0FBU0Usb0JBQW9CO1FBQ3RFLElBQ0UsQ0FBQyxDQUFDO1FBQ1IsR0FBSTZCLFlBQVlwQyxnREFBZSxDQUFDb0MsYUFBYSxDQUFDLENBQUM7SUFDbkQ7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNGLFNBQVM3QixRQUFRO0lBQzdCLElBQUk7UUFDQUQsT0FBT0M7UUFDUCxPQUFPO0lBQ1gsRUFDQSxVQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0osRUFDQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcz9hYzkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFjY2Vzc0xpc3QgZnJvbSAnLi9BY2Nlc3NMaXN0LmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGUgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlLmpzJztcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVkVHlwZSA9ICcweDAyJztcbmV4cG9ydCBjb25zdCB0eXBlID0gJ2VpcDE1NTknO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogRmVlQ2FwVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZmVlIGNhcCAoYG1hc0ZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmIChjaGFpbklkIDw9IDApXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAobWF4RmVlUGVyR2FzICYmIEJpZ0ludChtYXhGZWVQZXJHYXMpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3IoeyBmZWVDYXA6IG1heEZlZVBlckdhcyB9KTtcbiAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4RmVlUGVyR2FzICYmXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID4gbWF4RmVlUGVyR2FzKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yKHtcbiAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBmcm9tIGl0cyBzZXJpYWxpemVkIGZvcm0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIHlQYXJpdHksIHIsIHMsXSA9IHRyYW5zYWN0aW9uQXJyYXk7XG4gICAgaWYgKCEodHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDkgfHwgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDEyKSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICAuLi4odHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPiA5XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeVBhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4RmVlUGVyR2FzKSAmJiBtYXhGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyA9IEJpZ0ludChtYXhGZWVQZXJHYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMpICYmIG1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKGFjY2Vzc0xpc3QubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHkgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC0xNTU5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAxNTU5JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSgnMHgwMmY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDE1NTknLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAxNTU5JyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS4gVGhpcyBpcyB0aGUgXCJ0cmFuc2FjdGlvbiBoYXNoXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Lmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEsIGlucHV0LCB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIG1heEZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heEZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBnYXMgPyBIZXguZnJvbU51bWJlcihnYXMpIDogJzB4JyxcbiAgICAgICAgdG8gPz8gJzB4JyxcbiAgICAgICAgdmFsdWUgPyBIZXguZnJvbU51bWJlcih2YWx1ZSkgOiAnMHgnLFxuICAgICAgICBkYXRhID8/IGlucHV0ID8/ICcweCcsXG4gICAgICAgIGFjY2Vzc1R1cGxlTGlzdCxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkVHlwZSwgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIHR5cGU6ICcweDInLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLmdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubm9uY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgbm9uY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm5vbmNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS52YWx1ZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyB2YWx1ZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUudmFsdWUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm1heEZlZVBlckdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBtYXhGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm1heEZlZVBlckdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMubWFwIl0sIm5hbWVzIjpbIkFjY2Vzc0xpc3QiLCJBZGRyZXNzIiwiSGFzaCIsIkhleCIsIlJscCIsIlNpZ25hdHVyZSIsIlRyYW5zYWN0aW9uRW52ZWxvcGUiLCJzZXJpYWxpemVkVHlwZSIsInR5cGUiLCJhc3NlcnQiLCJlbnZlbG9wZSIsImNoYWluSWQiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsInRvIiwiSW52YWxpZENoYWluSWRFcnJvciIsInN0cmljdCIsIkJpZ0ludCIsIkZlZUNhcFRvb0hpZ2hFcnJvciIsImZlZUNhcCIsIlRpcEFib3ZlRmVlQ2FwRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwiZ2FzIiwidmFsdWUiLCJkYXRhIiwiYWNjZXNzTGlzdCIsInlQYXJpdHkiLCJyIiwicyIsImxlbmd0aCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwidHJhbnNhY3Rpb24iLCJOdW1iZXIiLCJ2YWxpZGF0ZSIsImZyb21UdXBsZUxpc3QiLCJzaWduYXR1cmUiLCJmcm9tVHVwbGUiLCJ1bmRlZmluZWQiLCJmcm9tIiwib3B0aW9ucyIsImVudmVsb3BlXyIsImdldFNpZ25QYXlsb2FkIiwiaGFzaCIsInByZXNpZ24iLCJrZWNjYWsyNTYiLCJzZXJpYWxpemUiLCJ2IiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImV4dHJhY3QiLCJmcm9tTnVtYmVyIiwidG9UdXBsZSIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1JwYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = \"0x01\";\nconst type = \"eip2930\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({\n        chainId\n    });\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, {\n        strict: false\n    });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.GasPriceTooHighError({\n        gasPrice\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            gasPrice,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            ...transactionArray.length > 8 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== \"0x\") transaction.gasPrice = BigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {},\n        type: \"eip2930\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(\"0x01\", _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.gasPrice === \"bigint\" ? {\n            gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice)\n        } : {},\n        type: \"0x1\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip2930.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pELE1BQU1PLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0IsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsRUFBRSxFQUFFLEdBQUdIO0lBQ2xDLElBQUlDLFdBQVcsR0FDWCxNQUFNLElBQUlMLHdFQUF1QyxDQUFDO1FBQUVLO0lBQVE7SUFDaEUsSUFBSUUsSUFDQVosK0NBQWMsQ0FBQ1ksSUFBSTtRQUFFRSxRQUFRO0lBQU07SUFDdkMsSUFBSUgsWUFBWUksT0FBT0osWUFBWSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsRUFDOUMsTUFBTSxJQUFJTix5RUFBd0MsQ0FBQztRQUFFTTtJQUFTO0FBQ3RFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU00sWUFBWUMsVUFBVTtJQUNsQyxNQUFNQyxtQkFBbUJoQiwwQ0FBUyxDQUFDRCwwQ0FBUyxDQUFDZ0IsWUFBWTtJQUN6RCxNQUFNLENBQUNSLFNBQVNZLE9BQU9YLFVBQVVZLEtBQUtYLElBQUlZLE9BQU9DLE1BQU1DLFlBQVlDLFNBQVNDLEdBQUdDLEVBQUcsR0FBR1Y7SUFDckYsSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJXLE1BQU0sS0FBSyxLQUFLWCxpQkFBaUJXLE1BQU0sS0FBSyxFQUFDLEdBQ2hFLE1BQU0sSUFBSXpCLDJFQUEwQyxDQUFDO1FBQ2pEMkIsWUFBWTtZQUNSdEI7WUFDQVk7WUFDQVg7WUFDQVk7WUFDQVg7WUFDQVk7WUFDQUM7WUFDQUM7WUFDQSxHQUFJUCxpQkFBaUJX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QUFFQSxVQUFVVCwrQ0FBYyxDQUFDTyxTQUFTRSxRQUFRO1FBQUUsSUFDOUMsQ0FBQyxDQUFDO1FBQ1JKLE1BQU07UUFDTixHQUFJOEIsWUFBWWpDLGdEQUFlLENBQUNpQyxhQUFhLENBQUMsQ0FBQztJQUNuRDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU0YsU0FBUzFCLFFBQVE7SUFDN0IsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSixFQUNBLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmpzPzYwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZWRUeXBlID0gJzB4MDEnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnZWlwMjkzMCc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEdhc1ByaWNlVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZ2FzIHByaWNlIChgZ2FzUHJpY2VgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzIGd3ZWkpIGNhbm5vdCBiZVxuICogLy8gQGVycm9yOiBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhc1ByaWNlLCB0byB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKHRvKVxuICAgICAgICBBZGRyZXNzLmFzc2VydCh0bywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGlmIChnYXNQcmljZSAmJiBCaWdJbnQoZ2FzUHJpY2UpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcih7IGdhc1ByaWNlIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5kZXNlcmlhbGl6ZSgnMHgwMWVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCwgeVBhcml0eSwgciwgcyxdID0gdHJhbnNhY3Rpb25BcnJheTtcbiAgICBpZiAoISh0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gOCB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTEpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gOFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSk7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHRvKSAmJiB0byAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSB0bztcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhcykgJiYgZ2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBCaWdJbnQoZ2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGRhdGEpICYmIGRhdGEgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBkYXRhO1xuICAgIGlmIChIZXgudmFsaWRhdGUobm9uY2UpICYmIG5vbmNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhc1ByaWNlKSAmJiBnYXNQcmljZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzUHJpY2UgPSBCaWdJbnQoZ2FzUHJpY2UpO1xuICAgIGlmIChhY2Nlc3NMaXN0Lmxlbmd0aCAhPT0gMCAmJiBhY2Nlc3NMaXN0ICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHIgJiYgcyAmJiB5UGFyaXR5ID8gU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmUpXG4gICAgICAgIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYWNjZXNzTGlzdDogWy4uLl0sXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBnYXNQcmljZTogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSgnMHgwMWY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDI5MzAnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAyOTMwJyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwge1xuICogICBzaWduYXR1cmUsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5oYXNoKGVudmVsb3BlX3NpZ25lZCkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIEVJUC0yOTMwIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIGhhc2guXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ocHJlc2lnblxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBhY2Nlc3NMaXN0LCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIHJldHVybiBIZXguY29uY2F0KCcweDAxJywgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMjAnKSxcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5ub25jZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBub25jZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubm9uY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLnZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IHZhbHVlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS52YWx1ZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzUHJpY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzUHJpY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhc1ByaWNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgdHlwZTogJzB4MScsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5qcy5tYXAiXSwibmFtZXMiOlsiQWNjZXNzTGlzdCIsIkFkZHJlc3MiLCJIYXNoIiwiSGV4IiwiUmxwIiwiU2lnbmF0dXJlIiwiVHJhbnNhY3Rpb25FbnZlbG9wZSIsInNlcmlhbGl6ZWRUeXBlIiwidHlwZSIsImFzc2VydCIsImVudmVsb3BlIiwiY2hhaW5JZCIsImdhc1ByaWNlIiwidG8iLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwic3RyaWN0IiwiQmlnSW50IiwiR2FzUHJpY2VUb29IaWdoRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwiZ2FzIiwidmFsdWUiLCJkYXRhIiwiYWNjZXNzTGlzdCIsInlQYXJpdHkiLCJyIiwicyIsImxlbmd0aCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwidHJhbnNhY3Rpb24iLCJOdW1iZXIiLCJ2YWxpZGF0ZSIsImZyb21UdXBsZUxpc3QiLCJzaWduYXR1cmUiLCJmcm9tVHVwbGUiLCJ1bmRlZmluZWQiLCJmcm9tIiwib3B0aW9ucyIsImVudmVsb3BlXyIsImdldFNpZ25QYXlsb2FkIiwiaGFzaCIsInByZXNpZ24iLCJrZWNjYWsyNTYiLCJzZXJpYWxpemUiLCJ2IiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImV4dHJhY3QiLCJmcm9tTnVtYmVyIiwidG9UdXBsZSIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1JwYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Authorization.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TransactionEnvelopeEip1559.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n\n\n\n\n\n\n\n\n\nconst serializedType = \"0x04\";\nconst type = \"eip7702\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { authorizationList } = envelope;\n    if (authorizationList) {\n        for (const authorization of authorizationList){\n            const { address, chainId } = authorization;\n            if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n                strict: false\n            });\n            if (Number(chainId) < 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({\n                chainId\n            });\n        }\n    }\n    _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_4__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 10 || transactionArray.length === 13)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            maxPriorityFeePerGas,\n            maxFeePerGas,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            authorizationList,\n            ...transactionArray.length > 9 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxFeePerGas) && maxFeePerGas !== \"0x\") transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== \"0x\") transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(accessList);\n    if (authorizationList !== \"0x\") transaction.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.fromTupleList(authorizationList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.from(signature) : {},\n        type: \"eip7702\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_8__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(accessList);\n    const authorizationTupleList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.toTupleList(authorizationList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(nonce) : \"0x\",\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxFeePerGas) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        authorizationTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_4__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip7702.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ047QUFDWTtBQUNsQjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUNjO0FBQ3ZFLE1BQU1TLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FDTSxTQUFTQyxPQUFPQyxRQUFRO0lBQzNCLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUUsR0FBR0Q7SUFDOUIsSUFBSUMsbUJBQW1CO1FBQ25CLEtBQUssTUFBTUMsaUJBQWlCRCxrQkFBbUI7WUFDM0MsTUFBTSxFQUFFRSxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtZQUM3QixJQUFJQyxTQUNBZCwrQ0FBYyxDQUFDYyxTQUFTO2dCQUFFRSxRQUFRO1lBQU07WUFDNUMsSUFBSUMsT0FBT0YsV0FBVyxHQUNsQixNQUFNLElBQUlULHdFQUF1QyxDQUFDO2dCQUFFUztZQUFRO1FBQ3BFO0lBQ0o7SUFDQVIsa0VBQWlDLENBQUNJO0FBQ3RDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNRLFlBQVlDLFVBQVU7SUFDbEMsTUFBTUMsbUJBQW1CakIsMENBQVMsQ0FBQ0QsMENBQVMsQ0FBQ2lCLFlBQVk7SUFDekQsTUFBTSxDQUFDTCxTQUFTUyxPQUFPQyxzQkFBc0JDLGNBQWNDLEtBQUtDLElBQUlDLE9BQU9DLE1BQU1DLFlBQVluQixtQkFBbUJvQixTQUFTQyxHQUFHQyxFQUFHLEdBQUdiO0lBQ2xJLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCYyxNQUFNLEtBQUssTUFBTWQsaUJBQWlCYyxNQUFNLEtBQUssRUFBQyxHQUNqRSxNQUFNLElBQUk3QiwyRUFBMEMsQ0FBQztRQUNqRCtCLFlBQVk7WUFDUnRCO1lBQ0FTO1lB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TUFBTSxFQUFFbEMsaUJBQWlCLEVBQUVHLE9BQU8sRUFBRVksR0FBRyxFQUFFSCxLQUFLLEVBQUVJLEVBQUUsRUFBRUMsS0FBSyxFQUFFSCxZQUFZLEVBQUVELG9CQUFvQixFQUFFTSxVQUFVLEVBQUVELElBQUksRUFBRXVCLEtBQUssRUFBRyxHQUFHMUM7SUFDNUhELE9BQU9DO0lBQ1AsTUFBTTJDLGtCQUFrQnZELHVEQUFzQixDQUFDZ0M7SUFDL0MsTUFBTXlCLHlCQUF5QnZELDBEQUF5QixDQUFDVztJQUN6RCxNQUFNOEIsWUFBWXJDLGtEQUFpQixDQUFDeUMsUUFBUUosU0FBUyxJQUFJL0I7UUFTckRtQjtJQVJKLE1BQU1WLGFBQWE7UUFDZmpCLCtDQUFjLENBQUNZO1FBQ2ZTLFFBQVFyQiwrQ0FBYyxDQUFDcUIsU0FBUztRQUNoQ0MsdUJBQXVCdEIsK0NBQWMsQ0FBQ3NCLHdCQUF3QjtRQUM5REMsZUFBZXZCLCtDQUFjLENBQUN1QixnQkFBZ0I7UUFDOUNDLE1BQU14QiwrQ0FBYyxDQUFDd0IsT0FBTztRQUM1QkMsZUFBQUEsZ0JBQUFBLEtBQU07UUFDTkMsUUFBUTFCLCtDQUFjLENBQUMwQixTQUFTO1FBQ2hDQyxDQUFBQSxPQUFBQSxpQkFBQUEsa0JBQUFBLE9BQVF1QixtQkFBUnZCLGtCQUFBQSxPQUFpQjtRQUNqQndCO1FBQ0FFO1dBQ0lkLFlBQVlyQyxrREFBaUIsQ0FBQ3FDLGFBQWEsRUFBRTtLQUNwRDtJQUNELE9BQU92QywyQ0FBVSxDQUFDSyxnQkFBZ0JKLDRDQUFXLENBQUNnQjtBQUNsRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTbUIsU0FBUzVCLFFBQVE7SUFDN0IsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSixFQUNBLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmpzP2I1ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcyc7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplZFR5cGUgPSAnMHgwNCc7XG5leHBvcnQgY29uc3QgdHlwZSA9ICdlaXA3NzAyJztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5hc3NlcnQoe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogW10sXG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogRmVlQ2FwVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZmVlIGNhcCAoYG1hc0ZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbkxpc3QgfSA9IGVudmVsb3BlO1xuICAgIGlmIChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKVxuICAgICAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIoY2hhaW5JZCkgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydChlbnZlbG9wZSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmRlc2VyaWFsaXplKCcweDA0ZWYwMTgyMDMxMTg0NzczNTk0MDA4NDc3MzU5NDAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIGF1dGhvcml6YXRpb25MaXN0LCB5UGFyaXR5LCByLCBzLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGlmICghKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMCB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTMpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25MaXN0LFxuICAgICAgICAgICAgICAgIC4uLih0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA+IDlcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5UGFyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZSh0bykgJiYgdG8gIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnRvID0gdG87XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShkYXRhKSAmJiBkYXRhICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gZGF0YTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlKSAmJiBub25jZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoYWNjZXNzTGlzdC5sZW5ndGggIT09IDAgJiYgYWNjZXNzTGlzdCAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IEFjY2Vzc0xpc3QuZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbkxpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGVMaXN0KGF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSByICYmIHMgJiYgeVBhcml0eSA/IFNpZ25hdHVyZS5mcm9tVHVwbGUoW3lQYXJpdHksIHIsIHNdKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIGFzc2VydCh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gb2JqZWN0IGludG8gYW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gW0F1dGhvcml6YXRpb24uZnJvbShhdXRob3JpemF0aW9uLCB7IHNpZ25hdHVyZSB9KV1cbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWluSWQ6IDEsIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIC8vIFshY29kZSBmb2N1c11cbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgcjogMTI1Li4ubixcbiAqIC8vIEBsb2c6ICAgczogNjQyLi4ubixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUgZnJvbSBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5TZXJpYWxpemVkfSB2YWx1ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oJzB4MDRmODU4MDE4MjAzMTE4NTAyNTQwYmU0MDA4NTA0YTgxN2M4MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzA4NDc3MzU5NDAwZTFhMDAxNjI3YzY4NzI2MWIwZTdmODYzOGFmMTExMmVmYThhNzdlMjM2NTZmNmU3OTQ1Mjc1YjE5ZTlkZWVkODAyNjEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA3NzAyJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgQW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbnZlbG9wZV8gPSAodHlwZW9mIGVudmVsb3BlID09PSAnc3RyaW5nJyA/IGRlc2VyaWFsaXplKGVudmVsb3BlKSA6IGVudmVsb3BlKTtcbiAgICBhc3NlcnQoZW52ZWxvcGVfKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZV8sXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpIDoge30pLFxuICAgICAgICB0eXBlOiAnZWlwNzcwMicsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF5bG9hZCB0byBzaWduIGZvciBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBob3cgdG8gY29tcHV0ZSB0aGUgc2lnbiBwYXlsb2FkIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiB3aXRoIEVDRFNBIHNpZ25pbmcgdXRpbGl0aWVzIGxpa2Uge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBbQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnNlcmlhbGl6ZShlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5zZXJpYWxpemUoZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyAuLi4gc2VuZCBgc2VyaWFsaXplZGAgdHJhbnNhY3Rpb24gdG8gSlNPTi1SUEMgYGV0aF9zZW5kUmF3VHJhbnNhY3Rpb25gXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gc2VyaWFsaXplLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbkxpc3QsIGNoYWluSWQsIGdhcywgbm9uY2UsIHRvLCB2YWx1ZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgYWNjZXNzTGlzdCwgZGF0YSwgaW5wdXQsIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGNvbnN0IGFjY2Vzc1R1cGxlTGlzdCA9IEFjY2Vzc0xpc3QudG9UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblR1cGxlTGlzdCA9IEF1dGhvcml6YXRpb24udG9UdXBsZUxpc3QoYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIG1heEZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heEZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBnYXMgPyBIZXguZnJvbU51bWJlcihnYXMpIDogJzB4JyxcbiAgICAgICAgdG8gPz8gJzB4JyxcbiAgICAgICAgdmFsdWUgPyBIZXguZnJvbU51bWJlcih2YWx1ZSkgOiAnMHgnLFxuICAgICAgICBkYXRhID8/IGlucHV0ID8/ICcweCcsXG4gICAgICAgIGFjY2Vzc1R1cGxlTGlzdCxcbiAgICAgICAgYXV0aG9yaXphdGlvblR1cGxlTGlzdCxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkVHlwZSwgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi52YWxpZGF0ZSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbXSxcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byB2YWxpZGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGVudmVsb3BlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmpzLm1hcCJdLCJuYW1lcyI6WyJBY2Nlc3NMaXN0IiwiQWRkcmVzcyIsIkF1dGhvcml6YXRpb24iLCJIYXNoIiwiSGV4IiwiUmxwIiwiU2lnbmF0dXJlIiwiVHJhbnNhY3Rpb25FbnZlbG9wZSIsIlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Iiwic2VyaWFsaXplZFR5cGUiLCJ0eXBlIiwiYXNzZXJ0IiwiZW52ZWxvcGUiLCJhdXRob3JpemF0aW9uTGlzdCIsImF1dGhvcml6YXRpb24iLCJhZGRyZXNzIiwiY2hhaW5JZCIsInN0cmljdCIsIk51bWJlciIsIkludmFsaWRDaGFpbklkRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJnYXMiLCJ0byIsInZhbHVlIiwiZGF0YSIsImFjY2Vzc0xpc3QiLCJ5UGFyaXR5IiwiciIsInMiLCJsZW5ndGgiLCJJbnZhbGlkU2VyaWFsaXplZEVycm9yIiwiYXR0cmlidXRlcyIsInRyYW5zYWN0aW9uIiwidmFsaWRhdGUiLCJCaWdJbnQiLCJmcm9tVHVwbGVMaXN0Iiwic2lnbmF0dXJlIiwiZnJvbVR1cGxlIiwidW5kZWZpbmVkIiwiZnJvbSIsIm9wdGlvbnMiLCJlbnZlbG9wZV8iLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJwcmVzaWduIiwia2VjY2FrMjU2Iiwic2VyaWFsaXplIiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImF1dGhvcml6YXRpb25UdXBsZUxpc3QiLCJleHRyYWN0IiwiZnJvbU51bWJlciIsInRvVHVwbGUiLCJjb25jYXQiLCJmcm9tSGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\nconst type = \"legacy\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(to, {\n        strict: false\n    });\n    if (typeof chainId !== \"undefined\" && chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({\n        chainId\n    });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.GasPriceTooHighError({\n        gasPrice\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const tuple = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(serialized);\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n    if (!(tuple.length === 6 || tuple.length === 9)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n        attributes: {\n            nonce,\n            gasPrice,\n            gas,\n            to,\n            value,\n            data,\n            ...tuple.length > 6 ? {\n                v: chainIdOrV_,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    const transaction = {\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== \"0x\") transaction.gasPrice = BigInt(gasPrice);\n    if (tuple.length === 6) return transaction;\n    const chainIdOrV = _Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(chainIdOrV_) && chainIdOrV_ !== \"0x\" ? Number(chainIdOrV_) : 0;\n    if (s === \"0x\" && r === \"0x\") {\n        if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Math.floor((v - 35) / 2);\n    if (chainId > 0) transaction.chainId = chainId;\n    else if (v !== 27 && v !== 28) throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({\n        value: v\n    });\n    transaction.yParity = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.vToYParity(v);\n    transaction.v = v;\n    transaction.s = s === \"0x\" ? 0n : BigInt(s);\n    transaction.r = r === \"0x\" ? 0n : BigInt(r);\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    const signature_ = (()=>{\n        if (!signature) return {};\n        const s = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.from(signature);\n        s.v = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(s.yParity);\n        return s;\n    })();\n    return {\n        ...envelope_,\n        ...signature_,\n        type: \"legacy\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_5__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope;\n    assert(envelope);\n    var _ref;\n    let serialized = [\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\"\n    ];\n    const signature = (()=>{\n        if (options.signature) return {\n            r: options.signature.r,\n            s: options.signature.s,\n            v: _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(options.signature.yParity)\n        };\n        if (typeof envelope.r === \"undefined\" || typeof envelope.s === \"undefined\") return undefined;\n        return {\n            r: envelope.r,\n            s: envelope.s,\n            v: envelope.v\n        };\n    })();\n    if (signature) {\n        const v = (()=>{\n            // EIP-155 (inferred chainId)\n            if (signature.v >= 35) {\n                const inferredChainId = Math.floor((signature.v - 35) / 2);\n                if (inferredChainId > 0) return signature.v;\n                return 27 + (signature.v === 35 ? 0 : 1);\n            }\n            // EIP-155 (explicit chainId)\n            if (chainId > 0) return chainId * 2 + 35 + signature.v - 27;\n            // Pre-EIP-155 (no chainId)\n            const v = 27 + (signature.v === 27 ? 0 : 1);\n            if (signature.v !== v) throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({\n                value: signature.v\n            });\n            return v;\n        })();\n        serialized = [\n            ...serialized,\n            _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(v),\n            signature.r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.r)),\n            signature.s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.s))\n        ];\n    } else if (chainId > 0) serialized = [\n        ...serialized,\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        \"0x\",\n        \"0x\"\n    ];\n    return _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: typeof envelope.chainId === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId) : undefined,\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        type: \"0x0\",\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.gasPrice === \"bigint\" ? {\n            gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice)\n        } : {},\n        ...signature ? {\n            ..._Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(signature),\n            v: signature.yParity === 0 ? \"0x1b\" : \"0x1c\"\n        } : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeLegacy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDTjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUN6RCxNQUFNTSxPQUFPLFNBQVM7QUFDN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTQyxPQUFPQyxRQUFRO0lBQzNCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEVBQUUsRUFBRSxHQUFHSDtJQUNsQyxJQUFJRyxJQUNBWCwrQ0FBYyxDQUFDVyxJQUFJO1FBQUVDLFFBQVE7SUFBTTtJQUN2QyxJQUFJLE9BQU9ILFlBQVksZUFBZUEsV0FBVyxHQUM3QyxNQUFNLElBQUlKLHdFQUF1QyxDQUFDO1FBQUVJO0lBQVE7SUFDaEUsSUFBSUMsWUFBWUksT0FBT0osWUFBWSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsRUFDOUMsTUFBTSxJQUFJTCx5RUFBd0MsQ0FBQztRQUFFSztJQUFTO0FBQ3RFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU00sWUFBWUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRZiwwQ0FBUyxDQUFDYztJQUN4QixNQUFNLENBQUNHLE9BQU9WLFVBQVVXLEtBQUtWLElBQUlXLE9BQU9DLE1BQU1DLGFBQWFDLEdBQUdDLEVBQUUsR0FBR1I7SUFDbkUsSUFBSSxDQUFFQSxDQUFBQSxNQUFNUyxNQUFNLEtBQUssS0FBS1QsTUFBTVMsTUFBTSxLQUFLLElBQ3pDLE1BQU0sSUFBSXRCLDJFQUEwQyxDQUFDO1FBQ2pEd0IsWUFBWTtZQUNSVDtZQUNBVjtZQUNBVztZQUNBVjtZQUNBVztZQUNBQztZQUNBLEdBQUlMLE1BQU1TLE1BQU0sR0FBRyxJQUNiO2dCQUNFRyxHQUFHTjtnQkFDSEM7Z0JBQ0FDO1lBQ0osSUFDRSxDQUFDLENBQUM7UUFDWjtRQUNB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UUFDWEMsU0FBUyxPQUFPRCxTQUFTQyxPQUFPLEtBQUssV0FDL0JQLCtDQUFjLENBQUNNLFNBQVNDLE9BQU8sSUFDL0IwQztRQUNONUIsTUFBTWYsQ0FBQUEsaUJBQUFBLFNBQVNlLElBQUksY0FBYmYsNEJBQUFBLGlCQUFpQkEsU0FBUzRDLEtBQUs7UUFDckM5QyxNQUFNO1FBQ04sR0FBSSxPQUFPRSxTQUFTYSxHQUFHLEtBQUssV0FDdEI7WUFBRUEsS0FBS25CLCtDQUFjLENBQUNNLFNBQVNhLEdBQUc7UUFBRSxJQUNwQyxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9iLFNBQVNZLEtBQUssS0FBSyxXQUN4QjtZQUFFQSxPQUFPbEIsK0NBQWMsQ0FBQ00sU0FBU1ksS0FBSztRQUFFLElBQ3hDLENBQUMsQ0FBQztRQUNSLEdBQUksT0FBT1osU0FBU2MsS0FBSyxLQUFLLFdBQ3hCO1lBQUVBLE9BQU9wQiwrQ0FBYyxDQUFDTSxTQUFTYyxLQUFLO1FBQUUsSUFDeEMsQ0FBQyxDQUFDO1FBQ1IsR0FBSSxPQUFPZCxTQUFTRSxRQUFRLEtBQUssV0FDM0I7WUFBRUEsVUFBVVIsK0NBQWMsQ0FBQ00sU0FBU0UsUUFBUTtRQUFFLElBQzlDLENBQUMsQ0FBQztRQUNSLEdBQUlnQyxZQUNFO1lBQ0UsR0FBR3RDLGdEQUFlLENBQUNzQyxVQUFVO1lBQzdCWixHQUFHWSxVQUFVSixPQUFPLEtBQUssSUFBSSxTQUFTO1FBQzFDLElBQ0UsQ0FBQyxDQUFDO0lBQ1o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNOLFNBQVN4QixRQUFRO0lBQzdCLElBQUk7UUFDQUQsT0FBT0M7UUFDUCxPQUFPO0lBQ1gsRUFDQSxVQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0osRUFDQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmpzPzc0OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnbGVnYWN5Jztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGVycm9yOiBHYXNQcmljZVRvb0hpZ2hFcnJvcjpcbiAqIC8vIEBlcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMyBnd2VpKSBjYW5ub3QgYmVcbiAqIC8vIEBlcnJvcjogaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXNQcmljZSwgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAodHlwZW9mIGNoYWluSWQgIT09ICd1bmRlZmluZWQnICYmIGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKGdhc1ByaWNlICYmIEJpZ0ludChnYXNQcmljZSkgPiAybiAqKiAyNTZuIC0gMW4pXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yKHsgZ2FzUHJpY2UgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZGVzZXJpYWxpemUoJzB4MDFlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnbGVnYWN5JyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHR1cGxlID0gUmxwLnRvSGV4KHNlcmlhbGl6ZWQpO1xuICAgIGNvbnN0IFtub25jZSwgZ2FzUHJpY2UsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBjaGFpbklkT3JWXywgciwgc10gPSB0dXBsZTtcbiAgICBpZiAoISh0dXBsZS5sZW5ndGggPT09IDYgfHwgdHVwbGUubGVuZ3RoID09PSA5KSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgLi4uKHR1cGxlLmxlbmd0aCA+IDZcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2OiBjaGFpbklkT3JWXyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzUHJpY2UpICYmIGdhc1ByaWNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IEJpZ0ludChnYXNQcmljZSk7XG4gICAgaWYgKHR1cGxlLmxlbmd0aCA9PT0gNilcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IGNoYWluSWRPclYgPSBIZXgudmFsaWRhdGUoY2hhaW5JZE9yVl8pICYmIGNoYWluSWRPclZfICE9PSAnMHgnXG4gICAgICAgID8gTnVtYmVyKGNoYWluSWRPclZfKVxuICAgICAgICA6IDA7XG4gICAgaWYgKHMgPT09ICcweCcgJiYgciA9PT0gJzB4Jykge1xuICAgICAgICBpZiAoY2hhaW5JZE9yViA+IDApXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gTnVtYmVyKGNoYWluSWRPclYpO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHYgPSBjaGFpbklkT3JWO1xuICAgIGNvbnN0IGNoYWluSWQgPSBNYXRoLmZsb29yKCh2IC0gMzUpIC8gMik7XG4gICAgaWYgKGNoYWluSWQgPiAwKVxuICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICBlbHNlIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOClcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZS5JbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG4gICAgdHJhbnNhY3Rpb24ueVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KHYpO1xuICAgIHRyYW5zYWN0aW9uLnYgPSB2O1xuICAgIHRyYW5zYWN0aW9uLnMgPSBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyk7XG4gICAgdHJhbnNhY3Rpb24uciA9IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgcjogMTI1Li4ubixcbiAqIC8vIEBsb2c6ICAgczogNjQyLi4ubixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYW4gbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5TZXJpYWxpemVkfSB2YWx1ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKCcweGY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2xlZ2FjeScsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICBjb25zdCBzID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgcy52ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1Yocy55UGFyaXR5KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZV8sXG4gICAgICAgIC4uLnNpZ25hdHVyZV8sXG4gICAgICAgIHR5cGU6ICdsZWdhY3knLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChlbnZlbG9wZSkge1xuICAgIHJldHVybiBoYXNoKGVudmVsb3BlLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIEhhc2hlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXNQcmljZTogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJ1xuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBMZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoYWluSWQgPSAwLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBsZXQgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICBdO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogb3B0aW9ucy5zaWduYXR1cmUucixcbiAgICAgICAgICAgICAgICBzOiBvcHRpb25zLnNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS55UGFyaXR5VG9WKG9wdGlvbnMuc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZlbG9wZS5yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZW52ZWxvcGUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogZW52ZWxvcGUucixcbiAgICAgICAgICAgIHM6IGVudmVsb3BlLnMsXG4gICAgICAgICAgICB2OiBlbnZlbG9wZS52LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCB2ID0gKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGluZmVycmVkIGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlLnYgPj0gMzUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZlcnJlZENoYWluSWQgPSBNYXRoLmZsb29yKChzaWduYXR1cmUudiAtIDM1KSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZlcnJlZENoYWluSWQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlLnY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI3ICsgKHNpZ25hdHVyZS52ID09PSAzNSA/IDAgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGV4cGxpY2l0IGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluSWQgKiAyICsgMzUgKyBzaWduYXR1cmUudiAtIDI3O1xuICAgICAgICAgICAgLy8gUHJlLUVJUC0xNTUgKG5vIGNoYWluSWQpXG4gICAgICAgICAgICBjb25zdCB2ID0gMjcgKyAoc2lnbmF0dXJlLnYgPT09IDI3ID8gMCA6IDEpO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZS52ICE9PSB2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTaWduYXR1cmUuSW52YWxpZFZFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUudiB9KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KSgpO1xuICAgICAgICBzZXJpYWxpemVkID0gW1xuICAgICAgICAgICAgLi4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIEhleC5mcm9tTnVtYmVyKHYpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucikpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkID4gMClcbiAgICAgICAgc2VyaWFsaXplZCA9IFsuLi5zZXJpYWxpemVkLCBIZXguZnJvbU51bWJlcihjaGFpbklkKSwgJzB4JywgJzB4J107XG4gICAgcmV0dXJuIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9ycGMgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgbGVnYWN5IHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGVudmVsb3BlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoZW52ZWxvcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBjaGFpbklkOiB0eXBlb2YgZW52ZWxvcGUuY2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhOiBlbnZlbG9wZS5kYXRhID8/IGVudmVsb3BlLmlucHV0LFxuICAgICAgICB0eXBlOiAnMHgwJyxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5nYXMpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm5vbmNlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG5vbmNlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5ub25jZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUudmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgdmFsdWU6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLnZhbHVlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXNQcmljZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXNQcmljZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzUHJpY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4oc2lnbmF0dXJlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICB2OiBzaWduYXR1cmUueVBhcml0eSA9PT0gMCA/ICcweDFiJyA6ICcweDFjJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOlsiQWRkcmVzcyIsIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJUcmFuc2FjdGlvbkVudmVsb3BlIiwidHlwZSIsImFzc2VydCIsImVudmVsb3BlIiwiY2hhaW5JZCIsImdhc1ByaWNlIiwidG8iLCJzdHJpY3QiLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwiQmlnSW50IiwiR2FzUHJpY2VUb29IaWdoRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0dXBsZSIsInRvSGV4Iiwibm9uY2UiLCJnYXMiLCJ2YWx1ZSIsImRhdGEiLCJjaGFpbklkT3JWXyIsInIiLCJzIiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRFcnJvciIsImF0dHJpYnV0ZXMiLCJ2IiwidHJhbnNhY3Rpb24iLCJ2YWxpZGF0ZSIsImNoYWluSWRPclYiLCJOdW1iZXIiLCJNYXRoIiwiZmxvb3IiLCJJbnZhbGlkVkVycm9yIiwieVBhcml0eSIsInZUb1lQYXJpdHkiLCJmcm9tIiwib3B0aW9ucyIsInNpZ25hdHVyZSIsImVudmVsb3BlXyIsInNpZ25hdHVyZV8iLCJ5UGFyaXR5VG9WIiwiZ2V0U2lnblBheWxvYWQiLCJoYXNoIiwicHJlc2lnbiIsImtlY2NhazI1NiIsInNlcmlhbGl6ZSIsInVuZGVmaW5lZCIsImlucHV0IiwiZnJvbU51bWJlciIsImluZmVycmVkQ2hhaW5JZCIsInRyaW1MZWZ0IiwiZnJvbUhleCIsInRvUnBjIiwiZXh0cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Value.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Value.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: function() { return /* binding */ InvalidDecimalNumberError; },\n/* harmony export */   exponents: function() { return /* binding */ exponents; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   formatGwei: function() { return /* binding */ formatGwei; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromEther: function() { return /* binding */ fromEther; },\n/* harmony export */   fromGwei: function() { return /* binding */ fromGwei; }\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */ const exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */ function format(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    let display = value.toString();\n    const negative = display.startsWith(\"-\");\n    if (negative) display = display.slice(1);\n    display = display.padStart(decimals, \"0\");\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals)\n    ];\n    fraction = fraction.replace(/(0+)$/, \"\");\n    return \"\".concat(negative ? \"-\" : \"\").concat(integer || \"0\").concat(fraction ? \".\".concat(fraction) : \"\");\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */ function formatEther(wei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */ function formatGwei(wei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */ function from(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value)) throw new InvalidDecimalNumberError({\n        value\n    });\n    let [integer = \"\", fraction = \"0\"] = value.split(\".\");\n    const negative = integer.startsWith(\"-\");\n    if (negative) integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, \"\");\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(\".\".concat(fraction))) === 1) integer = \"\".concat(BigInt(integer) + 1n);\n        fraction = \"\";\n    } else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals)\n        ];\n        const rounded = Math.round(Number(\"\".concat(unit, \".\").concat(right)));\n        if (rounded > 9) fraction = \"\".concat(BigInt(left) + BigInt(1), \"0\").padStart(left.length + 1, \"0\");\n        else fraction = \"\".concat(left).concat(rounded);\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = \"\".concat(BigInt(integer) + 1n);\n        }\n        fraction = fraction.slice(0, decimals);\n    } else {\n        fraction = fraction.padEnd(decimals, \"0\");\n    }\n    return BigInt(\"\".concat(negative ? \"-\" : \"\").concat(integer).concat(fraction));\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromEther(ether) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromGwei(gwei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */ class InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is not a valid decimal number.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Value.InvalidDecimalNumberError\"\n        });\n    }\n} //# sourceMappingURL=Value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ3RDLDBEQUEwRCxHQUNuRCxNQUFNQyxZQUFZO0lBQ3JCQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLE9BQU87QUFDWCxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTQyxPQUFPQyxLQUFLO1FBQUVDLFdBQUFBLGlFQUFXO0lBQ3JDLElBQUlDLFVBQVVGLE1BQU1HLFFBQVE7SUFDNUIsTUFBTUMsV0FBV0YsUUFBUUcsVUFBVSxDQUFDO0lBQ3BDLElBQUlELFVBQ0FGLFVBQVVBLFFBQVFJLEtBQUssQ0FBQztJQUM1QkosVUFBVUEsUUFBUUssUUFBUSxDQUFDTixVQUFVO0lBQ3JDLElBQUksQ0FBQ08sU0FBU0MsU0FBUyxHQUFHO1FBQ3RCUCxRQUFRSSxLQUFLLENBQUMsR0FBR0osUUFBUVEsTUFBTSxHQUFHVDtRQUNsQ0MsUUFBUUksS0FBSyxDQUFDSixRQUFRUSxNQUFNLEdBQUdUO0tBQ2xDO0lBQ0RRLFdBQVdBLFNBQVNFLE9BQU8sQ0FBQyxTQUFTO0lBQ3JDLE9BQU8sR0FBeUJILE9BQXRCSixXQUFXLE1BQU0sSUFBc0JLLE9BQWpCRCxXQUFXLEtBQXFDLE9BQS9CQyxXQUFXLElBQWEsT0FBVEEsWUFBYTtBQUNqRjtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0csWUFBWWxCLEdBQUc7UUFBRW1CLE9BQUFBLGlFQUFPO0lBQ3BDLE9BQU9kLE9BQU9MLEtBQUtELFVBQVVLLEtBQUssR0FBR0wsU0FBUyxDQUFDb0IsS0FBSztBQUN4RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0MsV0FBV3BCLEdBQUc7UUFBRW1CLE9BQUFBLGlFQUFPO0lBQ25DLE9BQU9kLE9BQU9MLEtBQUtELFVBQVVFLElBQUksR0FBR0YsU0FBUyxDQUFDb0IsS0FBSztBQUN2RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0UsS0FBS2YsS0FBSztRQUFFQyxXQUFBQSxpRUFBVztJQUNuQyxJQUFJLENBQUMsNEJBQTRCZSxJQUFJLENBQUNoQixRQUNsQyxNQUFNLElBQUlpQiwwQkFBMEI7UUFBRWpCO0lBQU07SUFDaEQsSUFBSSxDQUFDUSxVQUFVLEVBQUUsRUFBRUMsV0FBVyxHQUFHLENBQUMsR0FBR1QsTUFBTWtCLEtBQUssQ0FBQztJQUNqRCxNQUFNZCxXQUFXSSxRQUFRSCxVQUFVLENBQUM7SUFDcEMsSUFBSUQsVUFDQUksVUFBVUEsUUFBUUYsS0FBSyxDQUFDO0lBQzVCLHVCQUF1QjtJQUN2QkcsV0FBV0EsU0FBU0UsT0FBTyxDQUFDLFNBQVM7SUFDckMsbUVBQW1FO0lBQ25FLElBQUlWLGFBQWEsR0FBRztRQUNoQixJQUFJa0IsS0FBS0MsS0FBSyxDQUFDQyxPQUFPLElBQWEsT0FBVFosZ0JBQWlCLEdBQ3ZDRCxVQUFVLEdBQXdCLE9BQXJCYyxPQUFPZCxXQUFXLEVBQUU7UUFDckNDLFdBQVc7SUFDZixPQUNLLElBQUlBLFNBQVNDLE1BQU0sR0FBR1QsVUFBVTtRQUNqQyxNQUFNLENBQUNzQixNQUFNVixNQUFNVyxNQUFNLEdBQUc7WUFDeEJmLFNBQVNILEtBQUssQ0FBQyxHQUFHTCxXQUFXO1lBQzdCUSxTQUFTSCxLQUFLLENBQUNMLFdBQVcsR0FBR0E7WUFDN0JRLFNBQVNILEtBQUssQ0FBQ0w7U0FDbEI7UUFDRCxNQUFNd0IsVUFBVU4sS0FBS0MsS0FBSyxDQUFDQyxPQUFPLEdBQVdHLE9BQVJYLE1BQUssS0FBUyxPQUFOVztRQUM3QyxJQUFJQyxVQUFVLEdBQ1ZoQixXQUFXLEdBQTRCLE9BQXpCYSxPQUFPQyxRQUFRRCxPQUFPLElBQUcsS0FBR2YsUUFBUSxDQUFDZ0IsS0FBS2IsTUFBTSxHQUFHLEdBQUc7YUFFcEVELFdBQVcsR0FBVWdCLE9BQVBGLE1BQWUsT0FBUkU7UUFDekIsSUFBSWhCLFNBQVNDLE1BQU0sR0FBR1QsVUFBVTtZQUM1QlEsV0FBV0EsU0FBU0gsS0FBSyxDQUFDO1lBQzFCRSxVQUFVLEdBQXdCLE9BQXJCYyxPQUFPZCxXQUFXLEVBQUU7UUFDckM7UUFDQUMsV0FBV0EsU0FBU0gsS0FBSyxDQUFDLEdBQUdMO0lBQ2pDLE9BQ0s7UUFDRFEsV0FBV0EsU0FBU2lCLE1BQU0sQ0FBQ3pCLFVBQVU7SUFDekM7SUFDQSxPQUFPcUIsT0FBTyxHQUF5QmQsT0FBdEJKLFdBQVcsTUFBTSxJQUFlSyxPQUFWRCxTQUFtQixPQUFUQztBQUNyRDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU2tCLFVBQVU3QixLQUFLO1FBQUVlLE9BQUFBLGlFQUFPO0lBQ3BDLE9BQU9FLEtBQUtqQixPQUFPTCxVQUFVSyxLQUFLLEdBQUdMLFNBQVMsQ0FBQ29CLEtBQUs7QUFDeEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNlLFNBQVNqQyxJQUFJO1FBQUVrQixPQUFBQSxpRUFBTztJQUNsQyxPQUFPRSxLQUFLcEIsTUFBTUYsVUFBVUUsSUFBSSxHQUFHRixTQUFTLENBQUNvQixLQUFLO0FBQ3REO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1JLGtDQUFrQ3pCLGlEQUFnQjtJQUMzRHNDLFlBQVksRUFBRTlCLEtBQUssRUFBRSxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFpQixPQUFOQSxPQUFNO1FBQ3ZCK0IsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1ZhbHVlLmpzPzAxZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbi8qKiBAc2VlIGh0dHBzOi8vZXRoZXJldW0uZ2l0aHViLmlvL3llbGxvd3BhcGVyL3BhcGVyLnBkZiAqL1xuZXhwb3J0IGNvbnN0IGV4cG9uZW50cyA9IHtcbiAgICB3ZWk6IDAsXG4gICAgZ3dlaTogOSxcbiAgICBzemFibzogMTIsXG4gICAgZmlubmV5OiAxNSxcbiAgICBldGhlcjogMTgsXG59O1xuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAoZGl2aWRlZCBieSB0aGUgZ2l2ZW4gZXhwb25lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXQoNDIwXzAwMF8wMDBfMDAwbiwgOSlcbiAqIC8vIEBsb2c6ICc0MjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIGRpdmlkZSB0aGUgYGJpZ2ludGAgVmFsdWUgYnkuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gICAgbGV0IGRpc3BsYXkgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gZGlzcGxheS5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKVxuICAgICAgICBkaXNwbGF5ID0gZGlzcGxheS5zbGljZSgxKTtcbiAgICBkaXNwbGF5ID0gZGlzcGxheS5wYWRTdGFydChkZWNpbWFscywgJzAnKTtcbiAgICBsZXQgW2ludGVnZXIsIGZyYWN0aW9uXSA9IFtcbiAgICAgICAgZGlzcGxheS5zbGljZSgwLCBkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICAgICAgZGlzcGxheS5zbGljZShkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICBdO1xuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG4gICAgcmV0dXJuIGAke25lZ2F0aXZlID8gJy0nIDogJyd9JHtpbnRlZ2VyIHx8ICcwJ30ke2ZyYWN0aW9uID8gYC4ke2ZyYWN0aW9ufWAgOiAnJ31gO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdEV0aGVyKDFfMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgRXRoZXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWksIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXRHd2VpKDFfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgR3dlaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0R3dlaSh3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmb3JtYXQod2VpLCBleHBvbmVudHMuZ3dlaSAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIGBzdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgVmFsdWUgdG8gYGJpZ2ludGAgKG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIGV4cG9uZW50KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbSgnNDIwJywgOSlcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIG11bHRpcGx5IHRoZSBWYWx1ZSBieS5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgICBpZiAoIS9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGVjaW1hbE51bWJlckVycm9yKHsgdmFsdWUgfSk7XG4gICAgbGV0IFtpbnRlZ2VyID0gJycsIGZyYWN0aW9uID0gJzAnXSA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBpbnRlZ2VyLnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBpZiAobmVnYXRpdmUpXG4gICAgICAgIGludGVnZXIgPSBpbnRlZ2VyLnNsaWNlKDEpO1xuICAgIC8vIHRyaW0gdHJhaWxpbmcgemVyb3MuXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgICAvLyByb3VuZCBvZmYgaWYgdGhlIGZyYWN0aW9uIGlzIGxhcmdlciB0aGFuIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMuXG4gICAgaWYgKGRlY2ltYWxzID09PSAwKSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKE51bWJlcihgLiR7ZnJhY3Rpb259YCkpID09PSAxKVxuICAgICAgICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgICAgIGZyYWN0aW9uID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCB1bml0LCByaWdodF0gPSBbXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyAtIDEpLFxuICAgICAgICAgICAgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMgLSAxLCBkZWNpbWFscyksXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZShkZWNpbWFscyksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKE51bWJlcihgJHt1bml0fS4ke3JpZ2h0fWApKTtcbiAgICAgICAgaWYgKHJvdW5kZWQgPiA5KVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBgJHtCaWdJbnQobGVmdCkgKyBCaWdJbnQoMSl9MGAucGFkU3RhcnQobGVmdC5sZW5ndGggKyAxLCAnMCcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGAke2xlZnR9JHtyb3VuZGVkfWA7XG4gICAgICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgIGludGVnZXIgPSBgJHtCaWdJbnQoaW50ZWdlcikgKyAxbn1gO1xuICAgICAgICB9XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5wYWRFbmQoZGVjaW1hbHMsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXJ9JHtmcmFjdGlvbn1gKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21FdGhlcignNDIwJylcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBldGhlciAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlci5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdGhlcihldGhlciwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZyb20oZXRoZXIsIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21Hd2VpKCc0MjAnKVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGd3ZWkgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgR3dlaS5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Hd2VpKGd3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmcm9tKGd3ZWksIGV4cG9uZW50cy5nd2VpIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUV0aGVyKCcxMjMuNDU2Ljc4OScpXG4gKiAvLyBAZXJyb3I6IFZhbHVlLkludmFsaWREZWNpbWFsTnVtYmVyRXJyb3I6IFZhbHVlIGAxMjMuNDU2Ljc4OWAgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVmFsdWUuSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWUuanMubWFwIl0sIm5hbWVzIjpbIkVycm9ycyIsImV4cG9uZW50cyIsIndlaSIsImd3ZWkiLCJzemFibyIsImZpbm5leSIsImV0aGVyIiwiZm9ybWF0IiwidmFsdWUiLCJkZWNpbWFscyIsImRpc3BsYXkiLCJ0b1N0cmluZyIsIm5lZ2F0aXZlIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFkU3RhcnQiLCJpbnRlZ2VyIiwiZnJhY3Rpb24iLCJsZW5ndGgiLCJyZXBsYWNlIiwiZm9ybWF0RXRoZXIiLCJ1bml0IiwiZm9ybWF0R3dlaSIsImZyb20iLCJ0ZXN0IiwiSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvciIsInNwbGl0IiwiTWF0aCIsInJvdW5kIiwiTnVtYmVyIiwiQmlnSW50IiwibGVmdCIsInJpZ2h0Iiwicm91bmRlZCIsInBhZEVuZCIsImZyb21FdGhlciIsImZyb21Hd2VpIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js":
/*!***************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateL1Fee: function() { return /* binding */ estimateL1Fee; }\n/* harmony export */ });\n/* harmony import */ var _contract_contract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contract/contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/contract/contract.js\");\n/* harmony import */ var _transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction/actions/to-serializable-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js\");\n/* harmony import */ var _transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/read-contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/read-contract.js\");\n/* harmony import */ var _transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/serialize-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\");\n\n\n\n\nconst OPStackGasPriceOracleAddress = \"0x420000000000000000000000000000000000000F\";\n/**\n * @internal\n */ async function estimateL1Fee(options) {\n    const { transaction, gasPriceOracleAddress } = options;\n    const oracleContract = (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_0__.getContract)({\n        client: transaction.client,\n        address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n        chain: transaction.chain\n    });\n    // purposefully remove gasPrice from the transaction\n    const { gasPrice, ...serializableTx } = await (0,_transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__.toSerializableTransaction)({\n        transaction\n    });\n    const serialized = (0,_transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__.serializeTransaction)({\n        transaction: serializableTx\n    });\n    //serializeTransaction(transaction);\n    return (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__.readContract)({\n        contract: oracleContract,\n        method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n        params: [\n            serialized\n        ]\n    });\n} //# sourceMappingURL=estimate-l1-fee.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9nYXMvZXN0aW1hdGUtbDEtZmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQzRDO0FBQ25DO0FBQ2dCO0FBQy9FLE1BQU1JLCtCQUErQjtBQUNyQzs7Q0FFQyxHQUNNLGVBQWVDLGNBQWNDLE9BQU87SUFDdkMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdGO0lBQy9DLE1BQU1HLGlCQUFpQlQsa0VBQVdBLENBQUM7UUFDL0JVLFFBQVFILFlBQVlHLE1BQU07UUFDMUJDLFNBQVNILHlCQUF5Qko7UUFDbENRLE9BQU9MLFlBQVlLLEtBQUs7SUFDNUI7SUFDQSxvREFBb0Q7SUFDcEQsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0MsZ0JBQWdCLEdBQUcsTUFBTWIsOEdBQXlCQSxDQUFDO1FBQ3BFTTtJQUNKO0lBQ0EsTUFBTVEsYUFBYVosMkZBQW9CQSxDQUFDO1FBQ3BDSSxhQUFhTztJQUNqQjtJQUNBLG9DQUFvQztJQUNwQyxPQUFPWiwyRUFBWUEsQ0FBQztRQUNoQmMsVUFBVVA7UUFDVlEsUUFBUTtRQUNSQyxRQUFRO1lBQUNIO1NBQVc7SUFDeEI7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vZ2FzL2VzdGltYXRlLWwxLWZlZS5qcz83NjA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2NvbnRyYWN0LmpzXCI7XG5pbXBvcnQgeyB0b1NlcmlhbGl6YWJsZVRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2FjdGlvbnMvdG8tc2VyaWFsaXphYmxlLXRyYW5zYWN0aW9uLmpzXCI7XG5pbXBvcnQgeyByZWFkQ29udHJhY3QgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vcmVhZC1jb250cmFjdC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vc2VyaWFsaXplLXRyYW5zYWN0aW9uLmpzXCI7XG5jb25zdCBPUFN0YWNrR2FzUHJpY2VPcmFjbGVBZGRyZXNzID0gXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZUwxRmVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBnYXNQcmljZU9yYWNsZUFkZHJlc3MgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb3JhY2xlQ29udHJhY3QgPSBnZXRDb250cmFjdCh7XG4gICAgICAgIGNsaWVudDogdHJhbnNhY3Rpb24uY2xpZW50LFxuICAgICAgICBhZGRyZXNzOiBnYXNQcmljZU9yYWNsZUFkZHJlc3MgfHwgT1BTdGFja0dhc1ByaWNlT3JhY2xlQWRkcmVzcyxcbiAgICAgICAgY2hhaW46IHRyYW5zYWN0aW9uLmNoYWluLFxuICAgIH0pO1xuICAgIC8vIHB1cnBvc2VmdWxseSByZW1vdmUgZ2FzUHJpY2UgZnJvbSB0aGUgdHJhbnNhY3Rpb25cbiAgICBjb25zdCB7IGdhc1ByaWNlLCAuLi5zZXJpYWxpemFibGVUeCB9ID0gYXdhaXQgdG9TZXJpYWxpemFibGVUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemFibGVUeCxcbiAgICB9KTtcbiAgICAvL3NlcmlhbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gcmVhZENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3Q6IG9yYWNsZUNvbnRyYWN0LFxuICAgICAgICBtZXRob2Q6IFwiZnVuY3Rpb24gZ2V0TDFGZWUoYnl0ZXMgbWVtb3J5IF9kYXRhKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpXCIsXG4gICAgICAgIHBhcmFtczogW3NlcmlhbGl6ZWRdLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXN0aW1hdGUtbDEtZmVlLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRDb250cmFjdCIsInRvU2VyaWFsaXphYmxlVHJhbnNhY3Rpb24iLCJyZWFkQ29udHJhY3QiLCJzZXJpYWxpemVUcmFuc2FjdGlvbiIsIk9QU3RhY2tHYXNQcmljZU9yYWNsZUFkZHJlc3MiLCJlc3RpbWF0ZUwxRmVlIiwib3B0aW9ucyIsInRyYW5zYWN0aW9uIiwiZ2FzUHJpY2VPcmFjbGVBZGRyZXNzIiwib3JhY2xlQ29udHJhY3QiLCJjbGllbnQiLCJhZGRyZXNzIiwiY2hhaW4iLCJnYXNQcmljZSIsInNlcmlhbGl6YWJsZVR4Iiwic2VyaWFsaXplZCIsImNvbnRyYWN0IiwibWV0aG9kIiwicGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serializeTransaction: function() { return /* binding */ serializeTransaction; }\n/* harmony export */ });\n/* harmony import */ var ox_Hex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ox/Hex */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var ox_Signature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ox/Signature */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ox/TransactionEnvelopeEip1559 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ox/TransactionEnvelopeEip2930 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ox/TransactionEnvelopeEip7702 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\");\n/* harmony import */ var ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ox/TransactionEnvelopeLegacy */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\");\n\n\n\n\n\n\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */ function serializeTransaction(options) {\n    const { transaction } = options;\n    const type = getTransactionEnvelopeType(transaction);\n    // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n    const signature = (()=>{\n        if (options.signature) {\n            if (\"v\" in options.signature && typeof options.signature.v !== \"undefined\") {\n                return ox_Signature__WEBPACK_IMPORTED_MODULE_0__.fromLegacy({\n                    r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                    s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                    v: Number(options.signature.v)\n                });\n            }\n            return {\n                r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                // We force the Signature type here because we filter for legacy type above\n                yParity: options.signature.yParity\n            };\n        }\n        if (typeof transaction.v === \"undefined\" && typeof transaction.yParity === \"undefined\") {\n            return undefined;\n        }\n        if (transaction.r === undefined || transaction.s === undefined) {\n            throw new Error(\"Invalid signature provided with transaction\");\n        }\n        return {\n            r: typeof transaction.r === \"bigint\" ? transaction.r : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.r),\n            s: typeof transaction.s === \"bigint\" ? transaction.s : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.s),\n            yParity: typeof transaction.v !== \"undefined\" && typeof transaction.yParity === \"undefined\" ? ox_Signature__WEBPACK_IMPORTED_MODULE_0__.vToYParity(Number(transaction.v)) : Number(transaction.yParity)\n        };\n    })();\n    if (type === \"eip1559\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"legacy\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.assert(typedTransaction);\n        return ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"eip2930\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"eip7702\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */ function getTransactionEnvelopeType(transactionEnvelope) {\n    if (typeof transactionEnvelope.type !== \"undefined\") {\n        return transactionEnvelope.type;\n    }\n    if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n        return \"eip7702\";\n    }\n    if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" || typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n        return \"eip1559\";\n    }\n    if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n        if (typeof transactionEnvelope.accessList !== \"undefined\") {\n            return \"eip2930\";\n        }\n        return \"legacy\";\n    }\n    throw new Error(\"Invalid transaction type\");\n} //# sourceMappingURL=serialize-transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS90cmFuc2FjdGlvbi9zZXJpYWxpemUtdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNZO0FBQ2tDO0FBQ0E7QUFDQTtBQUNGO0FBQzlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU00scUJBQXFCQyxPQUFPO0lBQ3hDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdEO0lBQ3hCLE1BQU1FLE9BQU9DLDJCQUEyQkY7SUFDeEMsK0dBQStHO0lBQy9HLE1BQU1HLFlBQVksQ0FBQztRQUNmLElBQUlKLFFBQVFJLFNBQVMsRUFBRTtZQUNuQixJQUFJLE9BQU9KLFFBQVFJLFNBQVMsSUFDeEIsT0FBT0osUUFBUUksU0FBUyxDQUFDQyxDQUFDLEtBQUssYUFBYTtnQkFDNUMsT0FBT1gsb0RBQXdCLENBQUM7b0JBQzVCYSxHQUFHZCw0Q0FBZ0IsQ0FBQ08sUUFBUUksU0FBUyxDQUFDRyxDQUFDO29CQUN2Q0UsR0FBR2hCLDRDQUFnQixDQUFDTyxRQUFRSSxTQUFTLENBQUNLLENBQUM7b0JBQ3ZDSixHQUFHSyxPQUFPVixRQUFRSSxTQUFTLENBQUNDLENBQUM7Z0JBQ2pDO1lBQ0o7WUFDQSxPQUFPO2dCQUNIRSxHQUFHZCw0Q0FBZ0IsQ0FBQ08sUUFBUUksU0FBUyxDQUFDRyxDQUFDO2dCQUN2Q0UsR0FBR2hCLDRDQUFnQixDQUFDTyxRQUFRSSxTQUFTLENBQUNLLENBQUM7Z0JBQ3ZDLDJFQUEyRTtnQkFDM0VFLFNBQVNYLFFBQVFJLFNBQVMsQ0FDckJPLE9BQU87WUFDaEI7UUFDSjtRQUNBLElBQUksT0FBT1YsWUFBWUksQ0FBQyxLQUFLLGVBQ3pCLE9BQU9KLFlBQVlVLE9BQU8sS0FBSyxhQUFhO1lBQzVDLE9BQU9DO1FBQ1g7UUFDQSxJQUFJWCxZQUFZTSxDQUFDLEtBQUtLLGFBQWFYLFlBQVlRLENBQUMsS0FBS0csV0FBVztZQUM1RCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxPQUFPO1lBQ0hOLEdBQUcsT0FBT04sWUFBWU0sQ0FBQyxLQUFLLFdBQ3RCTixZQUFZTSxDQUFDLEdBQ2JkLDRDQUFnQixDQUFDUSxZQUFZTSxDQUFDO1lBQ3BDRSxHQUFHLE9BQU9SLFlBQVlRLENBQUMsS0FBSyxXQUN0QlIsWUFBWVEsQ0FBQyxHQUNiaEIsNENBQWdCLENBQUNRLFlBQVlRLENBQUM7WUFDcENFLFNBQVMsT0FBT1YsWUFBWUksQ0FBQyxLQUFLLGVBQzlCLE9BQU9KLFlBQVlVLE9BQU8sS0FBSyxjQUM3QmpCLG9EQUF3QixDQUFDZ0IsT0FBT1QsWUFBWUksQ0FBQyxLQUM3Q0ssT0FBT1QsWUFBWVUsT0FBTztRQUNwQztJQUNKO0lBQ0EsSUFBSVQsU0FBUyxXQUFXO1FBQ3BCLE1BQU1hLG1CQUFtQmQ7UUFDekJOLGlFQUFxQyxDQUFDb0I7UUFDdEMsT0FBT3BCLG9FQUF3QyxDQUFDb0Isa0JBQWtCO1lBQzlEWDtRQUNKO0lBQ0o7SUFDQSxJQUFJRixTQUFTLFVBQVU7UUFDbkIsTUFBTWEsbUJBQW1CZDtRQUN6QkgsZ0VBQW9DLENBQUNpQjtRQUNyQyxPQUFPakIsbUVBQXVDLENBQUNpQixrQkFBa0I7WUFDN0RYO1FBQ0o7SUFDSjtJQUNBLElBQUlGLFNBQVMsV0FBVztRQUNwQixNQUFNYSxtQkFBbUJkO1FBQ3pCTCxpRUFBcUMsQ0FBQ21CO1FBQ3RDLE9BQU9uQixvRUFBd0MsQ0FBQ21CLGtCQUFrQjtZQUM5RFg7UUFDSjtJQUNKO0lBQ0EsSUFBSUYsU0FBUyxXQUFXO1FBQ3BCLE1BQU1hLG1CQUFtQmQ7UUFDekJKLGlFQUFxQyxDQUFDa0I7UUFDdEMsT0FBT2xCLG9FQUF3QyxDQUFDa0Isa0JBQWtCO1lBQzlEWDtRQUNKO0lBQ0o7SUFDQSxNQUFNLElBQUlTLE1BQU07QUFDcEI7QUFDQTs7Q0FFQyxHQUNELFNBQVNWLDJCQUEyQmUsbUJBQW1CO0lBQ25ELElBQUksT0FBT0Esb0JBQW9CaEIsSUFBSSxLQUFLLGFBQWE7UUFDakQsT0FBT2dCLG9CQUFvQmhCLElBQUk7SUFDbkM7SUFDQSxJQUFJLE9BQU9nQixvQkFBb0JDLGlCQUFpQixLQUFLLGFBQWE7UUFDOUQsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFPRCxvQkFBb0JFLFlBQVksS0FBSyxlQUM1QyxPQUFPRixvQkFBb0JHLG9CQUFvQixLQUFLLGFBQWE7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFPSCxvQkFBb0JJLFFBQVEsS0FBSyxhQUFhO1FBQ3JELElBQUksT0FBT0osb0JBQW9CSyxVQUFVLEtBQUssYUFBYTtZQUN2RCxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxNQUFNLElBQUlWLE1BQU07QUFDcEIsRUFDQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZS10cmFuc2FjdGlvbi5qcz83NDc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG94X19IZXggZnJvbSBcIm94L0hleFwiO1xuaW1wb3J0ICogYXMgb3hfX1NpZ25hdHVyZSBmcm9tIFwib3gvU2lnbmF0dXJlXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5XCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSBmcm9tIFwib3gvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeVwiO1xuLyoqXG4gKiBTZXJpYWxpemVzIGEgbGVnYWN5LCBFSVAtMTU1OSwgRUlQLTI5MzAsIEVJUC00ODQ0LCBvciBFSVAtNzcwMiB0cmFuc2FjdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMudHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWQuXG4gKiBAcGFyYW0gW29wdGlvbnMuc2lnbmF0dXJlXSAtIFRoZSBzaWduYXR1cmUgdG8gaW5jbHVkZSB3aXRoIHRoZSB0cmFuc2FjdGlvbiwgaWYgbmVjZXNzYXJ5LlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiBvYmplY3QgaXMgaW52YWxpZC5cbiAqIEB0cmFuc2FjdGlvblxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXJpYWxpemVUcmFuc2FjdGlvbiB9IGZyb20gXCJ0aGlyZHdlYlwiO1xuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNlcmlhbGl6ZVRyYW5zYWN0aW9uKHsgdHJhbnNhY3Rpb246IHtcbiAqICAgIHRvOiBcIjB4XCIsXG4gKiAgICB2YWx1ZTogMG4sXG4gKiAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gVGhpcyBpcyB0byBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggb3VyIG9sZCBpbnRlcmZhY2UgKGluY2x1ZGluZyB0aGUgc2lnbmF0dXJlIGluIHRoZSB0cmFuc2FjdGlvbiBvYmplY3QpXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoXCJ2XCIgaW4gb3B0aW9ucy5zaWduYXR1cmUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zaWduYXR1cmUudiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBveF9fU2lnbmF0dXJlLmZyb21MZWdhY3koe1xuICAgICAgICAgICAgICAgICAgICByOiBveF9fSGV4LnRvQmlnSW50KG9wdGlvbnMuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgICAgICAgICBzOiBveF9fSGV4LnRvQmlnSW50KG9wdGlvbnMuc2lnbmF0dXJlLnMpLFxuICAgICAgICAgICAgICAgICAgICB2OiBOdW1iZXIob3B0aW9ucy5zaWduYXR1cmUudiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IG94X19IZXgudG9CaWdJbnQob3B0aW9ucy5zaWduYXR1cmUuciksXG4gICAgICAgICAgICAgICAgczogb3hfX0hleC50b0JpZ0ludChvcHRpb25zLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3JjZSB0aGUgU2lnbmF0dXJlIHR5cGUgaGVyZSBiZWNhdXNlIHdlIGZpbHRlciBmb3IgbGVnYWN5IHR5cGUgYWJvdmVcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiBvcHRpb25zLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICAueVBhcml0eSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi52ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb24ueVBhcml0eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uciA9PT0gdW5kZWZpbmVkIHx8IHRyYW5zYWN0aW9uLnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgcHJvdmlkZWQgd2l0aCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogdHlwZW9mIHRyYW5zYWN0aW9uLnIgPT09IFwiYmlnaW50XCJcbiAgICAgICAgICAgICAgICA/IHRyYW5zYWN0aW9uLnJcbiAgICAgICAgICAgICAgICA6IG94X19IZXgudG9CaWdJbnQodHJhbnNhY3Rpb24uciksXG4gICAgICAgICAgICBzOiB0eXBlb2YgdHJhbnNhY3Rpb24ucyA9PT0gXCJiaWdpbnRcIlxuICAgICAgICAgICAgICAgID8gdHJhbnNhY3Rpb24uc1xuICAgICAgICAgICAgICAgIDogb3hfX0hleC50b0JpZ0ludCh0cmFuc2FjdGlvbi5zKSxcbiAgICAgICAgICAgIHlQYXJpdHk6IHR5cGVvZiB0cmFuc2FjdGlvbi52ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLnlQYXJpdHkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IG94X19TaWduYXR1cmUudlRvWVBhcml0eShOdW1iZXIodHJhbnNhY3Rpb24udikpXG4gICAgICAgICAgICAgICAgOiBOdW1iZXIodHJhbnNhY3Rpb24ueVBhcml0eSksXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJlaXAxNTU5XCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgICAgICBjb25zdCB0eXBlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIG94X19UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh0eXBlZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG94X19UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlaXAyOTMwXCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlaXA3NzAyXCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIHR5cGVcIik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSh0cmFuc2FjdGlvbkVudmVsb3BlKSB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLnR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRW52ZWxvcGUudHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLmF1dGhvcml6YXRpb25MaXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBcImVpcDc3MDJcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLm1heEZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gXCJlaXAxNTU5XCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5nYXNQcmljZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRW52ZWxvcGUuYWNjZXNzTGlzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiZWlwMjkzMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImxlZ2FjeVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIHR5cGVcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemUtdHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIm94X19IZXgiLCJveF9fU2lnbmF0dXJlIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Iiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kiLCJzZXJpYWxpemVUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJ0cmFuc2FjdGlvbiIsInR5cGUiLCJnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSIsInNpZ25hdHVyZSIsInYiLCJmcm9tTGVnYWN5IiwiciIsInRvQmlnSW50IiwicyIsIk51bWJlciIsInlQYXJpdHkiLCJ1bmRlZmluZWQiLCJFcnJvciIsInZUb1lQYXJpdHkiLCJ0eXBlZFRyYW5zYWN0aW9uIiwiYXNzZXJ0Iiwic2VyaWFsaXplIiwidHJhbnNhY3Rpb25FbnZlbG9wZSIsImF1dGhvcml6YXRpb25MaXN0IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJnYXNQcmljZSIsImFjY2Vzc0xpc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\n"));

/***/ })

}]);