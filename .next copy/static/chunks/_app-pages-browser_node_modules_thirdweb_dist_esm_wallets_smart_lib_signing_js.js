"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_wallets_smart_lib_signing_js"],{

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: function(key) {\n            for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                msgs[_key - 1] = arguments[_key];\n            }\n            return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs));\n        },\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQzFCO0FBQ3FCO0FBQ1A7QUFDeEQsMENBQTBDLEdBQ25DLFNBQVNJLFFBQVFDLElBQUk7SUFDeEIsT0FBTztRQUNIQTtRQUNBTCxNQUFNLFNBQUNNOzZDQUFRQztnQkFBQUE7O21CQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNOztRQUN2REwsV0FBV0EsOERBQUFBO0lBQ2Y7QUFDSjtBQUNPLFNBQVNNLFlBQVlDLFFBQVEsRUFBRUMsT0FBTztJQUN6QyxNQUFNQyxTQUFTLENBQUNOLE9BQVNGLHFFQUFXQSxDQUFDO1lBQUUsR0FBR00sUUFBUTtZQUFFLEdBQUdMLFFBQVFDLEtBQUs7UUFBQztJQUNyRSxPQUFPO1FBQUUsR0FBR00sT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3hDLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzP2YyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: function() { return /* binding */ pippenger; },\n/* harmony export */   precomputeMSMUnsafe: function() { return /* binding */ precomputeMSMUnsafe; },\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n        windows,\n        windowSize\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n) {\n            let acc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : c.ZERO;\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                if (n === _0n) break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0) continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0) curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length) throw new Error(\"arrays of points and scalars must have equal length\");\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < scalars.length; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Qsb0VBQW9FLEdBQ2Q7QUFDRjtBQUNwRCxNQUFNSSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsU0FBU0UsZ0JBQWdCQyxTQUFTLEVBQUVDLElBQUk7SUFDcEMsTUFBTUMsTUFBTUQsS0FBS0UsTUFBTTtJQUN2QixPQUFPSCxZQUFZRSxNQUFNRDtBQUM3QjtBQUNBLFNBQVNHLFVBQVVDLENBQUMsRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0gsTUFBTUEsS0FBSyxLQUFLQSxJQUFJQyxNQUMxQyxNQUFNLElBQUlHLE1BQU0sdUNBQXVDSCxPQUFPLGNBQWNEO0FBQ3BGO0FBQ0EsU0FBU0ssVUFBVUwsQ0FBQyxFQUFFQyxJQUFJO0lBQ3RCRixVQUFVQyxHQUFHQztJQUNiLE1BQU1LLFVBQVVDLEtBQUtDLElBQUksQ0FBQ1AsT0FBT0QsS0FBSyxHQUFHLGNBQWM7SUFDdkQsTUFBTVMsYUFBYSxLQUFNVCxDQUFBQSxJQUFJLElBQUksMEJBQTBCO0lBQzNELE9BQU87UUFBRU07UUFBU0c7SUFBVztBQUNqQztBQUNBLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxDQUFDO0lBQ2hDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSCxTQUNmLE1BQU0sSUFBSVAsTUFBTTtJQUNwQk8sT0FBT0ksT0FBTyxDQUFDLENBQUNDLEdBQUdDO1FBQ2YsSUFBSSxDQUFFRCxDQUFBQSxhQUFhSixDQUFBQSxHQUNmLE1BQU0sSUFBSVIsTUFBTSw0QkFBNEJhO0lBQ3BEO0FBQ0o7QUFDQSxTQUFTQyxtQkFBbUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ0ssVUFDZixNQUFNLElBQUlmLE1B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RyxvREFBT0EsQ0FBQ3NHLE1BQU14RCxDQUFDLEVBQUV3RCxNQUFNSyxVQUFVLENBQUM7UUFDckMsR0FBR0wsS0FBSztRQUNSLEdBQUc7WUFBRXpFLEdBQUd5RSxNQUFNQyxFQUFFLENBQUNRLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzYxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNZXRob2RzIGZvciBlbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBieSBzY2FsYXJzLlxuICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYml0TGVuLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgYml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXNcbmNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcG9pbnRXaW5kb3dTaXplcyA9IG5ldyBXZWFrTWFwKCk7IC8vIFRoaXMgYWxsb3dzIHVzZSBtYWtlIHBvaW50cyBpbW11dGFibGUgKG5vdGhpbmcgY2hhbmdlcyBpbnNpZGUpXG5mdW5jdGlvbiBnZXRXKFApIHtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbi8qKlxuICogRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuICogU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4gKiBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbiAqIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuICogLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuICogLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuICogLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4gKiAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4gKiAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuICpcbiAqIEB0b2RvIFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy5cbiAqIFRoaXMgd291bGQgYWxsb3cgd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICBoYXNQcmVjb21wdXRlcyhlbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IGMuWkVSTykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBnbyBvdmVyIGVtcHR5IHNjYWxhclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IHByZWNvbXB1dGVzW29mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDFdOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGJ5IHJlLXVzaW5nIGFjYywgd2UgY2FuIHNhdmUgYSBsb3Qgb2YgYWRkaXRpb25zIGluIGNhc2Ugb2YgTVNNXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWRVbnNhZmUoUCwgbiwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB3aXRoIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlwcGVuZ2VyKGMsIGZpZWxkTiwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggIT09IHNjYWxhcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBvaW50cy5sZW5ndGgpKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gd2JpdHMgPiAxMiA/IHdiaXRzIC0gMyA6IHdiaXRzID4gNCA/IHdiaXRzIC0gMiA6IHdiaXRzID8gMiA6IDE7IC8vIGluIGJpdHNcbiAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTUFTSyArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICBjb25zdCB3Yml0cyA9IE51bWJlcigoc2NhbGFyID4+IEJpZ0ludChpKSkgJiBCaWdJbnQoTUFTSykpO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gQmlnSW50KCgxIDw8IHdpbmRvd1NpemUpIC0gMSk7XG4gICAgY29uc3QgdGFibGVzID0gcG9pbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFjYyA9IHA7IGkgPCB0YWJsZVNpemU7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2goYWNjKTtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gKHNjYWxhcnMpID0+IHtcbiAgICAgICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgICAgIGlmIChzY2FsYXJzLmxlbmd0aCA+IHBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG9mIHNjYWxhcnMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYXJyYXkgb2YgcG9pbnRzJyk7XG4gICAgICAgIGxldCByZXMgPSB6ZXJvO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGRvdWJsZSBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCB6ZXJvLlxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gemVybylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmRvdWJsZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChjaHVua3MgKiB3aW5kb3dTaXplIC0gKGkgKyAxKSAqIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigobiA+PiBzaGlmdEJ5KSAmIE1BU0spO1xuICAgICAgICAgICAgICAgIGlmICghY3VycilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgemVybyBzY2FsYXJzIGNodW5rc1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQodGFibGVzW2pdW2N1cnIgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJiaXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwiYml0cyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNhbGNXT3B0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ2YWxpZGF0ZU1TTVBvaW50cyIsInBvaW50cyIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicCIsImkiLCJ2YWxpZGF0ZU1TTVNjYWxhcnMiLCJzY2FsYXJzIiwiZmllbGQiLCJzIiwiaXNWYWxpZCIsInBvaW50UHJlY29tcHV0ZXMiLCJXZWFrTWFwIiwicG9pbnRXaW5kb3dTaXplcyIsImdldFciLCJQIiwiZ2V0Iiwid05BRiIsImhhc1ByZWNvbXB1dGVzIiwiZWxtIiwidW5zYWZlTGFkZGVyIiwibiIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGVW5zYWZlIiwiYWNjIiwiY3VyciIsImdldFByZWNvbXB1dGVzIiwidHJhbnNmb3JtIiwiY29tcCIsInNldCIsIndOQUZDYWNoZWQiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwicHJldiIsInNldFdpbmRvd1NpemUiLCJkZWxldGUiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJsZW5ndGgiLCJ6ZXJvIiwiTUFTSyIsImJ1Y2tldHMiLCJmaWxsIiwibGFzdEJpdHMiLCJmbG9vciIsIkJJVFMiLCJzdW0iLCJqIiwic2NhbGFyIiwicmVzSSIsInN1bUkiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiRnAiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsIk9iamVjdCIsImZyZWV6ZSIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"mapToCurve: expected array of bigints\");\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0YsNkZBQTZGO0FBQzdGLE1BQU1NLFFBQVFKLHNEQUFlQTtBQUM3Qiw0Q0FBNEM7QUFDNUMsU0FBU0ssTUFBTUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3hCQyxLQUFLRjtJQUNMRSxLQUFLRDtJQUNMLElBQUlELFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlDLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJIO0lBQzlDLE1BQU1JLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1IsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUyxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU1gsS0FBS1ksSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlYLE1BQU07QUFDeEI7QUFDQTs7O0NBR0MsR0FDTSxTQUFTYyxtQkFBbUJDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxVQUFVLEVBQUVDLENBQUM7SUFDdEQ1QixpREFBTUEsQ0FBQ3lCO0lBQ1B6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VyxJQUFJYixjQUFjeEIsS0FBSyxHQUFHO2dCQUFFLEdBQUcrRCxHQUFHO2dCQUFFOUQsS0FBSzhELElBQUlTLFNBQVM7Z0JBQUUsR0FBRzlDLE9BQU87WUFBQztZQUN6RSxNQUFNMEMsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUUsR0FBR2dDLGFBQWE7WUFDMURELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtRQUNBLDBDQUEwQztRQUMxQ04sWUFBV1csT0FBTztZQUNkLElBQUksQ0FBQ3RGLE1BQU11RixPQUFPLENBQUNELFVBQ2YsTUFBTSxJQUFJeEYsTUFBTTtZQUNwQixLQUFLLE1BQU1LLEtBQUttRixRQUNaLElBQUksT0FBT25GLE1BQU0sVUFDYixNQUFNLElBQUlMLE1BQU07WUFDeEIsTUFBTW1GLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV1csVUFBVUosYUFBYTtZQUM3REQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8yMGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cbiAqIFtSRkMgOTM4MCA1LjMuMV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShzY2FsYXJzKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsImFieXRlcyIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJ2YWxpZGF0ZU9iamVjdCIsIm9zMmlwIiwiaTJvc3AiLCJ2YWx1ZSIsImxlbmd0aCIsImFudW0iLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiaXRlbSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJtc2ciLCJEU1QiLCJsZW5JbkJ5dGVzIiwiSCIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImhhc2hfdG9fZmllbGQiLCJjb3VudCIsIm9wdGlvbnMiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJfRFNUIiwibG9nMnAiLCJ0b1N0cmluZyIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJ1IiwiZSIsImoiLCJlbG1fb2Zmc2V0IiwidHYiLCJzdWJhcnJheSIsImlzb2dlbnlNYXAiLCJmaWVsZCIsIm1hcCIsIkNPRUZGIiwicmV2ZXJzZSIsIngiLCJ5IiwieE51bSIsInhEZW4iLCJ5TnVtIiwieURlbiIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsImRpdiIsImNyZWF0ZUhhc2hlciIsIlBvaW50IiwibWFwVG9DdXJ2ZSIsImRlZiIsImhhc2hUb0N1cnZlIiwidTAiLCJmcm9tQWZmaW5lIiwidTEiLCJQIiwiY2xlYXJDb2ZhY3RvciIsImFzc2VydFZhbGlkaXR5IiwiZW5jb2RlVG9DdXJ2ZSIsImVuY29kZURTVCIsInNjYWxhcnMiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpLegendre: function() { return /* binding */ FpLegendre; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (modulo <= _0n) throw new Error(\"invalid modulus\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++){\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000) throw new Error(\"Cannot find square root: likely non-prime P\");\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. P ‚â° 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n_c = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n_c1 = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\n_c2 = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n_c3 = FpDiv;\n/**\n * Legendre symbol.\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x)=>f.pow(x, legendreConst);\n}\n_c4 = FpLegendre;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x)=>{\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n_c5 = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, redef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\n_c6 = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n_c7 = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n_c8 = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"FpSqrt\");\n$RefreshReg$(_c1, \"FpPow\");\n$RefreshReg$(_c2, \"FpInvertBatch\");\n$RefreshReg$(_c3, \"FpDiv\");\n$RefreshReg$(_c4, \"FpLegendre\");\n$RefreshReg$(_c5, \"FpIsSquare\");\n$RefreshReg$(_c6, \"Field\");\n$RefreshReg$(_c7, \"FpSqrtOdd\");\n$RefreshReg$(_c8, \"FpSqrtEven\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNELG9FQUFvRSxHQUNtRTtBQUN2SSxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU0sYUFBYSxHQUFHRixPQUFPLElBQUlHLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ3RHLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNLGFBQWEsR0FBR0osT0FBTyxJQUFJSyxNQUFNLGFBQWEsR0FBR0wsT0FBTyxJQUFJTSxNQUFNLGFBQWEsR0FBR04sT0FBTztBQUNyRyxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTSxhQUFhLEdBQUdQLE9BQU8sSUFBSVEsT0FBTyxhQUFhLEdBQUdSLE9BQU87QUFDckUsd0JBQXdCO0FBQ2pCLFNBQVNTLElBQUlDLENBQUMsRUFBRUMsQ0FBQztJQUNwQixNQUFNQyxTQUFTRixJQUFJQztJQUNuQixPQUFPQyxVQUFVYixNQUFNYSxTQUFTRCxJQUFJQztBQUN4QztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLElBQUlELFFBQVFoQixLQUNSLE1BQU0sSUFBSWtCLE1BQU07SUFDcEIsSUFBSUQsVUFBVWpCLEtBQ1YsTUFBTSxJQUFJa0IsTUFBTTtJQUNwQixJQUFJRCxXQUFXZixLQUNYLE9BQU9GO0lBQ1gsSUFBSW1CLE1BQU1qQjtJQUNWLE1BQU9jLFFBQVFoQixJQUFLO1FBQ2hCLElBQUlnQixRQUFRZCxLQUNSaUIsTUFBTSxNQUFPSixNQUFPRTtRQUN4QkYsTUFBTSxNQUFPQSxNQUFPRTtRQUNwQkQsVUFBVWQ7SUFDZDtJQUNBLE9BQU9pQjtBQUNYO0FBQ0EsMERBQTBELEdBQ25ELFNBQVNDLEtBQUtD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REFBZUEsQ0FBQ29KO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVdkksSUFBSUssS0FBSzJILGFBQWF4SSxPQUFPQTtJQUM3QyxPQUFPeUcsT0FBTzdHLDBEQUFlQSxDQUFDbUosU0FBU0QsWUFBWW5KLDBEQUFlQSxDQUFDb0osU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/MGNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaW5pdGUgZmllbGRzLlxuICogQSBmaW5pdGUgZmllbGQgb3ZlciAxMSBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpLCBfM24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpLCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDkpLCBfMTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQHRvZG8gdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2R1bHVzJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKykge1xuICAgICAgICAvLyBDcmFzaCBpbnN0ZWFkIG9mIGluZmluaXR5IGxvb3AsIHdlIGNhbm5vdCByZWFzb25hYmxlIGNvdW50IHVudGlsIFAuXG4gICAgICAgIGlmIChaID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IGxpa2VseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIEl0IHdpbGwgdHJ5IHRvIGNoZWNrIGlmIG9wdGltaXphdGlvbnMgYXJlIGFwcGxpY2FibGUgYW5kIGZhbGwgYmFjayB0byA0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLyoqXG4gKiBMZWdlbmRyZSBzeW1ib2wuXG4gKiAqIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyBub24gcmVzaWR1ZVxuICogKiAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBMZWdlbmRyZShvcmRlcikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAob3JkZXIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKGYsIHgpID0+IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmUgPSBGcExlZ2VuZHJlKGYuT1JERVIpO1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gbGVnZW5kcmUoZiwgeCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBpc0xFLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIEJZVEVTICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJiaXRNYXNrIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl84biIsIl85biIsIl8xNm4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRXJyb3IiLCJyZXMiLCJwb3cyIiwieCIsImludmVydCIsIm51bWJlciIsInkiLCJ1IiwidiIsInEiLCJyIiwibSIsIm4iLCJnY2QiLCJ0b25lbGxpU2hhbmtzIiwiUCIsImxlZ2VuZHJlQyIsIlEiLCJTIiwiWiIsInAxZGl2NCIsInRvbmVsbGlGYXN0IiwiRnAiLCJyb290IiwiZXFsIiwic3FyIiwiUTFkaXYyIiwidG9uZWxsaVNsb3ciLCJuZWciLCJPTkUiLCJnIiwibXVsIiwiWkVSTyIsInQyIiwiZ2UiLCJGcFNxcnQiLCJzcXJ0M21vZDQiLCJjMSIsInNxcnQ1bW9kOCIsIm4yIiwibnYiLCJpIiwic3ViIiwiaXNOZWdhdGl2ZUxFIiwiRklFTERfRklFTERTIiwidmFsaWRhdGVGaWVsZCIsImZpZWxkIiwiaW5pdGlhbCIsIk9SREVSIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJGcFBvdyIsImYiLCJwIiwiZCIsIkZwSW52ZXJ0QmF0Y2giLCJudW1zIiwidG1wIiwiQXJyYXkiLCJsZW5ndGgiLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImlzMCIsImludmVydGVkIiwiaW52IiwicmVkdWNlUmlnaHQiLCJGcERpdiIsImxocyIsInJocyIsIkZwTGVnZW5kcmUiLCJvcmRlciIsImxlZ2VuZHJlQ29uc3QiLCJGcElzU3F1YXJlIiwibGVnZW5kcmUiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiRmllbGQiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   DERErr: function() { return /* binding */ DERErr; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endomorphism, can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"invalid endomorphism, expected beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(len.length / 2 | 128) : \"\";\n            const t = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return b2n(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ‚àã (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            Object.freeze(this);\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"r\", this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"s\", this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute () {\n            let windowSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Point.BASE;\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey) {\n        let isCompressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB) {\n        let isCompressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\"\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"num < 2^\" + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultVerOpts;\n        var _Point_BASE_multiplyAndAddUnsafe;\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = (_Point_BASE_multiplyAndAddUnsafe = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point_BASE_multiplyAndAddUnsafe === void 0 ? void 0 : _Point_BASE_multiplyAndAddUnsafe.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n_c = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\nvar _c;\n$RefreshReg$(_c, \"SWUFpSqrtRatio\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELG9FQUFvRSxHQUNQO0FBQ3VDO0FBQ25FO0FBQ3lCO0FBQzFELFNBQVNhLG1CQUFtQkMsSUFBSTtJQUM1QixJQUFJQSxLQUFLQyxJQUFJLEtBQUtDLFdBQ2ROLGdEQUFLQSxDQUFDLFFBQVFJLEtBQUtDLElBQUk7SUFDM0IsSUFBSUQsS0FBS0csT0FBTyxLQUFLRCxXQUNqQk4sZ0RBQUtBLENBQUMsV0FBV0ksS0FBS0csT0FBTztBQUNyQztBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNTCxPQUFPYix3REFBYUEsQ0FBQ2tCO0lBQzNCVixxREFBaUIsQ0FBQ0ssTUFBTTtRQUNwQk8sR0FBRztRQUNIQyxHQUFHO0lBQ1AsR0FBRztRQUNDQywwQkFBMEI7UUFDMUJDLGdCQUFnQjtRQUNoQkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLG9CQUFvQjtRQUNwQkMsV0FBVztRQUNYQyxTQUFTO0lBQ2I7SUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFVixDQUFDLEVBQUUsR0FBR1A7SUFDeEIsSUFBSWdCLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHeEIsSUFBSTtJQUFDO0FBQ25DO0FBQ0EsTUFBTSxFQUFFeUIs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UUFDOUNELE1BQU1oVSxHQUFHcUYsR0FBRyxDQUFDc1AsS0FBSzVWLEtBQUsyVixDQUFDLEdBQUcsb0JBQW9CO1FBQy9DWixNQUFNOVQsR0FBR3NGLEdBQUcsQ0FBQ3dPLEtBQUtFLE1BQU0sc0JBQXNCO1FBQzlDcFAsSUFBSTVFLEdBQUdxRixHQUFHLENBQUN3TyxLQUFLRSxNQUFNLHNCQUFzQjtRQUM1QyxNQUFNLEVBQUV4TSxPQUFPLEVBQUUrTSxLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2EsTUFBTSxpREFBaUQ7UUFDakc5UCxJQUFJN0UsR0FBR3FGLEdBQUcsQ0FBQ3dPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEL08sSUFBSTdFLEdBQUdxRixHQUFHLENBQUNSLEdBQUd5UCxRQUFRLG1CQUFtQjtRQUN6QzFQLElBQUk1RSxHQUFHbVUsSUFBSSxDQUFDdlAsR0FBR21QLEtBQUt4TSxVQUFVLHdDQUF3QztRQUN0RTFDLElBQUk3RSxHQUFHbVUsSUFBSSxDQUFDdFAsR0FBR3lQLE9BQU8vTSxVQUFVLHVDQUF1QztRQUN2RSxNQUFNOE0sS0FBS3JVLEdBQUcrSSxLQUFLLENBQUM2SyxPQUFPNVQsR0FBRytJLEtBQUssQ0FBQ2xFLElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0UsR0FBR21VLElBQUksQ0FBQ25VLEdBQUcwSixHQUFHLENBQUM3RSxJQUFJQSxHQUFHd1AsS0FBSyw0QkFBNEI7UUFDM0R6UCxJQUFJNUUsR0FBRzRVLEdBQUcsQ0FBQ2hRLEdBQUdxUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVyUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2I1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiLlxuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHBpcHBlbmdlciwgdmFsaWRhdGVCYXNpYywgd05BRiwgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBnZXRNaW5IYXNoTGVuZ3RoLCBpbnZlcnQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQsIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYWJvb2wsIGVuc3VyZUJ5dGVzLCBtZW1vaXplZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcbiAgICBpZiAob3B0cy5sb3dTICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdsb3dTJywgb3B0cy5sb3dTKTtcbiAgICBpZiAob3B0cy5wcmVoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBleHBlY3RlZCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyB1dC5udW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAxMjgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKG51bSk7XG4gICAgICAgICAgICAvLyBQYWQgd2l0aCB6ZXJvIGJ5dGUgaWYgbmVnYXRpdmUgZmxhZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuICAgICAgICAgICAgICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBiMm4oZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB1dC5pblJhbmdlKG51bSwgXzFuLCBDVVJWRS5uKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG46IE4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleSwgZXhwZWN0ZWQgaGV4IG9yICcgKyBuQnl0ZUxlbmd0aCArICcgYnl0ZXMsIGdvdCAnICsgdHlwZW9mIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kKG51bSwgTik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICB1dC5hSW5SYW5nZSgncHJpdmF0ZSBrZXknLCBudW0sIF8xbiwgTik7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2MsIF8wbiwgTik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIC8vIENhc2UgYTogbm8gZW5kb21vcnBoaXNtLiBDYXNlIGI6IGhhcyBwcmVjb21wdXRlcy5cbiAgICAgICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICAgICAgLy8gQ2FzZSBjOiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlIG1ldGhvZHMgZm9yIGl0LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEZpZWxkIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbiAqIC8vIEJlZm9yZSB0aGF0LCBkZWZpbmUgQmlnSW50LXM6IGEsIGIsIHAsIG4sIEd4LCBHeVxuICogY29uc3QgY3VydmUgPSB3ZWllcnN0cmFzcyh7IGEsIGIsIEZwOiBGaWVsZChwKSwgbiwgR3gsIEd5LCBoOiAxbiB9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXV0LmluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncicsIHRoaXMuciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncycsIHRoaXMucywgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHMgaW4gWzEuLk5dXG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIlxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgdXQuYUluUmFuZ2UoJ251bSA8IDJeJyArIENVUlZFLm5CaXRMZW5ndGgsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGludmFsaWQgYXQgbGVhc3QgZm9yIFA1MjEuIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IG9wdHM7XG4gICAgICAgIC8vIFZlcmlmeSBvcHRzLCBkZWR1Y2Ugc2lnbmF0dXJlIGZvcm1hdFxuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgIT09ICdjb21wYWN0JyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgbXVzdCBiZSBjb21wYWN0IG9yIGRlcicpO1xuICAgICAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZyk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gIWlzSGV4ICYmXG4gICAgICAgICAgICAhZm9ybWF0ICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIGlmICghaXNIZXggJiYgIWlzT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgVWludDhBcnJheSwgaGV4IHN0cmluZyBvciBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzT2JqKVxuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xuICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gJ2NvbXBhY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9zaWcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbInBpcHBlbmdlciIsInZhbGlkYXRlQmFzaWMiLCJ3TkFGIiwiRmllbGQiLCJnZXRNaW5IYXNoTGVuZ3RoIiwiaW52ZXJ0IiwibWFwSGFzaFRvRmllbGQiLCJtb2QiLCJ2YWxpZGF0ZUZpZWxkIiwidXQiLCJhYm9vbCIsImVuc3VyZUJ5dGVzIiwibWVtb2l6ZWQiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJvcHRzIiwibG93UyIsInVuZGVmaW5lZCIsInByZWhhc2giLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwidmFsaWRhdGVPYmplY3QiLCJhIiwiYiIsImFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyIsIndyYXBQcml2YXRlS2V5IiwiaXNUb3JzaW9uRnJlZSIsImNsZWFyQ29mYWN0b3IiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJmcm9tQnl0ZXMiLCJ0b0J5dGVzIiwiZW5kbyIsIkZwIiwiZXFsIiwiWkVSTyIsIkVycm9yIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiT2JqZWN0IiwiZnJlZXplIiwiYnl0ZXNUb051bWJlckJFIiwiYjJuIiwiaGV4VG9CeXRlcyIsImgyYiIsIkRFUkVyciIsImNvbnN0cnVjdG9yIiwibSIsIkRFUiIsIkVyciIsIl90bHYiLCJlbmNvZGUiLCJ0YWciLCJkYXRhIiwiRSIsImxlbmd0aCIsImRhdGFMZW4iLCJsZW4iLCJudW1iZXJUb0hleFVucGFkZGVkIiwibGVuTGVuIiwidCIsImRlY29kZSIsInBvcyIsImZpcnN0IiwiaXNMb25nIiwibGVuZ3RoQnl0ZXMiLCJzdWJhcnJheSIsInYiLCJsIiwiX2ludCIsIm51bSIsIl8wbiIsImhleCIsIk51bWJlciIsInBhcnNlSW50IiwidG9TaWciLCJpbnQiLCJ0bHYiLCJhYnl0ZXMiLCJzZXFCeXRlcyIsInNlcUxlZnRCeXRlcyIsInJCeXRlcyIsInJMZWZ0Qnl0ZXMiLCJzQnl0ZXMiLCJzTGVmdEJ5dGVzIiwiciIsInMiLCJoZXhGcm9tU2lnIiwic2lnIiwicnMiLCJzcyIsInNlcSIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIndlaWVyc3RyYXNzUG9pbnRzIiwiQ1VSVkUiLCJGbiIsIm4iLCJuQml0TGVuZ3RoIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiVWludDhBcnJheSIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwiaW5SYW5nZSIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJrZXkiLCJsZW5ndGhzIiwibkJ5dGVMZW5ndGgiLCJOIiwiaXNCeXRlcyIsImJ5dGVzVG9IZXgiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZXJyb3IiLCJhSW5SYW5nZSIsImFzc2VydFByalBvaW50Iiwib3RoZXIiLCJQb2ludCIsInRvQWZmaW5lTWVtbyIsInAiLCJpeiIsInB4IiwicHkiLCJweiIsInoiLCJPTkUiLCJpczAiLCJpbnYiLCJheCIsImF5IiwienoiLCJhc3NlcnRWYWxpZE1lbW8iLCJpc1ZhbGlkIiwibGVmdCIsInJpZ2h0IiwiZnJvbUFmZmluZSIsImkiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJtc20iLCJzY2FsYXJzIiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwid25hZiIsInNldFdpbmRvd1NpemUiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3TkFGQ2FjaGVkIiwibXVsdGlwbHlVbnNhZmUiLCJzYyIsIkkiLCJoYXNQcmVjb21wdXRlcyIsIndOQUZDYWNoZWRVbnNhZmUiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsImQiLCJzY2FsYXIiLCJmYWtlIiwiZiIsImYxcCIsImYycCIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwiUSIsIkciLCJzdW0iLCJoIiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwiaXNDb21wcmVzc2VkIiwidG9IZXgiLCJfYml0cyIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJtb2ROIiwiaW52TiIsImNhdCIsImhlYWQiLCJPUkRFUiIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJjbCIsInVsIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJzbGljZSIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlcnkiLCJyZWNvdmVyUHVibGljS2V5IiwibXNnSGFzaCIsInJlYyIsInJhZGoiLCJwcmVmaXgiLCJSIiwiaXIiLCJ1MSIsInUyIiwiaGFzSGlnaFMiLCJ0b0RFUlJhd0J5dGVzIiwidG9ERVJIZXgiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJyYW5kb21Qcml2YXRlS2V5IiwicHJlY29tcHV0ZSIsImdldFB1YmxpY0tleSIsImlzUHJvYlB1YiIsIml0ZW0iLCJhcnIiLCJzdHIiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJiaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJrIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwic2VlZCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJxIiwibm9ybVMiLCJkZWZhdWx0VmVyT3B0cyIsInNpZ24iLCJwcml2S2V5IiwiQyIsImRyYmciLCJjcmVhdGVIbWFjRHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiZm9ybWF0IiwiaXNIZXgiLCJpc09iaiIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJwb3ciLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag) {\n    for(var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        messages[_key - 1] = arguments[_key];\n    }\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n_c = GmulAdd;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */ const schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */ const hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */ const encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\nvar _c;\n$RefreshReg$(_c, \"GmulAdd\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG9FQUFvRSxHQUN0QjtBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRSxNQUFNZSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJVjtJQUNWLGtCQUFrQjtJQUNsQixNQUFNVyxNQUFNVixPQUFPLElBQUlXLE1BQU1YLE9BQU8sSUFBSVksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNYyxPQUFPZCxPQUFPLEtBQUtlLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPO0lBQzFELE1BQU1pQixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFBVTtJQUN0QyxNQUFNUyxLQUFLLEtBQU1ELEtBQUtULElBQUtDLEdBQUcsTUFBTTtJQUNwQyxNQUFNVSxLQUFLLDJEQUFNRCxJQUFJUixLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNVyxLQUFLLDJEQUFNRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNWSxNQUFNLDJEQUFNRCxJQUFJakIsS0FBS00sS0FBS1EsS0FBTVI7SUFDdEMsTUFBTWEsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUgsS0FBS1ksTUFBT1o7SUFDekMsTUFBTWMsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUosS0FBS2EsTUFBT2I7SUFDekMsTUFBTWUsTUFBTSwyREFBTUQsS0FBS1IsTUFBTU4sS0FBS2MsTUFBT2Q7SUFDekMsTUFBTWdCLE9BQU8sMkRBQU1ELEtBQUtSLE1BQU1QLEtBQUtlLE1BQU9mO0lBQzFDLE1BQU1pQixPQUFPLDJEQUFNRCxNQUFNVixNQUFNTixLQUFLYyxNQUFPZDtJQUMzQyxNQUFNa0IsT0FBTywyREFBTUQsTUFBTWhCLEtBQUtELEtBQUtTLEtBQU1UO0lBQ3pDLE1BQU1tQixLQUFLLDJEQUFNRCxNQUFNYixNQUFNTCxLQUFLYSxNQUFPYjtJQUN6QyxNQUFNb0IsS0FBSywyREFBTUQsSUFBSWpCLEtBQUtGLEtBQUtRLEtBQU1SO0lBQ3JDLE1BQU1xQixPQUFPdkMsMERBQUlBLENBQUNzQyxJQUFJMUIsS0FBS007SUFDM0IsSUFBSSxDQUFDc0IsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNILE9BQU90QixJQUMxQixNQUFNLElBQUkwQixNQUFNO0lBQ3BCLE9BQU9KO0FBQ1g7QUFDQSxNQUFNQyxPQUFPMUMsMkRBQUtBLENBQUNVLFlBQVlvQyxXQUFXQSxXQUFXO0lBQUVDLE1BQU03QjtBQUFRO0FBQ3JFOzs7Ozs7Ozs7OztDQVdDLEdBQ00sTUFBTThCLFlBQVluRCw2REFBV0EsQ0FBQztJQUNqQ21CLEdBQUdMLE9BQU87SUFDVk0sR0FBR04sT0FBTztJQUNWc0MsSUFBSVA7SUFDSlEsR0FBR3RDO0lBQ0gsd0NBQXdDO0lBQ3hDdUMsSUFBSXhDLE9BQU87SUFDWHlDLElBQUl6QyxPQUFPO0lBQ1gwQyxHQUFHMUMsT0FBTztJQUNWMkMsTUFBTTtJQUNOQyxNQUFNO1FBQ0YsMEJBQTBCO1FBQzFCQyxNQUFNN0MsT0FBTztRQUNiOEMsYUFBYSxDQUFDQztZQUNWLE1BQU1SLElBQUl0QztZQUNWLE1BQU0rQyxLQUFLaEQsT0FBTztZQUNsQixNQUFNaUQsS0FBSyxDQUFDL0MsTUFBTUYsT0FBTztZQUN6QixNQUFNa0QsS0FBS2xELE9BQU87WUFDbEIsTUFBTWlCLEtBQUsrQjtZQUNYLE1BQU1HLFlBQVluRCxPQUFPLHdDQUF3QywwQkFBMEI7WUFDM0YsTUFBTW9ELEtBQUtoRCxXQUFXYSxLQUFLOEIsR0FBR1I7WUFDOUIsTUFBTWMsS0FBS2pELFdBQVcsQ0FBQzZDLEtBQUtGLEdBQUdSO1lBQy9CLElBQUllLEtBQUtoRSx5REFBR0EsQ0FBQ3lELElBQUlLLEtBQUtKLEtBQUtLLEtBQUtILElBQUlYO1lBQ3BDLElBQUlnQixLQUFLakUseURBQUdBLENBQUMsQ0FBQzhELEtBQUtILEtBQUtJLEtBQUtwQyxJQUFJc0I7WUFDakMsTUFBTWlCLFFBQVFGLEtBQUtIO1lBQ25CLE1BQU1NLFFBQVFGLEtBQUtKO1lBQ25CLElBQUlLLE9BQ0FGLEtBQUtmLElBQUllO1lBQ2IsSUFBSUcsT0FDQUYsS0FBS2hCLElBQUlnQjtZQUNiLElBQUlELEtBQUtILGFBQWFJLEtBQUtKLFdBQVc7Z0JBQ2xDLE1BQU0sSUFBSWpCLE1BQU0seUNBQXlDYTtZQUM3RDtZQUNBLE9BQU87Z0JBQUVTO2dCQUFPRjtnQkFBSUc7Z0JBQU9GO1lBQUc7UUFDbEM7SUFDSjtBQUNKLEdBQUd2RSx3REFBTUEsRUFBRTtBQUNYLCtGQUErRjtBQUMvRixpRUFBaUU7QUFDakUsTUFBTTBFLE1BQU0xRCxPQUFPO0FBQ25CLHNGQUFzRixHQUN0RixNQUFNMkQsdUJBQXVCLENBQUM7QUFDOUIsU0FBU0MsV0FBV0MsR0FBRztJQUFFO1FBQUdDLFNBQUgsMkJBQVc7O0lBQ2hDLElBQUlDLE9BQU9KLG9CQUFvQixDQUFDRSxJQUFJO0lBQ3BDLElBQUlFLFNBQVM1QixXQUFXO1FBQ3BCLE1BQU02QixPQUFPaEYsNERBQU1BLENBQUNpRixXQUFXQyxJQUFJLENBQUNMLEtBQUssQ0FBQ00sSUFBTUEsRUFBRUMsVUFBVSxDQUFDO1FBQzdETCxPQUFPckUsK0RBQVdBLENBQUNzRSxNQUFNQTtRQUN6Qkwsb0JBQW9CLENBQUNFLElBQUksR0FBR0U7SUFDaEM7SUFDQSxPQUFPL0UsNERBQU1BLENBQUNVLCtEQUFXQSxDQUFDcUUsU0FBU0Q7QUFDdkM7QUFDQSxvRkFBb0Y7QUFDcEYsTUFBTU8sZUFBZSxDQUFDQyxRQUFVQSxNQUFNQyxVQUFVLENBQUMsTUFBTUMsS0FBSyxDQUFDO0FBQzdELE1BQU1DLFdBQVcsQ0FBQ2xDLElBQU0xQyxtRUFBZUEsQ0FBQzBDLEdBQUc7QUFDM0MsTUFBTW1DLE9BQU8sQ0FBQ0MsSUFBTXJGLHlEQUFHQSxDQUFDcUYsR0FBRzVFO0FBQzNCLE1BQU02RSxPQUFPLENBQUNELElBQU1yRix5REFBR0EsQ0FBQ3FGLEdBQUcxRTtBQUMzQixNQUFNNEUsUUFBUXhDLFVBQVV5QyxlQUFlO0FBQ3ZDLE1BQU1DLFVBQVUsQ0FBQ0MsR0FBRzNFLEdBQUdDLElBQU11RSxNQUFNSSxJQUFJLENBQUNDLG9CQUFvQixDQUFDRixHQUFHM0UsR0FBR0M7S0FBN0R5RTtBQUNOLG9DQUFvQztBQUNwQyxTQUFTSSxvQkFBb0JDLElBQUk7SUFDN0IsSUFBSUMsS0FBS2hELFVBQVVpRCxLQUFLLENBQUNDLHNCQUFzQixDQUFDSCxPQUFPLHlDQUF5QztJQUNoRyxJQUFJSSxJQUFJWCxNQUFNWSxjQUFjLENBQUNKLEtBQUssNENBQTRDO0lBQzlFLE1BQU1LLFNBQVNGLEVBQUVHLFFBQVEsS0FBS04sS0FBS1QsS0FBSyxDQUFDUztJQUN6QyxPQUFPO1FBQUVLLFFBQVFBO1FBQVFFLE9BQU92QixhQUFhbUI7SUFBRztBQUNwRDtBQUNBOzs7Q0FHQyxHQUNELFNBQVNLLE9BQU9sQixDQUFDO0lBQ2JuRiw0REFBUUEsQ0FBQyxLQUFLbUYsR0FBR3pFLEtBQUtILGFBQWEsaUJBQWlCO0lBQ3BELE1BQU0rRixLQUFLcEIsS0FBS0MsSUFBSUE7SUFDcEIsTUFBTVIsSUFBSU8sS0FBS29CLEtBQUtuQixJQUFJM0UsT0FBTyxLQUFLLHdCQUF3QjtJQUM1RCxJQUFJUSxJQUFJRCxRQUFRNEQsSUFBSSwyQkFBMkI7SUFDL0MsSUFBSTNELElBQUlMLFFBQVF1RCxLQUNabEQsSUFBSWtFLEtBQUssQ0FBQ2xFLElBQUksbURBQW1EO0lBQ3JFLE1BQU1nRixJQUFJLElBQUlYLE1BQU1GLEdBQUduRSxHQUFHTixNQUFNLG1EQUFtRDtJQUNuRnNGLEVBQUVPLGNBQWM7SUFDaEIsT0FBT1A7QUFDWDtBQUNBLE1BQU1RLE1BQU12RywrREFBZUE7QUFDM0I7O0NBRUMsR0FDRCxTQUFTd0c7SUFBVTtRQUFHQyxLQUFILHVCQUFPOztJQUN0QixPQUFPdEIsS0FBS29CLElBQUlwQyxXQUFXLHdCQUF3QnNDO0FBQ3ZEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxvQkFBb0JDLFVBQVU7SUFDbkMsT0FBT2pCLG9CQUFvQmlCLFlBQVlSLEtBQUssRUFBRSxvREFBb0Q7QUFDdEc7QUFDQTs7O0NBR0MsR0FDRCxTQUFTUyxZQUFZQyxPQUFPLEVBQUVGLFVBQVU7UUFBRUcsVUFBQUEsaUVBQVV0SCxnRUFBV0EsQ0FBQztJQUM1RCxNQUFNdUgsSUFBSTdHLCtEQUFXQSxDQUFDLFdBQVcyRztJQUNqQyxNQUFNLEVBQUVWLE9BQU9hLEVBQUUsRUFBRWYsUUFBUWdCLENBQUMsRUFBRSxHQUFHdkIsb0JBQW9CaUIsYUFBYSxnQ0FBZ0M7SUFDbEcsTUFBTS9GLElBQUlWLCtEQUFXQSxDQUFDLFdBQVc0RyxTQUFTLEtBQUssMkNBQTJDO0lBQzFGLE1BQU1JLElBQUlsQyxTQUFTaUMsSUFBSVYsSUFBSXBDLFdBQVcsZUFBZXZELE1BQU0seURBQXlEO0lBQ3BILE1BQU11RyxPQUFPaEQsV0FBVyxpQkFBaUIrQyxHQUFHRixJQUFJRCxJQUFJLDRDQUE0QztJQUNoRyxNQUFNSyxLQUFLakMsS0FBS29CLElBQUlZLFFBQVEsMkJBQTJCO0lBQ3ZELElBQUlDLE9BQU9uRCxLQUNQLE1BQU0sSUFBSXhCLE1BQU0sMkJBQTJCLGtCQUFrQjtJQUNqRSxNQUFNLEVBQUUwRCxPQUFPa0IsRUFBRSxFQUFFcEIsUUFBUTNDLENBQUMsRUFBRSxHQUFHb0Msb0JBQW9CMEIsS0FBSyxnQkFBZ0I7SUFDMUUsTUFBTUUsSUFBSWQsVUFBVWEsSUFBSUwsSUFBSUQsSUFBSSxnRUFBZ0U7SUFDaEcsTUFBTVEsTUFBTSxJQUFJL0MsV0FBVyxLQUFLLCtDQUErQztJQUMvRStDLElBQUlDLEdBQUcsQ0FBQ0gsSUFBSTtJQUNaRSxJQUFJQyxHQUFHLENBQUN4QyxTQUFTRyxLQUFLN0IsSUFBSWdFLElBQUlMLEtBQUs7SUFDbkMsaUVBQWlFO0lBQ2pFLElBQUksQ0FBQ1EsY0FBY0YsS0FBS1IsR0FBR0MsS0FDdkIsTUFBTSxJQUFJdkUsTUFBTTtJQUNwQixPQUFPOEU7QUFDWDtBQUNBOzs7Q0FHQyxHQUNELFNBQVNFLGNBQWNDLFNBQVMsRUFBRWIsT0FBTyxFQUFFYyxTQUFTO0lBQ2hELE1BQU1KLE1BQU1ySCwrREFBV0EsQ0FBQyxhQUFhd0gsV0FBVztJQUNoRCxNQUFNWCxJQUFJN0csK0RBQVdBLENBQUMsV0FBVzJHO0lBQ2pDLE1BQU1lLE1BQU0xSCwrREFBV0EsQ0FBQyxhQUFheUgsV0FBVztJQUNoRCxJQUFJO1FBQ0EsTUFBTTNHLElBQUlvRixPQUFPRyxJQUFJcUIsT0FBTywwQ0FBMEM7UUFDdEUsTUFBTUMsSUFBSXRCLElBQUlnQixJQUFJTyxRQUFRLENBQUMsR0FBRyxNQUFNLHlDQUF5QztRQUM3RSxJQUFJLENBQUMzSCwyREFBT0EsQ0FBQzBILEdBQUdwSCxLQUFLSCxhQUNqQixPQUFPO1FBQ1gsTUFBTXlILElBQUl4QixJQUFJZ0IsSUFBSU8sUUFBUSxDQUFDLElBQUksTUFBTSwwQ0FBMEM7UUFDL0UsSUFBSSxDQUFDM0gsMkRBQU9BLENBQUM0SCxHQUFHdEgsS0FBS0QsYUFDakIsT0FBTztRQUNYLE1BQU04RyxJQUFJZCxVQUFVeEIsU0FBUzZDLElBQUlqRCxhQUFhNUQsSUFBSStGLElBQUksMENBQTBDO1FBQ2hHLE1BQU1pQixJQUFJMUMsUUFBUXRFLEdBQUcrRyxHQUFHNUMsS0FBSyxDQUFDbUMsS0FBSyxnQkFBZ0I7UUFDbkQsSUFBSSxDQUFDVSxLQUFLLENBQUNBLEVBQUU5QixRQUFRLE1BQU04QixFQUFFQyxRQUFRLEdBQUcvQyxDQUFDLEtBQUsyQyxHQUMxQyxPQUFPLE9BQU8sZ0JBQWdCO1FBQ2xDLE9BQU8sTUFBTSx5REFBeUQ7SUFDMUUsRUFDQSxPQUFPSyxPQUFPO1FBQ1YsT0FBTztJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTUMsVUFBMEIsYUFBSCxHQUFJLEtBQU87UUFDM0NDLGNBQWMxQjtRQUNkMkIsTUFBTXpCO1FBQ04wQixRQUFRYjtRQUNSNUIsT0FBTztZQUNIMEMsa0JBQWtCM0YsVUFBVWlELEtBQUssQ0FBQzBDLGdCQUFnQjtZQUNsRG5DO1lBQ0F4QjtZQUNBeEUsZUFBZUEsaUVBQUFBO1lBQ2ZKLGVBQWVBLGlFQUFBQTtZQUNmbUU7WUFDQXRFLEdBQUdBLHVEQUFBQTtRQUNQO0lBQ0osRUFBQyxJQUFLO0FBQ04sTUFBTTJJLFNBQXlCLGFBQUgsR0FBSSxLQUFNN0ksc0VBQVVBLENBQUMyQyxNQUFNO1FBQ25ELE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7U0FDSDtRQUNELE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7WUFDQTtTQUNIO0tBQ0osQ0FBQ21HLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRCxHQUFHLENBQUMsQ0FBQ0UsSUFBTXBJLE9BQU9vSSxLQUFJO0FBQ3JDLE1BQU1DLFNBQXlCLGFBQUgsR0FBSSxLQUFNdkksNkVBQW1CQSxDQUFDaUMsTUFBTTtRQUM1RHVHLEdBQUd0SSxPQUFPO1FBQ1Z1SSxHQUFHdkksT0FBTztRQUNWd0ksR0FBR3pHLEtBQUswRyxNQUFNLENBQUN6SSxPQUFPO0lBQzFCLEVBQUM7QUFDRCxNQUFNMEksTUFBc0IsYUFBSCxHQUFJLEtBQU12Six3RUFBWUEsQ0FBQ2tELFVBQVV5QyxlQUFlLEVBQUUsQ0FBQzZEO1FBQ3hFLE1BQU0sRUFBRWhFLENBQUMsRUFBRW5FLENBQUMsRUFBRSxHQUFHNkgsT0FBT3RHLEtBQUswRyxNQUFNLENBQUNFLE9BQU8sQ0FBQyxFQUFFO1FBQzlDLE9BQU9WLE9BQU90RCxHQUFHbkU7SUFDckIsR0FBRztRQUNDb0ksS0FBSztRQUNMQyxXQUFXO1FBQ1hyRCxHQUFHekQsS0FBSytHLEtBQUs7UUFDYnRDLEdBQUc7UUFDSHpELEdBQUc7UUFDSGdHLFFBQVE7UUFDUkMsTUFBTWhLLHdEQUFNQTtJQUNoQixFQUFDO0FBQ0QscUZBQXFGLEdBQzlFLE1BQU1pSyxjQUE4QixhQUFILEdBQUksS0FBTVAsSUFBSU8sV0FBVyxJQUFJO0FBQ3JFLHVGQUF1RixHQUNoRixNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1SLElBQUlRLGFBQWEsSUFBSSxDQUN6RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz9kMTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTklTVCBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogU2VlbXMgdG8gYmUgcmlnaWQgKG5vdCBiYWNrZG9vcmVkKVxuICogW2FzIHBlciBkaXNjdXNzaW9uXShodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NSkuXG4gKlxuICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICogW1NlZSBleHBsYW5hdGlvbl0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2KS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFJblJhbmdlLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgaW5SYW5nZSwgbnVtYmVyVG9CeXRlc0JFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBpdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICpcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLCAvLyBlcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnA6IEZwazEsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG4gICAgbjogc2VjcDI1NmsxTiwgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gQ29mYWN0b3JcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGFJblJhbmdlKCd4JywgeCwgXzFuLCBzZWNwMjU2azFQKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWluUmFuZ2UociwgXzFuLCBzZWNwMjU2azFQKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghaW5SYW5nZShzLCBfMW4sIHNlY3AyNTZrMU4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKi9cbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogc2VjcDI1NmsxIGhhc2gtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuLyoqIHNlY3AyNTZrMSBlbmNvZGUtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDdXJ2ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJGaWVsZCIsIm1vZCIsInBvdzIiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJpblJhbmdlIiwibnVtYmVyVG9CeXRlc0JFIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnBrMSIsImVxbCIsInNxciIsIkVycm9yIiwidW5kZWZpbmVkIiwic3FydCIsInNlY3AyNTZrMSIsIkZwIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImVuZG8iLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJrIiwiYTEiLCJiMSIsImEyIiwiUE9XXzJfMTI4IiwiYzEiLCJjMiIsImsxIiwiazIiLCJrMW5lZyIsImsybmVnIiwiXzBuIiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJwb2ludFRvQnl0ZXMiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJzbGljZSIsIm51bVRvMzJiIiwibW9kUCIsIngiLCJtb2ROIiwiUG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJHbXVsQWRkIiwiUSIsIkJBU0UiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInNjaG5vcnJHZXRFeHRQdWJLZXkiLCJwcml2IiwiZF8iLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJwIiwiZnJvbVByaXZhdGVLZXkiLCJzY2FsYXIiLCJoYXNFdmVuWSIsImJ5dGVzIiwibGlmdF94IiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsIm51bSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJzY2hub3JyIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDcUQ7QUFDWDtBQUNwQyxNQUFNSyxhQUFhRiwyQ0FBSUE7SUEyQjFCRyxPQUFPQyxHQUFHLEVBQUU7UUFDUk4sbURBQU9BLENBQUMsSUFBSTtRQUNaLElBQUksQ0FBQ08sS0FBSyxDQUFDRixNQUFNLENBQUNDO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FFLFdBQVdDLEdBQUcsRUFBRTtRQUNaVCxtREFBT0EsQ0FBQyxJQUFJO1FBQ1pELGtEQUFNQSxDQUFDVSxLQUFLLElBQUksQ0FBQ0MsU0FBUztRQUMxQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNKLEtBQUssQ0FBQ0MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNHLEtBQUssQ0FBQ1AsTUFBTSxDQUFDSTtRQUNsQixJQUFJLENBQUNHLEtBQUssQ0FBQ0osVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNJLE9BQU87SUFDaEI7SUFDQUMsU0FBUztRQUNMLE1BQU1MLE1BQU0sSUFBSU0sV0FBVyxJQUFJLENBQUNILEtBQUssQ0FBQ0YsU0FBUztRQUMvQyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBTyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFUixLQUFLLEVBQUVMLEtBQUssRUFBRUksUUFBUSxFQUFFVSxTQUFTLEVBQUVDLFFBQVEsRUFBRVosU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RU8sS0FBS0E7UUFDTEEsR0FBR04sUUFBUSxHQUFHQTtRQUNkTSxHQUFHSSxTQUFTLEdBQUdBO1FBQ2ZKLEdBQUdLLFFBQVEsR0FBR0E7UUFDZEwsR0FBR1AsU0FBUyxHQUFHQTtRQUNmTyxHQUFHTCxLQUFLLEdBQUdBLE1BQU1JLFVBQVUsQ0FBQ0MsR0FBR0wsS0FBSztRQUNwQ0ssR0FBR1YsS0FBSyxHQUFHQSxNQUFNUyxVQUFVLENBQUNDLEdBQUdWLEtBQUs7UUFDcEMsT0FBT1U7SUFDWDtJQUNBSixVQUFVO1FBQ04sSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDVCxLQUFLLENBQUNDLE9BQU87UUFDbEIsSUFBSSxDQUFDTixLQUFLLENBQUNNLE9BQU87SUFDdEI7SUE5REFVLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNkLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLFNBQVMsR0FBRztRQUNqQnBCLGlEQUFLQSxDQUFDdUI7UUFDTixNQUFNRSxNQUFNdkIsa0RBQU9BLENBQUNzQjtRQUNwQixJQUFJLENBQUNsQixLQUFLLEdBQUdpQixLQUFLTCxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNaLEtBQUssQ0FBQ0YsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSXNCLE1BQU07UUFDcEIsSUFBSSxDQUFDTCxRQUFRLEdBQUcsSUFBSSxDQUFDZixLQUFLLENBQUNlLFFBQVE7UUFDbkMsSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDSCxLQUFLLENBQUNHLFNBQVM7UUFDckMsTUFBTVksV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTU0sTUFBTSxJQUFJYixXQUFXTztRQUMzQix3Q0FBd0M7UUFDeENNLElBQUlDLEdBQUcsQ0FBQ0gsSUFBSUksTUFBTSxHQUFHUixXQUFXRSxLQUFLTCxNQUFNLEdBQUdkLE1BQU0sQ0FBQ3FCLEtBQUtaLE1BQU0sS0FBS1k7UUFDckUsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlILElBQUlFLE1BQU0sRUFBRUMsSUFDNUJILEdBQUcsQ0FBQ0csRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDeEIsS0FBSyxDQUFDRixNQUFNLENBQUN1QjtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDaEIsS0FBSyxHQUFHWSxLQUFLTCxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUgsSUFBSUUsTUFBTSxFQUFFQyxJQUM1QkgsR0FBRyxDQUFDRyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNuQixLQUFLLENBQUNQLE1BQU0sQ0FBQ3VCO1FBQ2xCQSxJQUFJSSxJQUFJLENBQUM7SUFDYjtBQXNDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLE9BQU8sQ0FBQ1QsTUFBTUUsS0FBS1EsVUFBWSxJQUFJOUIsS0FBS29CLE1BQU1FLEtBQUtyQixNQUFNLENBQUM2QixTQUFTcEIsTUFBTSxHQUFHO0FBQ3pGbUIsS0FBS2QsTUFBTSxHQUFHLENBQUNLLE1BQU1FLE1BQVEsSUFBSXRCLEtBQUtvQixNQUFNRSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/MGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFleGlzdHMiLCJhaGFzaCIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsInVwZGF0ZSIsImJ1ZiIsImlIYXNoIiwiZGlnZXN0SW50byIsIm91dCIsIm91dHB1dExlbiIsImZpbmlzaGVkIiwib0hhc2giLCJkZXN0cm95IiwiZGlnZXN0IiwiVWludDhBcnJheSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwiZGVzdHJveWVkIiwiYmxvY2tMZW4iLCJjb25zdHJ1Y3RvciIsImhhc2giLCJfa2V5Iiwia2V5IiwiRXJyb3IiLCJwYWQiLCJzZXQiLCJsZW5ndGgiLCJpIiwiZmlsbCIsImhtYWMiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Abi.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Abi.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   from: function() { return /* binding */ from; }\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbi.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbi.js\");\n/* harmony import */ var _internal_abi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/abi.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/internal/abi.js\");\n\n\n/** @internal */ function format(abi) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbi(abi);\n}\n/** @internal */ function from(abi) {\n    if (_internal_abi_js__WEBPACK_IMPORTED_MODULE_1__.isSignatures(abi)) return abitype__WEBPACK_IMPORTED_MODULE_2__.parseAbi(abi);\n    return abi;\n} //# sourceMappingURL=Abi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ1c7QUFDOUMsY0FBYyxHQUNQLFNBQVNFLE9BQU9DLEdBQUc7SUFDdEIsT0FBT0gsOENBQWlCLENBQUNHO0FBQzdCO0FBQ0EsY0FBYyxHQUNQLFNBQVNFLEtBQUtGLEdBQUc7SUFDcEIsSUFBSUYsMERBQXFCLENBQUNFLE1BQ3RCLE9BQU9ILDZDQUFnQixDQUFDRztJQUM1QixPQUFPQTtBQUNYLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpLmpzP2YwNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpKGFiaSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmkpIHtcbiAgICBpZiAoaW50ZXJuYWwuaXNTaWduYXR1cmVzKGFiaSkpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpKGFiaSk7XG4gICAgcmV0dXJuIGFiaTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaS5qcy5tYXAiXSwibmFtZXMiOlsiYWJpdHlwZSIsImludGVybmFsIiwiZm9ybWF0IiwiYWJpIiwiZm9ybWF0QWJpIiwiZnJvbSIsImlzU2lnbmF0dXJlcyIsInBhcnNlQWJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Abi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromAbi: function() { return /* binding */ fromAbi; }\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/** @internal */ function decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0) return undefined;\n    const data = options.data.replace(bytecode, \"0x\");\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */ function encode(abiConstructor, options) {\n    var _abiConstructor_inputs;\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, ((_abiConstructor_inputs = abiConstructor.inputs) === null || _abiConstructor_inputs === void 0 ? void 0 : _abiConstructor_inputs.length) && (args === null || args === void 0 ? void 0 : args.length) ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args) : \"0x\");\n}\n/** @internal */ function format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */ function from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */ function fromAbi(abi) {\n    const item = abi.find((item)=>item.type === \"constructor\");\n    if (!item) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({\n        name: \"constructor\"\n    });\n    return item;\n} //# sourceMappingURL=AbiConstructor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpQ29uc3RydWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDWTtBQUNwQjtBQUNoQyxjQUFjLEdBQ1AsU0FBU0ksT0FBT0MsY0FBYyxFQUFFQyxPQUFPO0lBQzFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdEO0lBQ3JCLElBQUlELGVBQWVHLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLLEdBQ2pDLE9BQU9DO0lBQ1gsTUFBTUMsT0FBT0wsUUFBUUssSUFBSSxDQUFDQyxPQUFPLENBQUNMLFVBQVU7SUFDNUMsT0FBT0wscURBQW9CLENBQUNHLGVBQWVHLE1BQU0sRUFBRUc7QUFDdkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9EQyxHQUNNLFNBQVNFLE9BQU9SLGNBQWMsRUFBRUMsT0FBTztRQUVkRDtJQUQ1QixNQUFNLEVBQUVFLFFBQVEsRUFBRU8sSUFBSSxFQUFFLEdBQUdSO0lBQzNCLE9BQU9ILDJDQUFVLENBQUNJLFVBQVVGLEVBQUFBLHlCQUFBQSxlQUFlRyxNQUFNLGNBQXJCSCw2Q0FBQUEsdUJBQXVCSSxNQUFNLE1BQUlLLGlCQUFBQSwyQkFBQUEsS0FBTUwsTUFBTSxJQUNuRVAscURBQW9CLENBQUNHLGVBQWVHLE1BQU0sRUFBRU0sUUFDNUM7QUFDVjtBQUNBLGNBQWMsR0FDUCxTQUFTRSxPQUFPWCxjQUFjO0lBQ2pDLE9BQU9MLGtEQUFxQixDQUFDSztBQUNqQztBQUNBLGNBQWMsR0FDUCxTQUFTYSxLQUFLYixjQUFjO0lBQy9CLE9BQU9KLDZDQUFZLENBQUNJO0FBQ3hCO0FBQ0EsY0FBYyxHQUNQLFNBQVNjLFFBQVFDLEdBQUc7SUFDdkIsTUFBTUMsT0FBT0QsSUFBSUUsSUFBSSxDQUFDLENBQUNELE9BQVNBLEtBQUtFLElBQUksS0FBSztJQUM5QyxJQUFJLENBQUNGLE1BQ0QsTUFBTSxJQUFJcEIsc0RBQXFCLENBQUM7UUFBRXdCLE1BQU07SUFBYztJQUMxRCxPQUFPSjtBQUNYLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpQ29uc3RydWN0b3IuanM/NmNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWJpSXRlbSBmcm9tICcuL0FiaUl0ZW0uanMnO1xuaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYWJpQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJ5dGVjb2RlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhYmlDb25zdHJ1Y3Rvci5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEucmVwbGFjZShieXRlY29kZSwgJzB4Jyk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgZGF0YSk7XG59XG4vKipcbiAqIEFCSS1lbmNvZGVzIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RvciBpbnB1dCAoYGlucHV0c2ApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpQ29uc3RydWN0b3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjb25zdHJ1Y3RvciA9IEFiaUNvbnN0cnVjdG9yLmZyb20oJ2NvbnN0cnVjdG9yKGFkZHJlc3MsIHVpbnQyNTYpJylcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpQ29uc3RydWN0b3IuZW5jb2RlKGNvbnN0cnVjdG9yLCB7XG4gKiAgIGJ5dGVjb2RlOiAnMHguLi4nLFxuICogICBhcmdzOiBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDEyM25dLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5kLXRvLWVuZFxuICpcbiAqIEJlbG93IGlzIGFuIGVuZC10by1lbmQgZXhhbXBsZSBvZiB1c2luZyBgQWJpQ29uc3RydWN0b3IuZW5jb2RlYCB0byBlbmNvZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGEgY29udHJhY3QgYW5kIGRlcGxveSBpdC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBBYmlDb25zdHJ1Y3RvciwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogLy8gMS4gSW5zdGFudGlhdGUgdGhlIEFCSSBDb25zdHJ1Y3Rvci5cbiAqIGNvbnN0IGNvbnN0cnVjdG9yID0gQWJpQ29uc3RydWN0b3IuZnJvbShcbiAqICAgJ2NvbnN0cnVjdG9yKGFkZHJlc3Mgb3duZXIsIHVpbnQyNTYgYW1vdW50KScsXG4gKiApXG4gKlxuICogLy8gMi4gRW5jb2RlIHRoZSBBQkkgQ29uc3RydWN0b3IuXG4gKiBjb25zdCBkYXRhID0gQWJpQ29uc3RydWN0b3IuZW5jb2RlKGNvbnN0cnVjdG9yLCB7XG4gKiAgIGJ5dGVjb2RlOiAnMHguLi4nLFxuICogICBhcmdzOiBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDEyM25dLFxuICogfSlcbiAqXG4gKiAvLyAzLiBEZXBsb3kgdGhlIGNvbnRyYWN0LlxuICogY29uc3QgaGFzaCA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICogICBwYXJhbXM6IFt7IGRhdGEgfV0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEZvciBzaW1wbGljaXR5LCB0aGUgYWJvdmUgZXhhbXBsZSB1c2VzIGB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdGAsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAqIHR5cGUgb2YgSlNPTi1SUEMgaW50ZXJmYWNlLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSBhYmlDb25zdHJ1Y3RvciAtIFRoZSBBQkkgQ29uc3RydWN0b3IgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoYWJpQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJ5dGVjb2RlLCBhcmdzIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIZXguY29uY2F0KGJ5dGVjb2RlLCBhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCAmJiBhcmdzPy5sZW5ndGhcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGFyZ3MpXG4gICAgICAgIDogJzB4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlDb25zdHJ1Y3Rvcik7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBBYmlJdGVtLmZyb20oYWJpQ29uc3RydWN0b3IpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpKSB7XG4gICAgY29uc3QgaXRlbSA9IGFiaS5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicpO1xuICAgIGlmICghaXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWU6ICdjb25zdHJ1Y3RvcicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlDb25zdHJ1Y3Rvci5qcy5tYXAiXSwibmFtZXMiOlsiYWJpdHlwZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwiZGVjb2RlIiwiYWJpQ29uc3RydWN0b3IiLCJvcHRpb25zIiwiYnl0ZWNvZGUiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJkYXRhIiwicmVwbGFjZSIsImVuY29kZSIsImFyZ3MiLCJjb25jYXQiLCJmb3JtYXQiLCJmb3JtYXRBYmlJdGVtIiwiZnJvbSIsImZyb21BYmkiLCJhYmkiLCJpdGVtIiwiZmluZCIsInR5cGUiLCJOb3RGb3VuZEVycm9yIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AbiConstructor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiFunction.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: function() { return /* binding */ decodeData; },\n/* harmony export */   decodeResult: function() { return /* binding */ decodeResult; },\n/* harmony export */   encodeData: function() { return /* binding */ encodeData; },\n/* harmony export */   encodeResult: function() { return /* binding */ encodeResult; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromAbi: function() { return /* binding */ fromAbi; },\n/* harmony export */   getSelector: function() { return /* binding */ getSelector; }\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */ function decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({\n        data\n    });\n    if (abiFunction.inputs.length === 0) return undefined;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], data) : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4) return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */ function decodeResult(abiFunction, data) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0) return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values)) return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */ function encodeData(abiFunction) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    const { overloads } = abiFunction;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], abiFunction.name, {\n        args: args[0]\n    }) : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args[0]) : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */ function encodeResult(abiFunction, output) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const { as = \"Array\" } = options;\n    const values = (()=>{\n        if (abiFunction.outputs.length === 1) return [\n            output\n        ];\n        if (Array.isArray(output)) return output;\n        if (as === \"Object\") return Object.values(output);\n        return [\n            output\n        ];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */ function format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */ function from(abiFunction) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== \"function\") throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({\n        name,\n        type: \"function\"\n    });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */ function getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n} //# sourceMappingURL=AbiFunction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpRnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDWTtBQUNwQjtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0ksV0FBV0MsV0FBVyxFQUFFQyxJQUFJO0lBQ3hDLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdGO0lBQ3RCLElBQUlGLHlDQUFRLENBQUNHLFFBQVEsR0FDakIsTUFBTSxJQUFJTCxpRUFBZ0MsQ0FBQztRQUFFSztJQUFLO0lBQ3RELElBQUlELFlBQVlLLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLLEdBQzlCLE9BQU9DO0lBQ1gsTUFBTUMsT0FBT04sWUFDUE8sUUFBUTtRQUFDVDtXQUFnQkU7S0FBVSxFQUFFRCxRQUNyQ0Q7SUFDTixJQUFJRix5Q0FBUSxDQUFDRyxTQUFTLEdBQ2xCLE9BQU9NO0lBQ1gsT0FBT1YscURBQW9CLENBQUNXLEtBQUtILE1BQU0sRUFBRVAsMENBQVMsQ0FBQ0csTUFBTTtBQUM3RDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStGQyxHQUNNLFNBQVNXLGFBQWFaLFdBQVcsRUFBRUMsSUFBSTtRQUFFWSxVQUFBQSxpRUFBVSxDQUFDO0lBQ3ZELE1BQU1DLFNBQVNqQixxREFBb0IsQ0FBQ0csWUFBWWUsT0FBTyxFQUFFZCxNQUFNWTtJQUMvRCxJQUFJQyxVQUFVRSxPQUFPQyxJQUFJLENBQUNILFFBQVFSLE1BQU0sS0FBSyxHQUN6QyxPQUFPQztJQUNYLElBQUlPLFVBQVVFLE9BQU9DLElBQUksQ0FBQ0gsUUFBUVIsTUFBTSxLQUFLLEdBQUc7UUFDNUMsSUFBSVksTUFBTUMsT0FBTyxDQUFDTCxTQUNkLE9BQU9BLE1BQU0sQ0FBQyxFQUFFO1FBQ3BCLE9BQU9FLE9BQU9GLE1BQU0sQ0FBQ0EsT0FBTyxDQUFDLEVBQUU7SUFDbkM7SUFDQSxPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0ZDLEdBQ00sU0FBU00sV0FBV3BCLFdBQVc7SUFBRTtRQUFHcUIsS0FBSCwyQkFBTzs7SUFDM0MsTUFBTSxFQUFFbkIsU0FBUyxFQUFFLEdBQUdGO0lBQ3RCLE1BQU1RLE9BQU9OLFlBQ1BPLFFBQVE7UUFBQ1Q7V0FBZ0JFO0tBQVUsRUFBRUYsWUFBWXNCLElBQUksRUFBRTtRQUNyREQsTUFBTUEsSUFBSSxDQUFDLEVBQUU7SUFDakIsS0FDRXJCO0lBQ04sTUFBTXVCLFdBQVdDLFlBQVloQjtJQUM3QixNQUFNUCxPQUFPb0IsS0FBS2YsTUFBTSxHQUFHLElBQ3JCVCxxREFBb0IsQ0FBQ1csS0FBS0gsTUFBTSxFQUFFZ0IsSUFBSSxDQUFDLEVBQUUsSUFDekNkO0lBQ04sT0FBT04sT0FBT0gsMkNBQVUsQ0FBQ3lCLFVBQVV0QixRQUFRc0I7QUFDL0M7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNJLGFBQWEzQixXQUFXLEVBQUU0QixNQUFNO1FBQUVmLFVBQUFBLGlFQUFVLENBQUM7SUFDekQsTUFBTSxFQUFFZ0IsS0FBSyxPQUFPLEVBQUUsR0FBR2hCO0lBQ3pCLE1BQU1DLFNBQVMsQ0FBQztRQUNaLElBQUlkLFlBQVllLE9BQU8sQ0FBQ1QsTUFBTSxLQUFLLEdBQy9CLE9BQU87WUFBQ3NCO1NBQU87UUFDbkIsSUFBSVYsTUFBTUMsT0FBTyxDQUFDUyxTQUNkLE9BQU9BO1FBQ1gsSUFBSUMsT0FBTyxVQUNQLE9BQU9iLE9BQU9GLE1BQU0sQ0FBQ2M7UUFDekIsT0FBTztZQUFDQTtTQUFPO0lBQ25CO0lBQ0EsT0FBTy9CLHFEQUFvQixDQUFDRyxZQUFZZSxPQUFPLEVBQUVEO0FBQ3JEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0NDLEdBQ00sU0FBU2dCLE9BQU85QixXQUFXO0lBQzlCLE9BQU9MLGtEQUFxQixDQUFDSztBQUNqQztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzR0MsR0FDTSxTQUFTZ0MsS0FBS2hDLFdBQVc7UUFBRWEsVUFBQUEsaUVBQVUsQ0FBQztJQUN6QyxPQUFPakIsNkNBQVksQ0FBQ0ksYUFBYWE7QUFDckM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdFQyxHQUNNLFNBQVNKLFFBQVF3QixHQUFHLEVBQUVYLElBQUksRUFBRVQsT0FBTztJQUN0QyxNQUFNTCxPQUFPWixnREFBZSxDQUFDcUMsS0FBS1gsTUFBTVQ7SUFDeEMsSUFBSUwsS0FBSzBCLElBQUksS0FBSyxZQUNkLE1BQU0sSUFBSXRDLHNEQUFxQixDQUFDO1FBQUUwQjtRQUFNWSxNQUFNO0lBQVc7SUFDN0QsT0FBTzFCO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDTSxTQUFTZ0IsWUFBWVksT0FBTztJQUMvQixPQUFPeEMsb0RBQW1CLENBQUN3QztBQUMvQixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzPzIyODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIEFCSS1kZWNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlIEFCSSBJdGVtJ3MgaW5wdXQgdHlwZXMgKGBpbnB1dHNgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKlxuICogY29uc3QgaW5wdXQgPSBBYmlGdW5jdGlvbi5kZWNvZGVEYXRhKGFwcHJvdmUsIGRhdGEpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUZ1bmN0aW9uIC0gVGhlIEFCSSBJdGVtIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gZGVjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YShhYmlGdW5jdGlvbiwgZGF0YSkge1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPCA0KVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IoeyBkYXRhIH0pO1xuICAgIGlmIChhYmlGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgZGF0YSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPD0gNClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoaXRlbS5pbnB1dHMsIEhleC5zbGljZShkYXRhLCA0KSk7XG59XG4vKipcbiAqIEFCSS1kZWNvZGVzIGEgZnVuY3Rpb24ncyByZXN1bHQgYWNjb3JkaW5nIHRvIHRoZSBBQkkgSXRlbSdzIG91dHB1dCB0eXBlcyAoYG91dHB1dHNgKS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSB1c2VkIHRvIGRlY29kZSBjb250cmFjdCBmdW5jdGlvbiByZXR1cm4gdmFsdWVzIChlLmcuIHRoZSByZXNwb25zZSBvZiBhbiBgZXRoX2NhbGxgIG9yIHRoZSBgaW5wdXRgIHByb3BlcnR5IG9mIGEgVHJhbnNhY3Rpb24pLlxuICpcbiAqIFNlZSB0aGUgW0VuZC10by1lbmQgRXhhbXBsZV0oI2VuZC10by1lbmQpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFlvdSBjYW4gZXh0cmFjdCBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhIEpTT04gQUJJIHdpdGgge0BsaW5rIG94I0FiaUZ1bmN0aW9uLihmcm9tQWJpOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJ1xuICpcbiAqIGNvbnN0IGVyYzIwQWJpID0gQWJpLmZyb20oWy4uLl0pIC8vIFshY29kZSBobF1cbiAqIGNvbnN0IHRvdGFsU3VwcGx5ID0gQWJpRnVuY3Rpb24uZnJvbUFiaShlcmMyMEFiaSwgJ3RvdGFsU3VwcGx5JykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHRgIHRvIGRlY29kZSB0aGUgcmVzdWx0IG9mIGEgYGJhbGFuY2VPZmAgY29udHJhY3QgY2FsbCBvbiB0aGUgW1dhZ21pIE1pbnQgRXhhbXBsZSBjb250cmFjdF0oaHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzIpLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBFeHRyYWN0IHRoZSBGdW5jdGlvbiBmcm9tIHRoZSBDb250cmFjdCdzIEFCSS5cbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgLy8gLi4uXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYmFsYW5jZU9mJyxcbiAqICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICAgIGlucHV0czogW3sgbmFtZTogJ2FjY291bnQnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gKiAgICAgb3V0cHV0czogW3sgbmFtZTogJ2JhbGFuY2UnLCB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiAgIH0sXG4gKiAgIC8vIC4uLlxuICogXSlcbiAqIGNvbnN0IGJhbGFuY2VPZiA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnYmFsYW5jZU9mJylcbiAqXG4gKiAvLyAyLiBFbmNvZGUgdGhlIEZ1bmN0aW9uIElucHV0LlxuICogY29uc3QgZGF0YSA9IEFiaUZ1bmN0aW9uLmVuY29kZURhdGEoXG4gKiAgIGJhbGFuY2VPZixcbiAqICAgWycweGQyMTM1Q2ZCMjE2Yjc0MTA5Nzc1MjM2RTM2ZDRiNDMzRjFERjUwN0InXVxuICogKVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgYmFsYW5jZSA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdChiYWxhbmNlT2YsIHJlc3BvbnNlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiA0Mm5cbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZGVjb2RlXG4gKiBAcGFyYW0gZGF0YSAtIEFCSS1lbmNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBEZWNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmVzdWx0KGFiaUZ1bmN0aW9uLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEFCSS1lbmNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyAoYGlucHV0c2ApLCBwcmVmaXhlZCB3aXRoIHRoZSA0IGJ5dGUgZnVuY3Rpb24gc2VsZWN0b3IuXG4gKlxuICogOjo6dGlwXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgdXNlZCB0byBlbmNvZGUgYSBjb250cmFjdCBmdW5jdGlvbiBhbmQgaXRzIGFyZ3VtZW50cyBmb3IgY29udHJhY3QgY2FsbHMgKGUuZy4gYGRhdGFgIHBhcmFtZXRlciBvZiBhbiBgZXRoX2NhbGxgIG9yIGBldGhfc2VuZFRyYW5zYWN0aW9uYCkuXG4gKlxuICogU2VlIHRoZSBbRW5kLXRvLWVuZCBFeGFtcGxlXSgjZW5kLXRvLWVuZCkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKCdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3MsIHVpbnQyNTYpJylcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpRnVuY3Rpb24uZW5jb2RlRGF0YSggLy8gWyFjb2RlIGZvY3VzXVxuICogICBhcHByb3ZlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXSAvLyBbIWNvZGUgZm9jdXNdXG4gKiApIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogWW91IGNhbiBleHRyYWN0IGFuIEFCSSBGdW5jdGlvbiBmcm9tIGEgSlNPTiBBQkkgd2l0aCB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZXJjMjBBYmkgPSBBYmkuZnJvbShbLi4uXSkgLy8gWyFjb2RlIGhsXVxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoZXJjMjBBYmksICdhcHByb3ZlJykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEVuZC10by1lbmRcbiAqXG4gKiBCZWxvdyBpcyBhbiBlbmQtdG8tZW5kIGV4YW1wbGUgb2YgdXNpbmcgYEFiaUZ1bmN0aW9uLmVuY29kZURhdGFgIHRvIGVuY29kZSB0aGUgaW5wdXQgb2YgYSBgYmFsYW5jZU9mYCBjb250cmFjdCBjYWxsIG9uIHRoZSBbV2FnbWkgTWludCBFeGFtcGxlIGNvbnRyYWN0XShodHRwczovL2V0aGVyc2Nhbi5pby9hZGRyZXNzLzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMikuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIC8vIDEuIEV4dHJhY3QgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIENvbnRyYWN0J3MgQUJJLlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAvLyAuLi5cbiAqICAge1xuICogICAgIG5hbWU6ICdiYWxhbmNlT2YnLFxuICogICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgICAgaW5wdXRzOiBbeyBuYW1lOiAnYWNjb3VudCcsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAqICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnYmFsYW5jZScsIHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgfSxcbiAqICAgLy8gLi4uXG4gKiBdKVxuICogY29uc3QgYmFsYW5jZU9mID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdiYWxhbmNlT2YnKVxuICpcbiAqIC8vIDIuIEVuY29kZSB0aGUgRnVuY3Rpb24gSW5wdXQuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGJhbGFuY2VPZiwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBbJzB4ZDIxMzVDZkIyMTZiNzQxMDk3NzUyMzZFMzZkNGI0MzNGMURGNTA3QiddIC8vIFshY29kZSBmb2N1c11cbiAqICkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC5cbiAqIGNvbnN0IGJhbGFuY2UgPSBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHQoYmFsYW5jZU9mLCByZXNwb25zZSlcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZW5jb2RlXG4gKiBAcGFyYW0gYXJncyAtIEZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybnMgQUJJLWVuY29kZWQgZnVuY3Rpb24gbmFtZSBhbmQgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRhKGFiaUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgYWJpRnVuY3Rpb24ubmFtZSwge1xuICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGl0ZW0pO1xuICAgIGNvbnN0IGRhdGEgPSBhcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShpdGVtLmlucHV0cywgYXJnc1swXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRhdGEgPyBIZXguY29uY2F0KHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xufVxuLyoqXG4gKiBBQkktZW5jb2RlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0IChgb3V0cHV0c2ApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICogY29uc3Qgb3V0cHV0ID0gQWJpRnVuY3Rpb24uZGVjb2RlUmVzdWx0KHRvdGFsU3VwcGx5LCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJylcbiAqIC8vIDQyblxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVSZXN1bHQodG90YWxTdXBwbHksIDQybikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgaXRlbSB0byBlbmNvZGUgdGhlIGZ1bmN0aW9uIG91dHB1dCBmb3IuXG4gKiBAcGFyYW0gb3V0cHV0IC0gVGhlIGZ1bmN0aW9uIG91dHB1dCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBmdW5jdGlvbiBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZXN1bHQoYWJpRnVuY3Rpb24sIG91dHB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFiaUZ1bmN0aW9uLm91dHB1dHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgaWYgKGFzID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUZ1bmN0aW9uLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlGdW5jdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBGdW5jdGlvbioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUeXBlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgTmFtZVxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdmb28nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSBvclxuICogZnJvbSBhIFRyYW5zYWN0aW9uIGBpbnB1dGAuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiYWJpdHlwZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwiZGVjb2RlRGF0YSIsImFiaUZ1bmN0aW9uIiwiZGF0YSIsIm92ZXJsb2FkcyIsInNpemUiLCJJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpdGVtIiwiZnJvbUFiaSIsImRlY29kZSIsInNsaWNlIiwiZGVjb2RlUmVzdWx0Iiwib3B0aW9ucyIsInZhbHVlcyIsIm91dHB1dHMiLCJPYmplY3QiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwiZW5jb2RlRGF0YSIsImFyZ3MiLCJuYW1lIiwic2VsZWN0b3IiLCJnZXRTZWxlY3RvciIsImVuY29kZSIsImNvbmNhdCIsImVuY29kZVJlc3VsdCIsIm91dHB1dCIsImFzIiwiZm9ybWF0IiwiZm9ybWF0QWJpSXRlbSIsImZyb20iLCJhYmkiLCJ0eXBlIiwiTm90Rm91bmRFcnJvciIsImFiaUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AbiFunction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiItem.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: function() { return /* binding */ AmbiguityError; },\n/* harmony export */   InvalidSelectorSizeError: function() { return /* binding */ InvalidSelectorSizeError; },\n/* harmony export */   NotFoundError: function() { return /* binding */ NotFoundError; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromAbi: function() { return /* binding */ fromAbi; },\n/* harmony export */   getSelector: function() { return /* binding */ getSelector; },\n/* harmony export */   getSignature: function() { return /* binding */ getSignature; },\n/* harmony export */   getSignatureHash: function() { return /* binding */ getSignatureHash; }\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */ function format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */ function from(abiItem) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { prepare = true } = options;\n    const item = (()=>{\n        if (Array.isArray(abiItem)) return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...prepare ? {\n            hash: getSignatureHash(item)\n        } : {}\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = options !== null && options !== void 0 ? options : {};\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, {\n        strict: false\n    });\n    const abiItems = abi.filter((abiItem)=>{\n        if (isSelector) {\n            if (abiItem.type === \"function\" || abiItem.type === \"error\") return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === \"event\") return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return \"name\" in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0) throw new NotFoundError({\n        name: name\n    });\n    if (abiItems.length === 1) return {\n        ...abiItems[0],\n        ...prepare ? {\n            hash: getSignatureHash(abiItems[0])\n        } : {}\n    };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems){\n        if (!(\"inputs\" in abiItem)) continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0) return {\n                ...abiItem,\n                ...prepare ? {\n                    hash: getSignatureHash(abiItem)\n                } : {}\n            };\n            continue;\n        }\n        if (!abiItem.inputs) continue;\n        if (abiItem.inputs.length === 0) continue;\n        if (abiItem.inputs.length !== args.length) continue;\n        const matched = args.every((arg, index)=>{\n            const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index];\n            if (!abiParameter) return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes) throw new AmbiguityError({\n                    abiItem,\n                    type: ambiguousTypes[0]\n                }, {\n                    abiItem: matchedAbiItem,\n                    type: ambiguousTypes[1]\n                });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (()=>{\n        if (matchedAbiItem) return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return {\n            ...abiItem,\n            overloads\n        };\n    })();\n    if (!abiItem) throw new NotFoundError({\n        name: name\n    });\n    return {\n        ...abiItem,\n        ...prepare ? {\n            hash: getSignatureHash(abiItem)\n        } : {}\n    };\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */ function getSelector(abiItem) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */ function getSignature(abiItem) {\n    const signature = (()=>{\n        if (typeof abiItem === \"string\") return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */ function getSignatureHash(abiItem) {\n    if (typeof abiItem !== \"string\" && \"hash\" in abiItem && abiItem.hash) return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */ class AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y){\n        super(\"Found ambiguous types in overloaded ABI Items.\", {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                \"`\".concat(x.type, \"` in `\").concat(_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem)), \"`, and\"),\n                \"`\".concat(y.type, \"` in `\").concat(_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem)), \"`\"),\n                \"\",\n                \"These types encode differently and cannot be distinguished at runtime.\",\n                \"Remove one of the ambiguous items in the ABI.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.AmbiguityError\"\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */ class NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = \"item\" }){\n        const selector = (()=>{\n            if (name) return ' with name \"'.concat(name, '\"');\n            if (data) return ' with data \"'.concat(data, '\"');\n            return \"\";\n        })();\n        super(\"ABI \".concat(type).concat(selector, \" not found.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.NotFoundError\"\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */ class InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }){\n        super(\"Selector size is invalid. Expected 4 bytes. Received \".concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data), ' bytes (\"').concat(data, '\").'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.InvalidSelectorSizeError\"\n        });\n    }\n} //# sourceMappingURL=AbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDRztBQUNKO0FBQ0Y7QUFDa0I7QUFDbEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0NDLEdBQ00sU0FBU0ssT0FBT0MsT0FBTztJQUMxQixPQUFPTixrREFBcUIsQ0FBQ007QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0dDLEdBQ00sU0FBU0UsS0FBS0YsT0FBTztRQUFFRyxVQUFBQSxpRUFBVSxDQUFDO0lBQ3JDLE1BQU0sRUFBRUMsVUFBVSxJQUFJLEVBQUUsR0FBR0Q7SUFDM0IsTUFBTUUsT0FBTyxDQUFDO1FBQ1YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDUCxVQUNkLE9BQU9OLGlEQUFvQixDQUFDTTtRQUNoQyxJQUFJLE9BQU9BLFlBQVksVUFDbkIsT0FBT04saURBQW9CLENBQUNNO1FBQ2hDLE9BQU9BO0lBQ1g7SUFDQSxPQUFPO1FBQ0gsR0FBR0ssSUFBSTtRQUNQLEdBQUlELFVBQVU7WUFBRUssTUFBTUMsaUJBQWlCTDtRQUFNLElBQUksQ0FBQyxDQUFDO0lBQ3ZEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0VDLEdBQ00sU0FBU00sUUFBUUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVWLE9BQU87SUFDdEMsTUFBTSxFQUFFVyxPQUFPLEVBQUUsRUFBRVYsVUFBVSxJQUFJLEVBQUUsR0FBSUQsb0JBQUFBLHFCQUFBQSxVQUNuQyxDQUFDO0lBQ0wsTUFBTVksYUFBYWxCLDZDQUFZLENBQUNnQixNQUFNO1FBQUVJ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N0IsaURBQWdCO0lBQy9DaUQsWUFBWSxFQUFFL0IsSUFBSSxFQUFFeUMsSUFBSSxFQUFFbEMsT0FBTyxNQUFNLEVBQUcsQ0FBRTtRQUN4QyxNQUFNbUMsV0FBVyxDQUFDO1lBQ2QsSUFBSTFDLE1BQ0EsT0FBTyxlQUFvQixPQUFMQSxNQUFLO1lBQy9CLElBQUl5QyxNQUNBLE9BQU8sZUFBb0IsT0FBTEEsTUFBSztZQUMvQixPQUFPO1FBQ1g7UUFDQSxLQUFLLENBQUMsT0FBY0MsT0FBUG5DLE1BQWdCLE9BQVRtQyxVQUFTO1FBQzdCUCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDTSxNQUFNRyxpQ0FBaUM3RCxpREFBZ0I7SUFDMURpRCxZQUFZLEVBQUVVLElBQUksRUFBRSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyx3REFBa0ZBLE9BQTFCekQseUNBQVEsQ0FBQ3lELE9BQU0sYUFBZ0IsT0FBTEEsTUFBSztRQUM3Rk4sT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcz9lZTUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpSXRlbS5qcyc7XG4vKipcbiAqIEZvcm1hdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlJdGVtLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBJdGVtICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpSXRlbSkge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBJdGVtKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgSXRlbSoqIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZnVuY3Rpb24gYXBwcm92ZShGb28gZm9vKSByZXR1cm5zIChib29sKScsXG4gKiBdKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIEl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFCSSBJdGVtcyBjYW4gYmUgZXh0cmFjdGVkIGJ5IHRoZWlyIG5hbWUgdXNpbmcgdGhlIGBuYW1lYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICdUcmFuc2ZlcicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3QgYnkgdGhlaXIgc2VsZWN0b3Igd2hlbiB7QGxpbmsgb3gjSGV4LkhleH0gaXMgcHJvdmlkZWQgdG8gYG5hbWVgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgSXRlbSBmcm9tIGFuIGBldGhfY2FsbGAgUlBDIHJlc3BvbnNlLFxuICogYSBUcmFuc2FjdGlvbiBgaW5wdXRgLCBvciBmcm9tIEV2ZW50IExvZyBgdG9waWNzYC5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzID0gW10sIHByZXBhcmUgPSB0cnVlIH0gPSAob3B0aW9ucyA/P1xuICAgICAgICB7fSk7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgYWJpSXRlbXMgPSBhYmkuZmlsdGVyKChhYmlJdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nIHx8IGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbSkgPT09IEhleC5zbGljZShuYW1lLCAwLCA0KTtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICduYW1lJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxuICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbXNbMF0pIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgYWJpSXRlbSBvZiBhYmlJdGVtcykge1xuICAgICAgICBpZiAoISgnaW5wdXRzJyBpbiBhYmlJdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMgfHwgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gJ2lucHV0cycgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwuaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbWJpZ3VpdHkgYWdhaW5zdCBhbHJlYWR5IG1hdGNoZWQgcGFyYW1ldGVycyAoZS5nLiBgYWRkcmVzc2AgdnMgYGJ5dGVzMjBgKS5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgICdpbnB1dHMnIGluIG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBpbnRlcm5hbC5nZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzVHlwZXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEFiaUl0ZW07XG4gICAgICAgIGNvbnN0IFthYmlJdGVtLCAuLi5vdmVybG9hZHNdID0gYWJpSXRlbXM7XG4gICAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0sIG92ZXJsb2FkcyB9O1xuICAgIH0pKCk7XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgWzQtYnl0ZSBzZWxlY3Rvcl0oaHR0cHM6Ly9zb2xpZGl0eS1ieS1leGFtcGxlLm9yZy9mdW5jdGlvbi1zZWxlY3Rvci8pIGZvciBhbiB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNlbGVjdG9yID0gQWJpSXRlbS5nZXRTZWxlY3RvcignZnVuY3Rpb24gb3duZXJPZih1aW50MjU2IHRva2VuSWQpJylcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlJdGVtLmdldFNlbGVjdG9yKHtcbiAqICAgaW5wdXRzOiBbeyB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgIG5hbWU6ICdvd25lck9mJyxcbiAqICAgb3V0cHV0czogW10sXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICogICB0eXBlOiAnZnVuY3Rpb24nXG4gKiB9KVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgaXRlbSB0byBjb21wdXRlIHRoZSBzZWxlY3RvciBmb3IuIENhbiBiZSBhIHNpZ25hdHVyZSBvciBhbiBBQkkgaXRlbSBmb3IgYW4gZXJyb3IsIGV2ZW50LCBmdW5jdGlvbiwgZXRjLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEhleC5zbGljZShnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pLCAwLCA0KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHN0cmluZ2lmaWVkIHNpZ25hdHVyZSBmb3IgYSBnaXZlbiB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBBYmlJdGVtLmdldFNpZ25hdHVyZSgnZnVuY3Rpb24gb3duZXJPZih1aW50MjU2IHRva2VuSWQpJylcbiAqIC8vIEBsb2c6ICdvd25lck9mKHVpbnQyNTYpJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gQWJpSXRlbS5nZXRTaWduYXR1cmUoe1xuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIGlucHV0czogW3sgbmFtZTogJ3Rva2VuSWQnLCB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqIH0pXG4gKiAvLyBAbG9nOiAnb3duZXJPZih1aW50MjU2KSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBJdGVtIHRvIGNvbXB1dGUgdGhlIHNpZ25hdHVyZSBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5naWZpZWQgc2lnbmF0dXJlIG9mIHRoZSBBQkkgSXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZShhYmlJdGVtKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhYmlJdGVtID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgICAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2lnbmF0dXJlIGhhc2ggZm9yIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19LlxuICpcbiAqIFVzZWZ1bCBmb3IgY29tcHV0aW5nIEV2ZW50IFRvcGljIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoYXNoID0gQWJpSXRlbS5nZXRTaWduYXR1cmVIYXNoKCdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IGFtb3VudCknKVxuICogLy8gQGxvZzogJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGhhc2ggPSBBYmlJdGVtLmdldFNpZ25hdHVyZUhhc2goe1xuICogICBuYW1lOiAnVHJhbnNmZXInLFxuICogICB0eXBlOiAnZXZlbnQnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7IG5hbWU6ICdmcm9tJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiB0cnVlIH0sXG4gKiAgICAgeyBuYW1lOiAndG8nLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IHRydWUgfSxcbiAqICAgICB7IG5hbWU6ICdhbW91bnQnLCB0eXBlOiAndWludDI1NicsIGluZGV4ZWQ6IGZhbHNlIH0sXG4gKiAgIF0sXG4gKiB9KVxuICogLy8gQGxvZzogJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBJdGVtIHRvIGNvbXB1dGUgdGhlIHNpZ25hdHVyZSBoYXNoIGZvci5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjSGFzaC4oa2VjY2FrMjU2OmZ1bmN0aW9uKX0gaGFzaCBvZiB0aGUgQUJJIGl0ZW0ncyBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGFiaUl0ZW0gIT09ICdzdHJpbmcnICYmICdoYXNoJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaGFzaClcbiAgICAgICAgcmV0dXJuIGFiaUl0ZW0uaGFzaDtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoZ2V0U2lnbmF0dXJlKGFiaUl0ZW0pKSk7XG59XG4vKipcbiAqIFRocm93cyB3aGVuIGFtYmlndW91cyB0eXBlcyBhcmUgZm91bmQgb24gb3ZlcmxvYWRlZCBBQkkgaXRlbXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oWydmdW5jdGlvbiBmb28oYWRkcmVzcyknLCAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJ10pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2ZvbycsIHtcbiAqICAgYXJnczogWycweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uQW1iaWd1aXR5RXJyb3I6IEZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy5cbiAqIC8vIEBlcnJvcjogYGJ5dGVzMjBgIGluIGBmb28oYnl0ZXMyMClgLCBhbmRcbiAqIC8vIEBlcnJvcjogYGFkZHJlc3NgIGluIGBmb28oYWRkcmVzcylgXG4gKiAvLyBAZXJyb3I6IFRoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS5cbiAqIC8vIEBlcnJvcjogUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgdHlwZXMgZnJvbSB0aGUgQUJJLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGZvbyhieXRlczIwKScgLy8gWyFjb2RlIC0tXVxuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQW1iaWd1aXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIHN1cGVyKCdGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWJpdHlwZSB0byBhZGQgc3VwcG9ydCBmb3Igc2lnbmF0dXJlLWZvcm1hdHRlZCBBQkkgaXRlbXMuXG4gICAgICAgICAgICAgICAgYFxcYCR7eC50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeC5hYmlJdGVtKSl9XFxgLCBhbmRgLFxuICAgICAgICAgICAgICAgIGBcXGAke3kudHlwZX1cXGAgaW4gXFxgJHtpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoYWJpdHlwZS5mb3JtYXRBYmlJdGVtKHkuYWJpSXRlbSkpfVxcYGAsXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgJ1RoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS4nLFxuICAgICAgICAgICAgICAgICdSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLkFtYmlndWl0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIGFuIEFCSSBpdGVtIGlzIG5vdCBmb3VuZCBpbiB0aGUgQUJJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uTm90Rm91bmRFcnJvcjogQUJJIGZ1bmN0aW9uIHdpdGggbmFtZSBcImJhelwiIG5vdCBmb3VuZC5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIEVuc3VyZSB0aGUgQUJJIGl0ZW0gZXhpc3RzIG9uIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknLFxuICogICAnZnVuY3Rpb24gYmF6KGJvb2wpJyAvLyBbIWNvZGUgKytdXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdiYXonKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBuYW1lLCBkYXRhLCB0eXBlID0gJ2l0ZW0nLCB9KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggbmFtZSBcIiR7bmFtZX1cImA7XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCB3aXRoIGRhdGEgXCIke2RhdGF9XCJgO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KSgpO1xuICAgICAgICBzdXBlcihgQUJJICR7dHlwZX0ke3NlbGVjdG9yfSBub3QgZm91bmQuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLk5vdEZvdW5kRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIHNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnMHhhYWEnKVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcjogU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAyIGJ5dGVzIChcIjB4YWFhXCIpLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBzZWxlY3RvciBzaXplIGlzIDQgYnl0ZXMuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweDdhZjgyYjFhJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoYFNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC4gRXhwZWN0ZWQgNCBieXRlcy4gUmVjZWl2ZWQgJHtIZXguc2l6ZShkYXRhKX0gYnl0ZXMgKFwiJHtkYXRhfVwiKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6WyJhYml0eXBlIiwiRXJyb3JzIiwiSGFzaCIsIkhleCIsImludGVybmFsIiwiZm9ybWF0IiwiYWJpSXRlbSIsImZvcm1hdEFiaUl0ZW0iLCJmcm9tIiwib3B0aW9ucyIsInByZXBhcmUiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VBYmlJdGVtIiwiaGFzaCIsImdldFNpZ25hdHVyZUhhc2giLCJmcm9tQWJpIiwiYWJpIiwibmFtZSIsImFyZ3MiLCJpc1NlbGVjdG9yIiwidmFsaWRhdGUiLCJzdHJpY3QiLCJhYmlJdGVtcyIsImZpbHRlciIsInR5cGUiLCJnZXRTZWxlY3RvciIsInNsaWNlIiwibGVuZ3RoIiwiTm90Rm91bmRFcnJvciIsIm1hdGNoZWRBYmlJdGVtIiwidW5kZWZpbmVkIiwiaW5wdXRzIiwibWF0Y2hlZCIsImV2ZXJ5IiwiYXJnIiwiaW5kZXgiLCJhYmlQYXJhbWV0ZXIiLCJpc0FyZ09mVHlwZSIsImFtYmlndW91c1R5cGVzIiwiZ2V0QW1iaWd1b3VzVHlwZXMiLCJBbWJpZ3VpdHlFcnJvciIsIm92ZXJsb2FkcyIsImdldFNpZ25hdHVyZSIsInNpZ25hdHVyZSIsIm5vcm1hbGl6ZVNpZ25hdHVyZSIsImtlY2NhazI1NiIsImZyb21TdHJpbmciLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIngiLCJ5IiwibWV0YU1lc3NhZ2VzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRhdGEiLCJzZWxlY3RvciIsIkludmFsaWRTZWxlY3RvclNpemVFcnJvciIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AbiItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: function() { return /* binding */ InvalidRError; },\n/* harmony export */   InvalidSError: function() { return /* binding */ InvalidSError; },\n/* harmony export */   InvalidSerializedSizeError: function() { return /* binding */ InvalidSerializedSizeError; },\n/* harmony export */   InvalidVError: function() { return /* binding */ InvalidVError; },\n/* harmony export */   InvalidYParityError: function() { return /* binding */ InvalidYParityError; },\n/* harmony export */   MissingPropertiesError: function() { return /* binding */ MissingPropertiesError; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   extract: function() { return /* binding */ extract; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; },\n/* harmony export */   fromDerBytes: function() { return /* binding */ fromDerBytes; },\n/* harmony export */   fromDerHex: function() { return /* binding */ fromDerHex; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   fromLegacy: function() { return /* binding */ fromLegacy; },\n/* harmony export */   fromRpc: function() { return /* binding */ fromRpc; },\n/* harmony export */   fromTuple: function() { return /* binding */ fromTuple; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   toDerBytes: function() { return /* binding */ toDerBytes; },\n/* harmony export */   toDerHex: function() { return /* binding */ toDerHex; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   toLegacy: function() { return /* binding */ toLegacy; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   toTuple: function() { return /* binding */ toTuple; },\n/* harmony export */   vToYParity: function() { return /* binding */ vToYParity; },\n/* harmony export */   validate: function() { return /* binding */ validate; },\n/* harmony export */   yParityToV: function() { return /* binding */ yParityToV; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */ function assert(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(\"0x\".concat(signature.slice(130)));\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch (e) {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */ function extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */ function from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n        size: 32\n    }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n        size: 32\n    }), // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return \"0x\".concat(sig.toDERHex());\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */ function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */ function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n            size: 32\n        }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */ function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s))\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */ function validate(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        assert(signature, options);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */ function vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */ function yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\n/** Thrown when the serialized signature is of an invalid size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Value `\".concat(signature, \"` is an invalid signature size.\"), {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                \"Received \".concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature)), \" bytes.\")\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */ class MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Signature `\".concat(_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature), \"` is missing either an `r`, `s`, or `yParity` property.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */ class InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid r value. r must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */ class InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid s value. s must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */ class InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid y-parity value. Y-parity must be 0 or 1.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */ class InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid v value. v must be 27, 28 or >=35.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n} //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2hCO0FBQ0U7QUFDTjtBQUNFO0FBQ1E7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNNLE9BQU9DLFNBQVM7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUN6QyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRDtJQUN0QixJQUFJLE9BQU9ELFVBQVVHLENBQUMsS0FBSyxhQUN2QixNQUFNLElBQUlDLHVCQUF1QjtRQUFFSjtJQUFVO0lBQ2pELElBQUksT0FBT0EsVUFBVUssQ0FBQyxLQUFLLGFBQ3ZCLE1BQU0sSUFBSUQsdUJBQXVCO1FBQUVKO0lBQVU7SUFDakQsSUFBSUUsYUFBYSxPQUFPRixVQUFVTSxPQUFPLEtBQUssYUFDMUMsTUFBTSxJQUFJRix1QkFBdUI7UUFBRUo7SUFBVTtJQUNqRCxJQUFJQSxVQUFVRyxDQUFDLEdBQUcsRUFBRSxJQUFJSCxVQUFVRyxDQUFDLEdBQUdMLG9EQUFtQixFQUNyRCxNQUFNLElBQUlVLGNBQWM7UUFBRUMsT0FBT1QsVUFBVUcsQ0FBQztJQUFDO0lBQ2pELElBQUlILFVBQVVLLENBQUMsR0FBRyxFQUFFLElBQUlMLFVBQVVLLENBQUMsR0FBR1Asb0RBQW1CLEVBQ3JELE1BQU0sSUFBSVksY0FBYztRQUFFRCxPQUFPVCxVQUFVSyxDQUFDO0lBQUM7SUFDakQsSUFBSSxPQUFPTCxVQUFVTSxPQUFPLEtBQUssWUFDN0JOLFVBQVVNLE9BQU8sS0FBSyxLQUN0Qk4sVUFBVU0sT0FBTyxLQUFLLEdBQ3RCLE1BQU0sSUFBSUssb0JBQW9CO1FBQUVGLE9BQU9ULFVBQVVNLE9BQU87SUFBQztBQUNqRTtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU00sVUFBVVosU0FBUztJQUMvQixPQUFPYSxR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Q0FBRTtRQUNuQixLQUFLLENBQUMsVUFBaUIsT0FBTkEsT0FBTTtRQUN2QjhDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaWduYXR1cmUuanM/ZWRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIFNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5hc3NlcnQoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBJbnZhbGlkU2lnbmF0dXJlUkVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgLTU0OS4uLm5gIGlzIGFuIGludmFsaWQgciB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByZWNvdmVyZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAocmVjb3ZlcmVkICYmIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChzaWduYXR1cmUuciA8IDBuIHx8IHNpZ25hdHVyZS5yID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnIgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5zIDwgMG4gfHwgc2lnbmF0dXJlLnMgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUucyB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMCAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheShbMTI4LCAzLCAxMzEsIC4uLl0pKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNIZXguSGV4fSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21IZXgoJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYycpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwICYmIHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMCwgMzIpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDMyLCA2NCkpO1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB5UGFyaXR5ID0gTnVtYmVyKGAweCR7c2lnbmF0dXJlLnNsaWNlKDEzMCl9YCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeVBhcml0eSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZUb1lQYXJpdHkoeVBhcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgaWYgKHR5cGVvZiB5UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzLFxuICAgICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gZnJvbSBhbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgbWF5IGluY2x1ZGUgc2lnbmF0dXJlIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5leHRyYWN0KHtcbiAqICAgYmF6OiAnYmFycnknLFxuICogICBmb286ICdiYXInLFxuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqICAgemVicmE6ICdzdHJpcGVzJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJiaXRyYXJ5IG9iamVjdCB0byBleHRyYWN0IHRoZSBzaWduYXR1cmUgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHR5cGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBvYmplY3QgZnJvbSBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSwge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MDEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBMZWdhY3lcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqICAgdjogMjcsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAvLyBAbG9nOiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdmFsdWUgdG8gaW5zdGFudGlhdGUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFudGlhdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tUnBjKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUudilcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGVnYWN5KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgeVBhcml0eTogc2lnbmF0dXJlLnlQYXJpdHkgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZV8pO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJCeXRlcyhuZXcgVWludDhBcnJheShbMTMyLCA1MSwgMjMsIC4uLl0pKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tRGVySGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJIZXgoJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbURFUihIZXguZnJvbShzaWduYXR1cmUpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4geyByLCBzIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUuZnJvbUxlZ2FjeSh7IHI6IDFuLCBzOiAybiwgdjogMjggfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB5UGFyaXR5OiB2VG9ZUGFyaXR5KHNpZ25hdHVyZS52KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ScGMoe1xuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUudiA/IE51bWJlcihzaWduYXR1cmUudikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB5UGFyaXR5ID0gc2lnbmF0dXJlLnlQYXJpdHkgPyBOdW1iZXIoc2lnbmF0dXJlLnlQYXJpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInICYmIHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHlQYXJpdHkgPSB2VG9ZUGFyaXR5KHYpO1xuICAgICAgICBpZiAodHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG4gICAgICAgIHJldHVybiB5UGFyaXR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogQmlnSW50KHNpZ25hdHVyZS5yKSxcbiAgICAgICAgczogQmlnSW50KHNpZ25hdHVyZS5zKSxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21UdXBsZShbJzB4MDEnLCAnMHg3YicsICcweDFjOCddKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiAxMjNuLFxuICogLy8gQGxvZzogICBzOiA0NTZuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW3lQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICByOiByID09PSAnMHgnID8gMG4gOiBCaWdJbnQociksXG4gICAgICAgIHM6IHMgPT09ICcweCcgPyAwbiA6IEJpZ0ludChzKSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoeVBhcml0eSksXG4gICAgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0J5dGVzKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMDIsIDE2LCAxMCwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9IZXgoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6ICcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlKTtcbiAgICBjb25zdCByID0gc2lnbmF0dXJlLnI7XG4gICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBIZXguY29uY2F0KEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksIFxuICAgIC8vIElmIHRoZSBzaWduYXR1cmUgaXMgcmVjb3ZlcmVkLCBhZGQgdGhlIHJlY292ZXJ5IGJ5dGUgdG8gdGhlIHNpZ25hdHVyZS5cbiAgICB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInXG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIoeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksIHsgc2l6ZTogMSB9KVxuICAgICAgICA6ICcweCcpO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVyQnl0ZXMoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTMyLCA1MSwgMjMsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBzaWcudG9ERVJSYXdCeXRlcygpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVySGV4KHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6ICcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBgMHgke3NpZy50b0RFUkhleCgpfWA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUudG9MZWdhY3koeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHY6IHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9ScGMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHM6IEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09IDAgPyAnMHgwJyA6ICcweDEnLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGEgc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBiZSB1c2VkIGZvciBzaWduYXR1cmVzIGluIFRyYW5zYWN0aW9uIEVudmVsb3BlcywgRUlQLTc3MDIgQXV0aG9yaXphdGlvbiBMaXN0cywgZXRjLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlVHVwbGUgPSBTaWduYXR1cmUudG9UdXBsZSh7XG4gKiAgIHI6IDEyM24sXG4gKiAgIHM6IDQ1Nm4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogW3lQYXJpdHk6ICcweDAxJywgcjogJzB4N2InLCBzOiAnMHgxYzgnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeVBhcml0eSA/ICcweDAxJyA6ICcweCcsXG4gICAgICAgIHIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihyKSksXG4gICAgICAgIHMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzKSksXG4gICAgXTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlLnZhbGlkYXRlKHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB5UGFyaXR5ID0gU2lnbmF0dXJlLnZUb1lQYXJpdHkoMjgpXG4gKiAvLyBAbG9nOiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSBFQ0RTQSBgdmAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgeVBhcml0eWAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2VG9ZUGFyaXR5KHYpIHtcbiAgICBpZiAodiA9PT0gMCB8fCB2ID09PSAyNylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHYgPT09IDEgfHwgdiA9PT0gMjgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh2ID49IDM1KVxuICAgICAgICByZXR1cm4gdiAlIDIgPT09IDAgPyAxIDogMDtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFZFcnJvcih7IHZhbHVlOiB2IH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHYgPSBTaWduYXR1cmUueVBhcml0eVRvVigxKVxuICogLy8gQGxvZzogMjhcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB5UGFyaXR5IC0gVGhlIEVDRFNBIGB5UGFyaXR5YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB2YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlQYXJpdHlUb1YoeVBhcml0eSkge1xuICAgIGlmICh5UGFyaXR5ID09PSAwKVxuICAgICAgICByZXR1cm4gMjc7XG4gICAgaWYgKHlQYXJpdHkgPT09IDEpXG4gICAgICAgIHJldHVybiAyODtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xufVxuLyoqIFRocm93biB3aGVuIHRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZSBpcyBvZiBhbiBpbnZhbGlkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3NpZ25hdHVyZX1cXGAgaXMgYW4gaW52YWxpZCBzaWduYXR1cmUgc2l6ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQ6IDY0IGJ5dGVzIG9yIDY1IGJ5dGVzLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20oc2lnbmF0dXJlKSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaXMgbWlzc2luZyBlaXRoZXIgYW4gYHJgLCBgc2AsIG9yIGB5UGFyaXR5YCBwcm9wZXJ0eS4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nUHJvcGVydGllc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgU2lnbmF0dXJlIFxcYCR7SnNvbi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1cXGAgaXMgbWlzc2luZyBlaXRoZXIgYW4gXFxgclxcYCwgXFxgc1xcYCwgb3IgXFxgeVBhcml0eVxcYCBwcm9wZXJ0eS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5NaXNzaW5nUHJvcGVydGllc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgcmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCByIHZhbHVlLiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkUkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgc2AgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBzIHZhbHVlLiBzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgeVBhcml0eWAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFlQYXJpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB5LXBhcml0eSB2YWx1ZS4gWS1wYXJpdHkgbXVzdCBiZSAwIG9yIDEuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFlQYXJpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHZgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRWRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgdiB2YWx1ZS4gdiBtdXN0IGJlIDI3LCAyOCBvciA+PTM1LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRWRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiU29saWRpdHkiLCJhc3NlcnQiLCJzaWduYXR1cmUiLCJvcHRpb25zIiwicmVjb3ZlcmVkIiwiciIsIk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IiLCJzIiwieVBhcml0eSIsIm1heFVpbnQyNTYiLCJJbnZhbGlkUkVycm9yIiwidmFsdWUiLCJJbnZhbGlkU0Vycm9yIiwiSW52YWxpZFlQYXJpdHlFcnJvciIsImZyb21CeXRlcyIsImZyb21IZXgiLCJsZW5ndGgiLCJJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciIsIkJpZ0ludCIsInNsaWNlIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmRlZmluZWQiLCJ2VG9ZUGFyaXR5IiwiZXh0cmFjdCIsImZyb20iLCJzaWduYXR1cmVfIiwiVWludDhBcnJheSIsImZyb21ScGMiLCJ2IiwiZnJvbUxlZ2FjeSIsImZyb21EZXJCeXRlcyIsImZyb21EZXJIZXgiLCJTaWduYXR1cmUiLCJmcm9tREVSIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ0b0J5dGVzIiwidG9IZXgiLCJjb25jYXQiLCJmcm9tTnVtYmVyIiwic2l6ZSIsInlQYXJpdHlUb1YiLCJ0b0RlckJ5dGVzIiwic2lnIiwidG9ERVJSYXdCeXRlcyIsInRvRGVySGV4IiwidG9ERVJIZXgiLCJ0b0xlZ2FjeSIsInRvUnBjIiwidG9UdXBsZSIsInRyaW1MZWZ0IiwidmFsaWRhdGUiLCJJbnZhbGlkVkVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/internal/abi.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abi.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSignatures: function() { return /* binding */ isSignatures; }\n/* harmony export */ });\n/** @internal */ function isSignatures(value) {\n    for (const item of value){\n        if (typeof item !== \"string\") return false;\n    }\n    return true;\n} //# sourceMappingURL=abi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxjQUFjLEdBQ1AsU0FBU0EsYUFBYUMsS0FBSztJQUM5QixLQUFLLE1BQU1DLFFBQVFELE1BQU87UUFDdEIsSUFBSSxPQUFPQyxTQUFTLFVBQ2hCLE9BQU87SUFDZjtJQUNBLE9BQU87QUFDWCxFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaS5qcz82Njg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpZ25hdHVyZXModmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmkuanMubWFwIl0sIm5hbWVzIjpbImlzU2lnbmF0dXJlcyIsInZhbHVlIiwiaXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/internal/abi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: function() { return /* binding */ getAmbiguousTypes; },\n/* harmony export */   isArgOfType: function() { return /* binding */ isArgOfType; },\n/* harmony export */   normalizeSignature: function() { return /* binding */ normalizeSignature; }\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */ function normalizeSignature(signature) {\n    let active = true;\n    let current = \"\";\n    let level = 0;\n    let result = \"\";\n    let valid = false;\n    for(let i = 0; i < signature.length; i++){\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if ([\n            \"(\",\n            \")\",\n            \",\"\n        ].includes(char)) active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === \"(\") level++;\n        if (char === \")\") level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active) continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === \" \" && [\n                \"event\",\n                \"function\",\n                \"error\",\n                \"\"\n            ].includes(result)) result = \"\";\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === \")\") {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === \" \") {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\n                current = \"\";\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid) throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError(\"Unable to normalize signature.\");\n    return result;\n}\n/** @internal */ function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch(abiParameterType){\n        case \"address\":\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, {\n                strict: false\n            });\n        case \"bool\":\n            return argType === \"boolean\";\n        case \"function\":\n            return argType === \"string\";\n        case \"string\":\n            return argType === \"string\";\n        default:\n            {\n                if (abiParameterType === \"tuple\" && \"components\" in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n                // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n                // https://regexr.com/6v8hp\n                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === \"number\" || argType === \"bigint\";\n                // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n                // https://regexr.com/6va55\n                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === \"string\" || arg instanceof Uint8Array;\n                // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n                // https://regexr.com/6va6i\n                if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                    return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {\n                            ...abiParameter,\n                            // Pop off `[]` or `[M]` from end of type\n                            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n                        }));\n                }\n                return false;\n            }\n    }\n}\n/** @internal */ function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for(const parameterIndex in sourceParameters){\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [\n            sourceParameter.type,\n            targetParameter.type\n        ];\n        const ambiguous = (()=>{\n            if (types.includes(\"address\") && types.includes(\"bytes20\")) return true;\n            if (types.includes(\"address\") && types.includes(\"string\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            if (types.includes(\"address\") && types.includes(\"bytes\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            return false;\n        })();\n        if (ambiguous) return types;\n    }\n    return;\n} //# sourceMappingURL=abiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpSXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUNGO0FBQ3ZDLGNBQWMsR0FDUCxTQUFTRSxtQkFBbUJDLFNBQVM7SUFDeEMsSUFBSUMsU0FBUztJQUNiLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxRQUFRO0lBQ1osSUFBSUMsU0FBUztJQUNiLElBQUlDLFFBQVE7SUFDWixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sVUFBVU8sTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLE1BQU1FLE9BQU9SLFNBQVMsQ0FBQ00sRUFBRTtRQUN6QiwwREFBMEQ7UUFDMUQsSUFBSTtZQUFDO1lBQUs7WUFBSztTQUFJLENBQUNHLFFBQVEsQ0FBQ0QsT0FDekJQLFNBQVM7UUFDYix1RUFBdUU7UUFDdkUsSUFBSU8sU0FBUyxLQUNUTDtRQUNKLElBQUlLLFNBQVMsS0FDVEw7UUFDSiwyREFBMkQ7UUFDM0QsSUFBSSxDQUFDRixRQUNEO1FBQ0osa0RBQWtEO1FBQ2xELElBQUlFLFVBQVUsR0FBRztZQUNiLElBQUlLLFNBQVMsT0FBTztnQkFBQztnQkFBUztnQkFBWTtnQkFBUzthQUFHLENBQUNDLFFBQVEsQ0FBQ0wsU0FDNURBLFNBQVM7aUJBQ1I7Z0JBQ0RBLFVBQVVJO2dCQUNWLCtEQUErRDtnQkFDL0QsSUFBSUEsU0FBUyxLQUFLO29CQUNkSCxRQUFRO29CQUNSO2dCQUNKO1lBQ0o7WUFDQTtRQUNKO1FBQ0EsZ0JBQWdCO1FBQ2hCLElBQUlHLFNBQVMsS0FBSztZQUNkLHdHQUF3RztZQUN4RyxJQUFJUixTQUFTLENBQUNNLElBQUksRUFBRSxLQUFLLE9BQU9KLFlBQVksT0FBT0EsWUFBWSxNQUFNO2dCQUNqRUEsVUFBVTtnQkFDVkQsU0FBUztZQUNiO1lBQ0E7UUFDSjtRQUNBRyxVQUFVSTtRQUNWTixXQUFXTTtJQUNmO0lBQ0EsSUFBSSxDQUFDSCxPQUNELE1BQU0sSUFBSVAsaURBQWdCLENBQUM7SUFDL0IsT0FBT007QUFDWDtBQUNBLGNBQWMsR0FDUCxTQUFTTyxZQUFZQyxHQUFHLEVBQUVDLFlBQVk7SUFDekMsTUFBTUMsVUFBVSxPQUFPRjtJQUN2QixNQUFNRyxtQkFBbUJGLGFBQWFHLElBQUk7SUFDMUMsT0FBUUQ7UUFDSixLQUFLO1lBQ0QsT0FBT2xCLGlEQUFnQixDQUFDZSxLQUFLO2dCQUFFTSxRQUFRO1lBQU07UUFDakQsS0FBSztZQUNELE9BQU9KLFlBQVk7UUFDdkIsS0FBSztZQUNELE9BQU9BLFlBQVk7UUFDdkIsS0FBSztZQUNELE9BQU9BLFlBQVk7UUFDdkI7WUFBUztnQkFDTCxJQUFJQyxxQkFBcUIsV0FBVyxnQkFBZ0JGLGNBQ2hELE9BQU9NLE9BQU9DLE1BQU0sQ0FBQ1AsYUFBYVEsVUFBVSxFQUFFQyxLQUFLLENBQUMsQ0FBQ0MsV0FBV0M7b0JBQzVELE9BQU9iLFlBQVlRLE9BQU9DLE1BQU0sQ0FBQ1IsSUFBSSxDQUFDWSxNQUFNLEVBQUVEO2dCQUNsRDtnQkFDSixpRkFBaUY7Z0JBQ2pGLDJCQUEyQjtnQkFDM0IsSUFBSSwrSEFBK0hFLElBQUksQ0FBQ1YsbUJBQ3BJLE9BQU9ELFlBQVksWUFBWUEsWUFBWTtnQkFDL0Msc0RBQXNEO2dCQUN0RCwyQkFBMkI7Z0JBQzNCLElBQUksdUNBQXVDVyxJQUFJLENBQUNWLG1CQUM1QyxPQUFPRCxZQUFZLFlBQVlGLGVBQWVjO2dCQUNsRCw2REFBNkQ7Z0JBQzdELDJCQUEyQjtnQkFDM0IsSUFBSSxvQ0FBb0NELElBQUksQ0FBQ1YsbUJBQW1CO29CQUM1RCxPQUFRWSxNQUFNQyxPQUFPLENBQUNoQixRQUNsQkEsSUFBSVUsS0FBSyxDQUFDLENBQUNPLElBQU1sQixZQUFZa0IsR0FBRzs0QkFDNUIsR0FBR2hCLFlBQVk7NEJBQ2YseUNBQXlDOzRCQUN6Q0csTUFBTUQsaUJBQWlCZSxPQUFPLENBQUMsb0JBQW9CO3dCQUN2RDtnQkFDUjtnQkFDQSxPQUFPO1lBQ1g7SUFDSjtBQUNKO0FBQ0EsY0FBYyxHQUNQLFNBQVNDLGtCQUFrQkMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxJQUFJO0lBQ3RFLElBQUssTUFBTUMsa0JBQWtCSCxpQkFBa0I7UUFDM0MsTUFBTUksa0JBQWtCSixnQkFBZ0IsQ0FBQ0csZUFBZTtRQUN4RCxNQUFNRSxrQkFBa0JKLGdCQUFnQixDQUFDRSxlQUFlO1FBQ3hELElBQUlDLGdCQUFnQnBCLElBQUksS0FBSyxXQUN6QnFCLGdCQUFnQnJCLElBQUksS0FBSyxXQUN6QixnQkFBZ0JvQixtQkFDaEIsZ0JBQWdCQyxpQkFDaEIsT0FBT04sa0JBQWtCSyxnQkFBZ0JmLFVBQVUsRUFBRWdCLGdCQUFnQmhCLFVBQVUsRUFBRWEsSUFBSSxDQUFDQyxlQUFlO1FBQ3pHLE1BQU1HLFFBQVE7WUFBQ0YsZ0JBQWdCcEIsSUFBSTtZQUFFcUIsZ0JBQWdCckIsSUFBSTtTQUFDO1FBQzFELE1BQU11QixZQUFZLENBQUM7WUFDZixJQUFJRCxNQUFNN0IsUUFBUSxDQUFDLGNBQWM2QixNQUFNN0IsUUFBUSxDQUFDLFlBQzVDLE9BQU87WUFDWCxJQUFJNkIsTUFBTTdCLFFBQVEsQ0FBQyxjQUFjNkIsTUFBTTdCLFFBQVEsQ0FBQyxXQUM1QyxPQUFPWixpREFBZ0IsQ0FBQ3FDLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUMxQ2pCLFFBQVE7WUFDWjtZQUNKLElBQUlvQixNQUFNN0IsUUFBUSxDQUFDLGNBQWM2QixNQUFNN0IsUUFBUSxDQUFDLFVBQzVDLE9BQU9aLGlEQUFnQixDQUFDcUMsSUFBSSxDQUFDQyxlQUFlLEVBQUU7Z0JBQzFDakIsUUFBUTtZQUNaO1lBQ0osT0FBTztRQUNYO1FBQ0EsSUFBSXFCLFdBQ0EsT0FBT0Q7SUFDZjtJQUNBO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzPzU0ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzaWduYXR1cmVbaV07XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIHdlIHdhbnQgdG8gcmVhY3RpdmF0ZS5cbiAgICAgICAgaWYgKFsnKCcsICcpJywgJywnXS5pbmNsdWRlcyhjaGFyKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBcImxldmVsXCIgdG9rZW4sIHdlIHdhbnQgdG8gaW5jcmVtZW50L2RlY3JlbWVudC5cbiAgICAgICAgaWYgKGNoYXIgPT09ICcoJylcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIGlmIChjaGFyID09PSAnKScpXG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgYWN0aXZlLCB3ZSBkb24ndCB3YW50IHRvIG11dGF0ZSB0aGUgcmVzdWx0LlxuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBJZiBsZXZlbCA9PT0gMCwgd2UgYXJlIGF0IHRoZSBkZWZpbml0aW9uIGxldmVsLlxuICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcgJiYgWydldmVudCcsICdmdW5jdGlvbicsICdlcnJvcicsICcnXS5pbmNsdWRlcyhyZXN1bHQpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGRlZmluaXRpb24sIHdlIG11c3QgYmUgZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBzcGFjZXNcbiAgICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciwgYW5kIHRoZSBjdXJyZW50IHNlY3Rpb24gaXNuJ3QgZW1wdHksIHdlIHdhbnQgdG8gZGVhY3RpdmF0ZS5cbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVbaSAtIDFdICE9PSAnLCcgJiYgY3VycmVudCAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsKCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2hhcjtcbiAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignVW5hYmxlIHRvIG5vcm1hbGl6ZSBzaWduYXR1cmUuJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FyZ09mVHlwZShhcmcsIGFiaVBhcmFtZXRlcikge1xuICAgIGNvbnN0IGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlclR5cGUgPSBhYmlQYXJhbWV0ZXIudHlwZTtcbiAgICBzd2l0Y2ggKGFiaVBhcmFtZXRlclR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmcsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmIChhYmlQYXJhbWV0ZXJUeXBlID09PSAndHVwbGUnICYmICdjb21wb25lbnRzJyBpbiBhYmlQYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYWJpUGFyYW1ldGVyLmNvbXBvbmVudHMpLmV2ZXJ5KChjb21wb25lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FyZ09mVHlwZShPYmplY3QudmFsdWVzKGFyZylbaW5kZXhdLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbiAgICAgICAgICAgIGlmICgvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ251bWJlcicgfHwgYXJnVHlwZSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgICAgICAvLyBgYnl0ZXM8TT5gOiBiaW5hcnkgdHlwZSBvZiBgTWAgYnl0ZXMsIGAwIDwgTSA8PSAzMmBcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE1NVxuICAgICAgICAgICAgaWYgKC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgICAgICAvLyBmaXhlZC1sZW5ndGggKGA8dHlwZT5bTV1gKSBhbmQgZHluYW1pYyAoYDx0eXBlPltdYCkgYXJyYXlzXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNmlcbiAgICAgICAgICAgIGlmICgvW2Etel0rWzEtOV17MCwzfShcXFtbMC05XXswLH1cXF0pKyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJnKSAmJlxuICAgICAgICAgICAgICAgICAgICBhcmcuZXZlcnkoKHgpID0+IGlzQXJnT2ZUeXBlKHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcCBvZmYgYFtdYCBvciBgW01dYCBmcm9tIGVuZCBvZiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFtbMC05XXswLH1cXF0pJC8sICcnKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXJzLCB0YXJnZXRQYXJhbWV0ZXJzLCBhcmdzKSB7XG4gICAgZm9yIChjb25zdCBwYXJhbWV0ZXJJbmRleCBpbiBzb3VyY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVBhcmFtZXRlciA9IHNvdXJjZVBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xuICAgICAgICBjb25zdCB0YXJnZXRQYXJhbWV0ZXIgPSB0YXJnZXRQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgaWYgKHNvdXJjZVBhcmFtZXRlci50eXBlID09PSAndHVwbGUnICYmXG4gICAgICAgICAgICB0YXJnZXRQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgJ2NvbXBvbmVudHMnIGluIHNvdXJjZVBhcmFtZXRlciAmJlxuICAgICAgICAgICAgJ2NvbXBvbmVudHMnIGluIHRhcmdldFBhcmFtZXRlcilcbiAgICAgICAgICAgIHJldHVybiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXIuY29tcG9uZW50cywgdGFyZ2V0UGFyYW1ldGVyLmNvbXBvbmVudHMsIGFyZ3NbcGFyYW1ldGVySW5kZXhdKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbc291cmNlUGFyYW1ldGVyLnR5cGUsIHRhcmdldFBhcmFtZXRlci50eXBlXTtcbiAgICAgICAgY29uc3QgYW1iaWd1b3VzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdieXRlczIwJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdieXRlcycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmIChhbWJpZ3VvdXMpXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbIkFkZHJlc3MiLCJFcnJvcnMiLCJub3JtYWxpemVTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJhY3RpdmUiLCJjdXJyZW50IiwibGV2ZWwiLCJyZXN1bHQiLCJ2YWxpZCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiaW5jbHVkZXMiLCJCYXNlRXJyb3IiLCJpc0FyZ09mVHlwZSIsImFyZyIsImFiaVBhcmFtZXRlciIsImFyZ1R5cGUiLCJhYmlQYXJhbWV0ZXJUeXBlIiwidHlwZSIsInZhbGlkYXRlIiwic3RyaWN0IiwiT2JqZWN0IiwidmFsdWVzIiwiY29tcG9uZW50cyIsImV2ZXJ5IiwiY29tcG9uZW50IiwiaW5kZXgiLCJ0ZXN0IiwiVWludDhBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIngiLCJyZXBsYWNlIiwiZ2V0QW1iaWd1b3VzVHlwZXMiLCJzb3VyY2VQYXJhbWV0ZXJzIiwidGFyZ2V0UGFyYW1ldGVycyIsImFyZ3MiLCJwYXJhbWV0ZXJJbmRleCIsInNvdXJjZVBhcmFtZXRlciIsInRhcmdldFBhcmFtZXRlciIsInR5cGVzIiwiYW1iaWd1b3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/internal/abiItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/erc6492/WrappedSignature.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/WrappedSignature.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: function() { return /* binding */ InvalidWrappedSignatureError; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   magicBytes: function() { return /* binding */ magicBytes; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   universalSignatureValidatorAbi: function() { return /* binding */ universalSignatureValidatorAbi; },\n/* harmony export */   universalSignatureValidatorBytecode: function() { return /* binding */ universalSignatureValidatorBytecode; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */ const magicBytes = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */ const universalSignatureValidatorBytecode = \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */ const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\"\n    },\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"bool\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n        name: \"isValidSig\"\n    }\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * WrappedSignature.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */ function assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes) throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = WrappedSignature.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = WrappedSignature.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function from(wrapped) {\n    if (typeof wrapped === \"string\") return fromHex(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const { data, signature, to } = WrappedSignature.fromHex('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function fromHex(wrapped) {\n    assert(wrapped);\n    const [to, data, signature_hex] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), wrapped);\n    const signature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(signature_hex);\n    return {\n        data,\n        signature,\n        to\n    };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = WrappedSignature.toHex({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */ function toHex(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), [\n        to,\n        data,\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.toHex(signature)\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const valid = WrappedSignature.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */ function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */ class InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(wrapped){\n        super(\"Value `\".concat(wrapped, \"` is an invalid ERC-6492 wrapped signature.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"WrappedSignature.InvalidWrappedSignatureError\"\n        });\n    }\n} //# sourceMappingURL=WrappedSignature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzY0OTIvV3JhcHBlZFNpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2Q7QUFDTjtBQUNZO0FBQ2xEOztDQUVDLEdBQ00sTUFBTUksYUFBYSxxRUFBcUU7QUFDL0Y7O0NBRUMsR0FDTSxNQUFNQyxzQ0FBc0MsNnlHQUE2eUc7QUFDaDJHOzs7O0NBSUMsR0FDTSxNQUFNQyxpQ0FBaUM7SUFDMUM7UUFDSUMsUUFBUTtZQUNKO2dCQUNJQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7WUFDQTtnQkFDSUQsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtTQUNIO1FBQ0RDLGlCQUFpQjtRQUNqQkQsTUFBTTtJQUNWO0lBQ0E7UUFDSUYsUUFBUTtZQUNKO2dCQUNJQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7WUFDQTtnQkFDSUQsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtTQUNIO1FBQ0RFLFNBQVM7WUFDTDtnQkFDSUYsTUFBTTtZQUNWO1NBQ0g7UUFDREMsaUJBQWlCO1FBQ2pCRCxNQUFNO1FBQ05ELE1BQU07SUFDVjtDQUNILENBQUM7QUFDRjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTSSxPQUFPQyxPQUFPO0lBQzFCLElBQUlYLCtDQUFTLENBQUNXLFNBQVMsQ0FBQyxRQUFRVCxZQUM1QixNQUFNLElBQUlXLDZCQUE2QkY7QUFDL0M7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDTSxTQUFTRyxLQUFLSCxPQUFPO0lBQ3hCLElBQUksT0FBT0EsWUFBWSxVQUNuQixPQUFPSSxRQUFRSjtJQUNuQixPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0ksUUFBUUosT0FBTztJQUMzQkQsT0FBT0M7SUFDUCxNQUFNLENBQUNLLElBQUlDLE1BQU1DLGNBQWMsR0FBR3BCLDBEQUFvQixDQUFDQSx3REFBa0IsQ0FBQywwQkFBMEJhO0lBQ3BHLE1BQU1TLFlBQVluQix1REFBaUIsQ0FBQ2lCO0lBQ3BDLE9BQU87UUFBRUQ7UUFBTUc7UUFBV0o7SUFBRztBQUNqQztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sU0FBU0ssTUFBTUMsS0FBSztJQUN2QixNQUFNLEVBQUVMLElBQUksRUFBRUcsU0FBUyxFQUFFSixFQUFFLEVBQUUsR0FBR007SUFDaEMsT0FBT3RCLGdEQUFVLENBQUNGLDBEQUFvQixDQUFDQSx3REFBa0IsQ0FBQywwQkFBMEI7UUFDaEZrQjtRQUNBQztRQUNBaEIscURBQWUsQ0FBQ21CO0tBQ25CLEdBQUdsQjtBQUNSO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVN1QixTQUFTZCxPQUFPO0lBQzVCLElBQUk7UUFDQUQsT0FBT0M7UUFDUCxPQUFPO0lBQ1gsRUFDQSxVQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0o7QUFDQSwyREFBMkQsR0FDcEQsTUFBTUUscUNBQXFDZCxzREFBZ0I7SUFDOUQ0QixZQUFZaEIsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxVQUFtQixPQUFSQSxTQUFRO1FBQ3pCaUIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWVixPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2VyYzY0OTIvV3JhcHBlZFNpZ25hdHVyZS5qcz8wY2JkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi4vY29yZS9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9jb3JlL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4uL2NvcmUvU2lnbmF0dXJlLmpzJztcbi8qKlxuICogTWFnaWMgYnl0ZXMgdXNlZCB0byBpZGVudGlmeSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5Mic7XG4vKipcbiAqIERlcGxveWxlc3MgRVJDLTY0OTIgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBieXRlY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwNjk0MzgwMzgwNjEwNjk0ODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTA1MWU1NjViNjAwMDYxMDAzYzg0ODQ4NDYxMDA0ODU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MDAwN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjEwMDc0ODM2MTA0MGM1NjViMDM2MTAxZTc1NzYwMDA2MDYwODA4NDgwNjAyMDAxOTA1MTgxMDE5MDYxMDA5MjkxOTA2MTA1Nzc1NjViNjA0MDUxOTI5NTUwOTA5MzUwOTE1MDYwMDA5MDYwMDE2MDAxNjBhMDFiMDM4NTE2OTA2MTAwYjY5MDg1OTA2MTA1ZGQ1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDBmMzU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDBmODU2NWI2MDYwOTE1MDViNTA1MDkwNTA4NzYwMDE2MDAxNjBhMDFiMDMxNjNiNjAwMDAzNjEwMTYwNTc4MDYxMDE2MDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyM2EyMDY0NjU3MDZjNmY3OTZkNjU2ZTc0MDAwMDYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4YTE2OTA2MzE2MjZiYTdlOTA2MTAxOTA5MDhiOTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDFhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMWQxOTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTQ1MDUwNTA1MDUwNjEwNDA1NTY1YjYwMDE2MDAxNjBhMDFiMDM4NDE2M2IxNTYxMDI3YTU3NjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzg2MTY5MDYzMTYyNmJhN2U5MDYxMDIyNzkwODc5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMjQ0NTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAyNjg5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5MDUwNjEwNDA1NTY1YjgxNTE2MDQxMTQ2MTAyZGY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYTYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNmM2NTZlNjc3NDY4MDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MTAyZTc2MTA0MjU1NjViNTA2MDIwODIwMTUxNjA0MDgwODQwMTUxODQ1MTg1OTM5MjYwMDA5MTg1OTE5MDgxMTA2MTAzMGM1NzYxMDMwYzYxMDY1ZDU2NWIwMTYwMjAwMTUxNjBmODFjOTA1MDYwMWI4MTE0ODAxNTkwNjEwMzJiNTc1MDgwNjBmZjE2NjAxYzE0MTU1YjE1NjEwMzhjNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2I2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDc2MjA3NjYxNmM3NTY1MDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyODk5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI2MDAxNjAwMTYwYTAxYjAzODkxNjkwNjAwMTkwNjBhMDAxNjAyMDYwNDA1MTYwMjA4MTAzOTA4MDg0MDM5MDg1NWFmYTE1ODAxNTYxMDNlYTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA2MDIwNjA0MDUxMDM1MTYwMDE2MDAxNjBhMDFiMDMxNjE0OTQ1MDUwNTA1MDUwNWI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI1MTEwMTU2MTA0MWQ1NzYwMDA4MGZkNWI1MDgwNTEwMTUxOTA1NjViNjA0MDUxODA2MDYwMDE2MDQwNTI4MDYwMDM5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjEwNDU4NTc2MDAwODBmZDViNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDQ4YzU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDQ3NDU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwNGE2NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA0YmY1NzYxMDRiZjYxMDQ1YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDRlZDU3NjEwNGVkNjEwNDViNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDUwNTU3NjAwMDgwZmQ1YjYxMDUxNjgyNjAyMDgzMDE2MDIwODcwMTYxMDQ3MTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNTMzNTc2MDAwODBmZDViODM1MTYxMDUzZTgxNjEwNDQzNTY1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MTA1NmQ4NjgyODcwMTYxMDQ5NTU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDU4YzU3NjAwMDgwZmQ1YjgzNTE2MTA1OTc4MTYxMDQ0MzU2NWI2MDIwODUwMTUxOTA5MzUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDViMzU3NjAwMDgwZmQ1YjYxMDViZjg2ODI4NzAxNjEwNDk1NTY1YjYwNDA4NjAxNTE5MDkzNTA5MDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYwMDA4MjUxNjEwNWVmODE4NDYwMjA4NzAxNjEwNDcxNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwODI1MTgwNjA0MDg0MDE1MjYxMDYxZTgxNjA2MDg1MDE2MDIwODcwMTYxMDQ3MTU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA2MDAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTA2NDU1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MGUwMWIwMzE5ODExNjgxMTQ2MTA0MDU1NzYwMDA4MGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAzMjYwMDQ1MjYwMjQ2MDAwZmRmZTUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjIzNzI2NTYzNmY3NjY1NzI1MzY5Njc2ZTY1NzInO1xuLyoqXG4gKiBBQkkgZm9yIHRoZSBFUkMtNjQ5MiB1bml2ZXJzYWwgZGVwbG95bGVzcyBzaWduYXR1cmUgdmFsaWRhdG9yIGNvbnRyYWN0LlxuICpcbiAqIENvbnN0cnVjdG9yIHJldHVybiB2YWx1ZSBpcyBgMHgxYCAodmFsaWQpIG9yIGAweDBgIChpbnZhbGlkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfaGFzaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG5hbWU6ICdpc1ZhbGlkU2lnJyxcbiAgICB9LFxuXTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdyYXBwZWRTaWduYXR1cmUgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIFdyYXBwZWRTaWduYXR1cmUuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjogVmFsdWUgYDB4ZGVhZGJlZWZgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQod3JhcHBlZCkge1xuICAgIGlmIChIZXguc2xpY2Uod3JhcHBlZCwgLTMyKSAhPT0gbWFnaWNCeXRlcylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3Iod3JhcHBlZCk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBXcmFwcGVkU2lnbmF0dXJlIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBzZXJpYWxpemVkIGZvcm1hdC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFdyYXBwZWRTaWduYXR1cmUuZnJvbSgnMHguLi4nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSwgdG86ICcweC4uLicsIH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBXcmFwcGVkU2lnbmF0dXJlLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogeyBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0sIHRvOiAnMHguLi4nLCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHdyYXBwZWQpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbUhleCh3cmFwcGVkKTtcbiAgICByZXR1cm4gd3JhcHBlZDtcbn1cbi8qKlxuICogUGFyc2VzIGFuIFtFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyI3NwZWNpZmljYXRpb24pIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV3JhcHBlZFNpZ25hdHVyZSB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogY29uc3QgeyBkYXRhLCBzaWduYXR1cmUsIHRvIH0gPSBXcmFwcGVkU2lnbmF0dXJlLmZyb21IZXgoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBXcmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBbdG8sIGRhdGEsIHNpZ25hdHVyZV9oZXhdID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzLCBieXRlcywgYnl0ZXMnKSwgd3JhcHBlZCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlX2hleCk7XG4gICAgcmV0dXJuIHsgZGF0YSwgc2lnbmF0dXJlLCB0byB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGFuIFtFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyI3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBXcmFwcGVkU2lnbmF0dXJlIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgd3JhcHBlZCA9IFdyYXBwZWRTaWduYXR1cmUudG9IZXgoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqICAgdG86ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBXcmFwcGVkIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBTZXJpYWxpemVkIHdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IHZhbHVlO1xuICAgIHJldHVybiBIZXguY29uY2F0KEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcywgYnl0ZXMsIGJ5dGVzJyksIFtcbiAgICAgICAgdG8sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLFxuICAgIF0pLCBtYWdpY0J5dGVzKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgd3JhcHBlZCBzaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXcmFwcGVkU2lnbmF0dXJlIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFdyYXBwZWRTaWduYXR1cmUudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gVGhlIHdyYXBwZWQgc2lnbmF0dXJlIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh3cmFwcGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3dyYXBwZWR9XFxgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdXcmFwcGVkU2lnbmF0dXJlLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyYXBwZWRTaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbIkFiaVBhcmFtZXRlcnMiLCJFcnJvcnMiLCJIZXgiLCJTaWduYXR1cmUiLCJtYWdpY0J5dGVzIiwidW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQnl0ZWNvZGUiLCJ1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JBYmkiLCJpbnB1dHMiLCJuYW1lIiwidHlwZSIsInN0YXRlTXV0YWJpbGl0eSIsIm91dHB1dHMiLCJhc3NlcnQiLCJ3cmFwcGVkIiwic2xpY2UiLCJJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIiwiZnJvbSIsImZyb21IZXgiLCJ0byIsImRhdGEiLCJzaWduYXR1cmVfaGV4IiwiZGVjb2RlIiwic2lnbmF0dXJlIiwidG9IZXgiLCJ2YWx1ZSIsImNvbmNhdCIsImVuY29kZSIsInZhbGlkYXRlIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/erc6492/WrappedSignature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbi.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbi.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbi: function() { return /* binding */ formatAbi; }\n/* harmony export */ });\n/* harmony import */ var _formatAbiItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiItem.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */ function formatAbi(abi) {\n    const signatures = [];\n    const length = abi.length;\n    for(let i = 0; i < length; i++){\n        const abiItem = abi[i];\n        const signature = (0,_formatAbiItem_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem)(abiItem);\n        signatures.push(signature);\n    }\n    return signatures;\n} //# sourceMappingURL=formatAbi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUQ7QUFDbkQ7Ozs7O0NBS0MsR0FDTSxTQUFTQyxVQUFVQyxHQUFHO0lBQ3pCLE1BQU1DLGFBQWEsRUFBRTtJQUNyQixNQUFNQyxTQUFTRixJQUFJRSxNQUFNO0lBQ3pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxRQUFRQyxJQUFLO1FBQzdCLE1BQU1DLFVBQVVKLEdBQUcsQ0FBQ0csRUFBRTtRQUN0QixNQUFNRSxZQUFZUCxnRUFBYUEsQ0FBQ007UUFDaENILFdBQVdLLElBQUksQ0FBQ0Q7SUFDcEI7SUFDQSxPQUFPSjtBQUNYLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmkuanM/NGRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRBYmlJdGVtIH0gZnJvbSAnLi9mb3JtYXRBYmlJdGVtLmpzJztcbi8qKlxuICogUGFyc2VzIEpTT04gQUJJIGludG8gaHVtYW4tcmVhZGFibGUgQUJJXG4gKlxuICogQHBhcmFtIGFiaSAtIEFCSVxuICogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgQUJJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBYmkoYWJpKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFiaS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhYmlJdGVtID0gYWJpW2ldO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBzaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRBYmkuanMubWFwIl0sIm5hbWVzIjpbImZvcm1hdEFiaUl0ZW0iLCJmb3JtYXRBYmkiLCJhYmkiLCJzaWduYXR1cmVzIiwibGVuZ3RoIiwiaSIsImFiaUl0ZW0iLCJzaWduYXR1cmUiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatAbiItem: function() { return /* binding */ formatAbiItem; }\n/* harmony export */ });\n/* harmony import */ var _formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatAbiParameters.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */ function formatAbiItem(abiItem) {\n    var _abiItem_outputs;\n    if (abiItem.type === \"function\") return \"function \".concat(abiItem.name, \"(\").concat((0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs), \")\").concat(abiItem.stateMutability && abiItem.stateMutability !== \"nonpayable\" ? \" \".concat(abiItem.stateMutability) : \"\").concat(((_abiItem_outputs = abiItem.outputs) === null || _abiItem_outputs === void 0 ? void 0 : _abiItem_outputs.length) ? \" returns (\".concat((0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.outputs), \")\") : \"\");\n    if (abiItem.type === \"event\") return \"event \".concat(abiItem.name, \"(\").concat((0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs), \")\");\n    if (abiItem.type === \"error\") return \"error \".concat(abiItem.name, \"(\").concat((0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs), \")\");\n    if (abiItem.type === \"constructor\") return \"constructor(\".concat((0,_formatAbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters)(abiItem.inputs), \")\").concat(abiItem.stateMutability === \"payable\" ? \" payable\" : \"\");\n    if (abiItem.type === \"fallback\") return \"fallback() external\".concat(abiItem.stateMutability === \"payable\" ? \" payable\" : \"\");\n    return \"receive() external payable\";\n} //# sourceMappingURL=formatAbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdFO0FBQ2hFOzs7OztDQUtDLEdBQ00sU0FBU0MsY0FBY0MsT0FBTztRQUlsQkE7SUFIZixJQUFJQSxRQUFRQyxJQUFJLEtBQUssWUFDakIsT0FBTyxZQUE0QkgsT0FBaEJFLFFBQVFFLElBQUksRUFBQyxLQUEwQ0YsT0FBdkNGLDRFQUFtQkEsQ0FBQ0UsUUFBUUcsTUFBTSxHQUFFLEtBRTVESCxPQUYrREEsUUFBUUksZUFBZSxJQUFJSixRQUFRSSxlQUFlLEtBQUssZUFDM0gsSUFBNEIsT0FBeEJKLFFBQVFJLGVBQWUsSUFDM0IsSUFFRyxPQUZFSixFQUFBQSxtQkFBQUEsUUFBUUssT0FBTyxjQUFmTCx1Q0FBQUEsaUJBQWlCTSxNQUFNLElBQzVCLGFBQWtELE9BQXJDUiw0RUFBbUJBLENBQUNFLFFBQVFLLE9BQU8sR0FBRSxPQUNsRDtJQUNWLElBQUlMLFFBQVFDLElBQUksS0FBSyxTQUNqQixPQUFPLFNBQXlCSCxPQUFoQkUsUUFBUUUsSUFBSSxFQUFDLEtBQXVDLE9BQXBDSiw0RUFBbUJBLENBQUNFLFFBQVFHLE1BQU0sR0FBRTtJQUN4RSxJQUFJSCxRQUFRQyxJQUFJLEtBQUssU0FDakIsT0FBTyxTQUF5QkgsT0FBaEJFLFFBQVFFLElBQUksRUFBQyxLQUF1QyxPQUFwQ0osNEVBQW1CQSxDQUFDRSxRQUFRRyxNQUFNLEdBQUU7SUFDeEUsSUFBSUgsUUFBUUMsSUFBSSxLQUFLLGVBQ2pCLE9BQU8sZUFBc0RELE9BQXZDRiw0RUFBbUJBLENBQUNFLFFBQVFHLE1BQU0sR0FBRSxLQUEyRCxPQUF4REgsUUFBUUksZUFBZSxLQUFLLFlBQVksYUFBYTtJQUN0SCxJQUFJSixRQUFRQyxJQUFJLEtBQUssWUFDakIsT0FBTyxzQkFBOEUsT0FBeERELFFBQVFJLGVBQWUsS0FBSyxZQUFZLGFBQWE7SUFDdEYsT0FBTztBQUNYLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlJdGVtLmpzPzBjMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0QWJpUGFyYW1ldGVycywgfSBmcm9tICcuL2Zvcm1hdEFiaVBhcmFtZXRlcnMuanMnO1xuLyoqXG4gKiBGb3JtYXRzIEFCSSBpdGVtIChlLmcuIGVycm9yLCBldmVudCwgZnVuY3Rpb24pIGludG8gaHVtYW4tcmVhZGFibGUgQUJJIGl0ZW1cbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIEFCSSBpdGVtXG4gKiBAcmV0dXJucyBIdW1hbi1yZWFkYWJsZSBBQkkgaXRlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QWJpSXRlbShhYmlJdGVtKSB7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAmJiBhYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAhPT0gJ25vbnBheWFibGUnXG4gICAgICAgICAgICA/IGAgJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eX1gXG4gICAgICAgICAgICA6ICcnfSR7YWJpSXRlbS5vdXRwdXRzPy5sZW5ndGhcbiAgICAgICAgICAgID8gYCByZXR1cm5zICgke2Zvcm1hdEFiaVBhcmFtZXRlcnMoYWJpSXRlbS5vdXRwdXRzKX0pYFxuICAgICAgICAgICAgOiAnJ31gO1xuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgIHJldHVybiBgZXZlbnQgJHthYmlJdGVtLm5hbWV9KCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KWA7XG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgcmV0dXJuIGBlcnJvciAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pYDtcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKVxuICAgICAgICByZXR1cm4gYGNvbnN0cnVjdG9yKCR7Zm9ybWF0QWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cyl9KSR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgPT09ICdwYXlhYmxlJyA/ICcgcGF5YWJsZScgOiAnJ31gO1xuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdmYWxsYmFjaycpXG4gICAgICAgIHJldHVybiBgZmFsbGJhY2soKSBleHRlcm5hbCR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHkgPT09ICdwYXlhYmxlJyA/ICcgcGF5YWJsZScgOiAnJ31gO1xuICAgIHJldHVybiAncmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0QWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOlsiZm9ybWF0QWJpUGFyYW1ldGVycyIsImZvcm1hdEFiaUl0ZW0iLCJhYmlJdGVtIiwidHlwZSIsIm5hbWUiLCJpbnB1dHMiLCJzdGF0ZU11dGFiaWxpdHkiLCJvdXRwdXRzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbi.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbi.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbi: function() { return /* binding */ parseAbi; }\n/* harmony export */ });\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/structs.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/utils.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */ function parseAbi(signatures) {\n    const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_0__.parseStructs)(signatures);\n    const abi = [];\n    const length = signatures.length;\n    for(let i = 0; i < length; i++){\n        const signature = signatures[i];\n        if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_1__.isStructSignature)(signature)) continue;\n        abi.push((0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseSignature)(signature, structs));\n    }\n    return abi;\n} //# sourceMappingURL=parseAbi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTREO0FBQ1I7QUFDQTtBQUNwRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTRyxTQUFTQyxVQUFVO0lBQy9CLE1BQU1DLFVBQVVKLGlFQUFZQSxDQUFDRztJQUM3QixNQUFNRSxNQUFNLEVBQUU7SUFDZCxNQUFNQyxTQUFTSCxXQUFXRyxNQUFNO0lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxRQUFRQyxJQUFLO1FBQzdCLE1BQU1DLFlBQVlMLFVBQVUsQ0FBQ0ksRUFBRTtRQUMvQixJQUFJUix5RUFBaUJBLENBQUNTLFlBQ2xCO1FBQ0pILElBQUlJLElBQUksQ0FBQ1IsaUVBQWNBLENBQUNPLFdBQVdKO0lBQ3ZDO0lBQ0EsT0FBT0M7QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmkuanM/YWYyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1N0cnVjdFNpZ25hdHVyZSB9IGZyb20gJy4vcnVudGltZS9zaWduYXR1cmVzLmpzJztcbmltcG9ydCB7IHBhcnNlU3RydWN0cyB9IGZyb20gJy4vcnVudGltZS9zdHJ1Y3RzLmpzJztcbmltcG9ydCB7IHBhcnNlU2lnbmF0dXJlIH0gZnJvbSAnLi9ydW50aW1lL3V0aWxzLmpzJztcbi8qKlxuICogUGFyc2VzIGh1bWFuLXJlYWRhYmxlIEFCSSBpbnRvIEpTT04ge0BsaW5rIEFiaX1cbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlcyAtIEh1bWFuLVJlYWRhYmxlIEFCSVxuICogQHJldHVybnMgUGFyc2VkIHtAbGluayBBYml9XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFiaSA9IHBhcnNlQWJpKFtcbiAqICAgLy8gIF4/IGNvbnN0IGFiaTogcmVhZG9ubHkgW3sgbmFtZTogXCJiYWxhbmNlT2ZcIjsgdHlwZTogXCJmdW5jdGlvblwiOyBzdGF0ZU11dGFiaWxpdHk6Li4uXG4gKiAgICdmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcyBvd25lcikgdmlldyByZXR1cm5zICh1aW50MjU2KScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IGFtb3VudCknLFxuICogXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQWJpKHNpZ25hdHVyZXMpIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gcGFyc2VTdHJ1Y3RzKHNpZ25hdHVyZXMpO1xuICAgIGNvbnN0IGFiaSA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25hdHVyZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcbiAgICAgICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYWJpLnB1c2gocGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKSk7XG4gICAgfVxuICAgIHJldHVybiBhYmk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUFiaS5qcy5tYXAiXSwibmFtZXMiOlsiaXNTdHJ1Y3RTaWduYXR1cmUiLCJwYXJzZVN0cnVjdHMiLCJwYXJzZVNpZ25hdHVyZSIsInBhcnNlQWJpIiwic2lnbmF0dXJlcyIsInN0cnVjdHMiLCJhYmkiLCJsZW5ndGgiLCJpIiwic2lnbmF0dXJlIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAbiItem: function() { return /* binding */ parseAbiItem; }\n/* harmony export */ });\n/* harmony import */ var _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors/abiItem.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\");\n/* harmony import */ var _runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runtime/signatures.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\");\n/* harmony import */ var _runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime/structs.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\");\n/* harmony import */ var _runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime/utils.js */ \"(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\");\n\n\n\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */ function parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === \"string\") abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature);\n    else {\n        const structs = (0,_runtime_structs_js__WEBPACK_IMPORTED_MODULE_1__.parseStructs)(signature);\n        const length = signature.length;\n        for(let i = 0; i < length; i++){\n            const signature_ = signature[i];\n            if ((0,_runtime_signatures_js__WEBPACK_IMPORTED_MODULE_2__.isStructSignature)(signature_)) continue;\n            abiItem = (0,_runtime_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseSignature)(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem) throw new _errors_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAbiItemError({\n        signature\n    });\n    return abiItem;\n} //# sourceMappingURL=parseAbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEQ7QUFDRTtBQUNSO0FBQ0E7QUFDcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTSSxhQUFhQyxTQUFTO0lBQ2xDLElBQUlDO0lBQ0osSUFBSSxPQUFPRCxjQUFjLFVBQ3JCQyxVQUFVSCxpRUFBY0EsQ0FBQ0U7U0FDeEI7UUFDRCxNQUFNRSxVQUFVTCxpRUFBWUEsQ0FBQ0c7UUFDN0IsTUFBTUcsU0FBU0gsVUFBVUcsTUFBTTtRQUMvQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsUUFBUUMsSUFBSztZQUM3QixNQUFNQyxhQUFhTCxTQUFTLENBQUNJLEVBQUU7WUFDL0IsSUFBSVIseUVBQWlCQSxDQUFDUyxhQUNsQjtZQUNKSixVQUFVSCxpRUFBY0EsQ0FBQ08sWUFBWUg7WUFDckM7UUFDSjtJQUNKO0lBQ0EsSUFBSSxDQUFDRCxTQUNELE1BQU0sSUFBSU4sbUVBQW1CQSxDQUFDO1FBQUVLO0lBQVU7SUFDOUMsT0FBT0M7QUFDWCxFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlJdGVtLmpzPzNkYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW52YWxpZEFiaUl0ZW1FcnJvciB9IGZyb20gJy4vZXJyb3JzL2FiaUl0ZW0uanMnO1xuaW1wb3J0IHsgaXNTdHJ1Y3RTaWduYXR1cmUgfSBmcm9tICcuL3J1bnRpbWUvc2lnbmF0dXJlcy5qcyc7XG5pbXBvcnQgeyBwYXJzZVN0cnVjdHMgfSBmcm9tICcuL3J1bnRpbWUvc3RydWN0cy5qcyc7XG5pbXBvcnQgeyBwYXJzZVNpZ25hdHVyZSB9IGZyb20gJy4vcnVudGltZS91dGlscy5qcyc7XG4vKipcbiAqIFBhcnNlcyBodW1hbi1yZWFkYWJsZSBBQkkgaXRlbSAoZS5nLiBlcnJvciwgZXZlbnQsIGZ1bmN0aW9uKSBpbnRvIHtAbGluayBBYml9IGl0ZW1cbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gSHVtYW4tcmVhZGFibGUgQUJJIGl0ZW1cbiAqIEByZXR1cm5zIFBhcnNlZCB7QGxpbmsgQWJpfSBpdGVtXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFiaUl0ZW0gPSBwYXJzZUFiaUl0ZW0oJ2Z1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzIG93bmVyKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpJylcbiAqIC8vICAgIF4/IGNvbnN0IGFiaUl0ZW06IHsgbmFtZTogXCJiYWxhbmNlT2ZcIjsgdHlwZTogXCJmdW5jdGlvblwiOyBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiOy4uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBhYmlJdGVtID0gcGFyc2VBYmlJdGVtKFtcbiAqICAgLy8gIF4/IGNvbnN0IGFiaUl0ZW06IHsgbmFtZTogXCJmb29cIjsgdHlwZTogXCJmdW5jdGlvblwiOyBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiOyBpbnB1dHM6Li4uXG4gKiAgICdmdW5jdGlvbiBmb28oQmF6IGJhcikgdmlldyByZXR1cm5zIChzdHJpbmcpJyxcbiAqICAgJ3N0cnVjdCBCYXogeyBzdHJpbmcgbmFtZTsgfScsXG4gKiBdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBYmlJdGVtKHNpZ25hdHVyZSkge1xuICAgIGxldCBhYmlJdGVtO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlXyA9IHNpZ25hdHVyZVtpXTtcbiAgICAgICAgICAgIGlmIChpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmVfKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGFiaUl0ZW0gPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmVfLCBzdHJ1Y3RzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghYWJpSXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBYmlJdGVtRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgcmV0dXJuIGFiaUl0ZW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbIkludmFsaWRBYmlJdGVtRXJyb3IiLCJpc1N0cnVjdFNpZ25hdHVyZSIsInBhcnNlU3RydWN0cyIsInBhcnNlU2lnbmF0dXJlIiwicGFyc2VBYmlJdGVtIiwic2lnbmF0dXJlIiwiYWJpSXRlbSIsInN0cnVjdHMiLCJsZW5ndGgiLCJpIiwic2lnbmF0dXJlXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/auth/constants.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERC_6492_MAGIC_VALUE: function() { return /* binding */ ERC_6492_MAGIC_VALUE; }\n/* harmony export */ });\nconst ERC_6492_MAGIC_VALUE = \"0x6492649264926492649264926492649264926492649264926492649264926492\"; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9hdXRoL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsdUJBQXVCLHFFQUFxRSxDQUN6RyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL2F1dGgvY29uc3RhbnRzLmpzP2M4OTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEVSQ182NDkyX01BR0lDX1ZBTFVFID0gXCIweDY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiRVJDXzY0OTJfTUFHSUNfVkFMVUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js":
/*!****************************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serializeErc6492Signature: function() { return /* binding */ serializeErc6492Signature; }\n/* harmony export */ });\n/* harmony import */ var _utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/abi/encodeAbiParameters.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var _utils_encoding_helpers_concat_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/encoding/helpers/concat-hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/helpers/concat-hex.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/constants.js\");\n\n\n\n/**\n * @description Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */ function serializeErc6492Signature(param) {\n    let { address, data, signature } = param;\n    return (0,_utils_encoding_helpers_concat_hex_js__WEBPACK_IMPORTED_MODULE_0__.concatHex)([\n        (0,_utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encodeAbiParameters)([\n            {\n                type: \"address\"\n            },\n            {\n                type: \"bytes\"\n            },\n            {\n                type: \"bytes\"\n            }\n        ], [\n            address,\n            data,\n            signature\n        ]),\n        _constants_js__WEBPACK_IMPORTED_MODULE_2__.ERC_6492_MAGIC_VALUE\n    ]);\n} //# sourceMappingURL=serialize-erc6492-signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9hdXRoL3NlcmlhbGl6ZS1lcmM2NDkyLXNpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBFO0FBQ047QUFDZDtBQUN0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNHLDBCQUEwQixLQUE2QjtRQUE3QixFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFHLEdBQTdCO0lBQ3RDLE9BQU9MLGdGQUFTQSxDQUFDO1FBQ2JELHNGQUFtQkEsQ0FBQztZQUFDO2dCQUFFTyxNQUFNO1lBQVU7WUFBRztnQkFBRUEsTUFBTTtZQUFRO1lBQUc7Z0JBQUVBLE1BQU07WUFBUTtTQUFFLEVBQUU7WUFBQ0g7WUFBU0M7WUFBTUM7U0FBVTtRQUMzR0osK0RBQW9CQTtLQUN2QjtBQUNMLEVBQ0EsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9hdXRoL3NlcmlhbGl6ZS1lcmM2NDkyLXNpZ25hdHVyZS5qcz9iMzljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuY29kZUFiaVBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vdXRpbHMvYWJpL2VuY29kZUFiaVBhcmFtZXRlcnMuanNcIjtcbmltcG9ydCB7IGNvbmNhdEhleCB9IGZyb20gXCIuLi91dGlscy9lbmNvZGluZy9oZWxwZXJzL2NvbmNhdC1oZXguanNcIjtcbmltcG9ydCB7IEVSQ182NDkyX01BR0lDX1ZBTFVFIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTZXJpYWxpemVzIGEgc2lnbmF0dXJlIGZvciB1c2Ugd2l0aCBbRVJDLTY0OTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MikuIFRoZSBzaWduYXR1cmUgbXVzdCBiZSBnZW5lcmF0ZWQgYnkgYSBzaWduZXIgZm9yIGFuIFtFUkMtNDMzN10oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00MzM3KSBBY2NvdW50IEZhY3RvcnkgYWNjb3VudCB3aXRoIGNvdW50ZXJmYWN0dWFsIGRlcGxveW1lbnQgYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSB7QGxpbmsgRXJjNjQ5MlNpZ25hdHVyZX0gc2lnbmF0dXJlICBUaGUgc2lnbmF0dXJlIG9iamVjdCB0byBzZXJpYWxpemUgaW50byBIZXggZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlLmFkZHJlc3MgVGhlIEVSQy00MzM3IEFjY291bnQgRmFjdG9yeSBhZGRyZXNzXG4gKiBAcGFyYW0ge0hleH0gc2lnbmF0dXJlLmRhdGEgQWNjb3VudCBkZXBsb3ltZW50IGNhbGxkYXRhIChpZiBub3QgZGVwbG95ZWQpIGZvciBjb3VudGVyZmFjdHVhbCB2ZXJpZmljYXRpb25cbiAqIEBwYXJhbSB7SGV4fSBzaWduYXR1cmUuc2lnbmF0dXJlIFRoZSBvcmlnaW5hbCBzaWduYXR1cmVcbiAqXG4gKiBAcmV0dXJucyB7SGV4fSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNlcmlhbGl6ZUVyYzY0OTJTaWduYXR1cmUgfSBmcm9tICd0aGlyZHdlYi9hdXRoJztcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkU2lnbmF0dXJlID0gc2VyaWFsaXplRXJjNjQ5MlNpZ25hdHVyZSh7XG4gKiAgYWRkcmVzczogJzB4Li4uJyxcbiAqICBkYXRhOiAnMHguLi4nLFxuICogIHNpZ25hdHVyZTogJzB4Li4uJyxcbiAqIH0pO1xuICogLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjYWZlYmFiZWNhZmViYWJlY2FmZWJhYmVjYWZlYmFiZWNhZmViYWJlMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0ZGVhZGJlZWYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDFhNDYxZjUwOTg4N2JkMTllMzEyYzBjNTg0NjdjZThmZjhlMzAwZDNjMWE5MGI2MDhhNzYwYzViODAzMThlYWYxNWZlNTdjOTZmOTE3NWQ2Y2Q0ZGFhZDQ2NjM3NjNiYWE3ZTc4ODM2ZTA2N2QwMTYzZTlhMmNjZjJmZjc1M2Y1YjFiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyXG4gKiBgYGBcbiAqIEBhdXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVFcmM2NDkyU2lnbmF0dXJlKHsgYWRkcmVzcywgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgcmV0dXJuIGNvbmNhdEhleChbXG4gICAgICAgIGVuY29kZUFiaVBhcmFtZXRlcnMoW3sgdHlwZTogXCJhZGRyZXNzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfV0sIFthZGRyZXNzLCBkYXRhLCBzaWduYXR1cmVdKSxcbiAgICAgICAgRVJDXzY0OTJfTUFHSUNfVkFMVUUsXG4gICAgXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemUtZXJjNjQ5Mi1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbImVuY29kZUFiaVBhcmFtZXRlcnMiLCJjb25jYXRIZXgiLCJFUkNfNjQ5Ml9NQUdJQ19WQUxVRSIsInNlcmlhbGl6ZUVyYzY0OTJTaWduYXR1cmUiLCJhZGRyZXNzIiwiZGF0YSIsInNpZ25hdHVyZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/verify-hash.js":
/*!************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/auth/verify-hash.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyEip1271Signature: function() { return /* binding */ verifyEip1271Signature; },\n/* harmony export */   verifyHash: function() { return /* binding */ verifyHash; }\n/* harmony export */ });\n/* harmony import */ var ox_Abi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ox/Abi */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Abi.js\");\n/* harmony import */ var ox_AbiConstructor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ox/AbiConstructor */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiConstructor.js\");\n/* harmony import */ var ox_AbiFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ox/AbiFunction */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AbiFunction.js\");\n/* harmony import */ var ox_Signature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ox/Signature */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var ox_erc6492__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ox/erc6492 */ \"(app-pages-browser)/./node_modules/ox/_esm/erc6492/WrappedSignature.js\");\n/* harmony import */ var _contract_contract_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../contract/contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/contract/contract.js\");\n/* harmony import */ var _extensions_erc1271_generated_isValidSignature_read_isValidSignature_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\");\n/* harmony import */ var _rpc_actions_eth_call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../rpc/actions/eth_call.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/rpc/actions/eth_call.js\");\n/* harmony import */ var _rpc_rpc_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../rpc/rpc.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/rpc/rpc.js\");\n/* harmony import */ var _utils_any_evm_zksync_isZkSyncChain_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/any-evm/zksync/isZkSyncChain.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/any-evm/zksync/isZkSyncChain.js\");\n/* harmony import */ var _utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/bytecode/is-contract-deployed.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/is-contract-deployed.js\");\n/* harmony import */ var _utils_encoding_from_bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/encoding/from-bytes.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js\");\n/* harmony import */ var _utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js\");\n/* harmony import */ var _utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n/* harmony import */ var _serialize_erc6492_signature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./serialize-erc6492-signature.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ZKSYNC_VALIDATOR_ADDRESS = \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n/**\n * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */ async function verifyHash(param) {\n    let { hash, signature, address, client, chain, accountFactory } = param;\n    const signatureHex = (()=>{\n        if ((0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(signature)) return signature;\n        if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature) return ox_Signature__WEBPACK_IMPORTED_MODULE_1__.toHex(signature);\n        if (signature instanceof Uint8Array) return (0,_utils_encoding_from_bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes)(signature, \"hex\");\n        // We should never hit this but TS doesn't know that\n        throw new Error(\"Invalid signature type for signature \".concat(signature, \": \").concat(typeof signature));\n    })();\n    const isDeployed = await (0,_utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_3__.isContractDeployed)((0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_4__.getContract)({\n        address,\n        client,\n        chain\n    }));\n    if (isDeployed) {\n        const validEip1271 = await verifyEip1271Signature({\n            hash,\n            signature: signatureHex,\n            contract: (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_4__.getContract)({\n                chain,\n                address,\n                client\n            })\n        }).catch((err)=>{\n            console.error(\"Error verifying EIP-1271 signature\", err);\n            return false;\n        });\n        if (validEip1271) {\n            return true;\n        }\n    }\n    // contract not deployed, use erc6492 validator to verify signature\n    const wrappedSignature = await (async ()=>{\n        // If no factory is provided, we have to assume its already deployed or is an EOA\n        // TODO: Figure out how to automatically tell if our default factory was used\n        if (!accountFactory) return signatureHex;\n        // If this sigature was already wrapped for ERC-6492, carry on\n        if (ox_erc6492__WEBPACK_IMPORTED_MODULE_5__.validate(signatureHex)) return signatureHex;\n        // Otherwise, serialize the signature for ERC-6492 validation\n        return (0,_serialize_erc6492_signature_js__WEBPACK_IMPORTED_MODULE_6__.serializeErc6492Signature)({\n            address: accountFactory.address,\n            data: accountFactory.verificationCalldata,\n            signature: signatureHex\n        });\n    })();\n    let verificationData;\n    const zkSyncChain = await (0,_utils_any_evm_zksync_isZkSyncChain_js__WEBPACK_IMPORTED_MODULE_7__.isZkSyncChain)(chain);\n    const abi = ox_Abi__WEBPACK_IMPORTED_MODULE_8__.from(ox_erc6492__WEBPACK_IMPORTED_MODULE_5__.universalSignatureValidatorAbi);\n    if (zkSyncChain) {\n        // zksync chains dont support deploying code with eth_call\n        // need to call a deployed contract instead\n        verificationData = {\n            to: ZKSYNC_VALIDATOR_ADDRESS,\n            data: ox_AbiFunction__WEBPACK_IMPORTED_MODULE_9__.encodeData(ox_AbiFunction__WEBPACK_IMPORTED_MODULE_9__.fromAbi(abi, \"isValidSig\"), [\n                address,\n                hash,\n                wrappedSignature\n            ])\n        };\n    } else {\n        const validatorConstructor = ox_AbiConstructor__WEBPACK_IMPORTED_MODULE_10__.fromAbi(abi);\n        verificationData = {\n            data: ox_AbiConstructor__WEBPACK_IMPORTED_MODULE_10__.encode(validatorConstructor, {\n                args: [\n                    address,\n                    hash,\n                    wrappedSignature\n                ],\n                bytecode: ox_erc6492__WEBPACK_IMPORTED_MODULE_5__.universalSignatureValidatorBytecode\n            })\n        };\n    }\n    const rpcRequest = (0,_rpc_rpc_js__WEBPACK_IMPORTED_MODULE_11__.getRpcClient)({\n        chain,\n        client\n    });\n    try {\n        const result = await (0,_rpc_actions_eth_call_js__WEBPACK_IMPORTED_MODULE_12__.eth_call)(rpcRequest, verificationData);\n        return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_13__.hexToBool)(result);\n    } catch (e) {\n        // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n        const validEip1271 = await verifyEip1271Signature({\n            hash,\n            signature: signatureHex,\n            contract: (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_4__.getContract)({\n                chain,\n                address,\n                client\n            })\n        }).catch((err)=>{\n            console.error(\"Error verifying EIP-1271 signature\", err);\n            return false;\n        });\n        if (validEip1271) {\n            return true;\n        }\n        // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n        // Verification failed somehow\n        return false;\n    }\n}\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nasync function verifyEip1271Signature(param) {\n    let { hash, signature, contract } = param;\n    try {\n        const result = await (0,_extensions_erc1271_generated_isValidSignature_read_isValidSignature_js__WEBPACK_IMPORTED_MODULE_14__.isValidSignature)({\n            hash,\n            signature,\n            contract\n        });\n        return result === EIP_1271_MAGIC_VALUE;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=verify-hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9hdXRoL3ZlcmlmeS1oYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ3NCO0FBQ047QUFDSjtBQUN3QjtBQUNoQjtBQUMyRDtBQUMzRDtBQUNUO0FBQzRCO0FBQ007QUFDbkI7QUFDQTtBQUNpQjtBQUM3RSxNQUFNZ0IsMkJBQTJCO0FBQ2pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDTSxlQUFlQyxXQUFXLEtBQTREO1FBQTVELEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxjQUFjLEVBQUcsR0FBNUQ7SUFDN0IsTUFBTUMsZUFBZSxDQUFDO1FBQ2xCLElBQUlWLDZEQUFLQSxDQUFDSyxZQUNOLE9BQU9BO1FBQ1gsSUFBSSxPQUFPQSxjQUFjLFlBQVksT0FBT0EsYUFBYSxPQUFPQSxXQUM1RCxPQUFPaEIsK0NBQW1CLENBQUNnQjtRQUMvQixJQUFJQSxxQkFBcUJPLFlBQ3JCLE9BQU9kLHdFQUFTQSxDQUFDTyxXQUFXO1FBQ2hDLG9EQUFvRDtRQUNwRCxNQUFNLElBQUlRLE1BQU0sd0NBQXNELE9BQWRSLFdBQVUsTUFBcUIsT0FBakIsT0FBT0E7SUFDakY7SUFDQSxNQUFNUyxhQUFhLE1BQU1qQiwyRkFBa0JBLENBQUNMLGtFQUFXQSxDQUFDO1FBQ3BEYztRQUNBQztRQUNBQztJQUNKO0lBQ0EsSUFBSU0sWUFBWTtRQUNaLE1BQU1DLGVBQWUsTUFBTUMsdUJBQXVCO1lBQzlDWjtZQUNBQyxXQUFXSztZQUNYTyxVQUFVekIsa0VBQVdBLENBQUM7Z0JBQ2xCZ0I7Z0JBQ0FGO2dCQUNBQztZQUNKO1FBQ0osR0FBR1csS0FBSyxDQUFDLENBQUNDO1lBQ05DLFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NGO1lBQ3BELE9BQU87UUFDWDtRQUNBLElBQUlKLGNBQWM7WUFDZCxPQUFPO1FBQ1g7SUFDSjtJQUNBLG1FQUFtRTtJQUNuRSxNQUFNTyxtQkFBbUIsTUFBTSxDQUFDO1FBQzVCLGlGQUFpRjtRQUNqRiw2RUFBNkU7UUFDN0UsSUFBSSxDQUFDYixnQkFDRCxPQUFPQztRQUNYLDhEQUE4RDtRQUM5RCxJQUFJbkIsZ0RBQTZCLENBQUNtQixlQUM5QixPQUFPQTtRQUNYLDZEQUE2RDtRQUM3RCxPQUFPVCwwRkFBeUJBLENBQUM7WUFDN0JLLFNBQVNHLGVBQWVILE9BQU87WUFDL0JrQixNQUFNZixlQUFlZ0Isb0JBQW9CO1lBQ3pDcEIsV0FBV0s7UUFDZjtJQUNKO0lBQ0EsSUFBSWdCO0lBQ0osTUFBTUMsY0FBYyxNQUFNL0IscUZBQWFBLENBQUNZO0lBQ3hDLE1BQU1vQixNQUFNMUMsd0NBQVksQ0FBQ0ssc0VBQW1EO0lBQzVFLElBQUlvQyxhQUFhO1FBQ2IsMERBQTBEO1FBQzFELDJDQUEyQztRQUMzQ0QsbUJBQW1CO1lBQ2ZLLElBQUk3QjtZQUNKc0IsTUFBTXBDLHNEQUEwQixDQUFDQSxtREFBdUIsQ0FBQ3dDLEtBQUssZUFBZTtnQkFBQ3RCO2dCQUFTRjtnQkFBTWtCO2FBQWlCO1FBQ2xIO0lBQ0osT0FDSztRQUNELE1BQU1ZLHVCQUF1Qi9DLHVEQUEwQixDQUFDeUM7UUFDeERGLG1CQUFtQjtZQUNmRixNQUFNckMsc0RBQXlCLENBQUMrQyxzQkFBc0I7Z0JBQ2xERSxNQUFNO29CQUFDOUI7b0JBQVNGO29CQUFNa0I7aUJBQWlCO2dCQUN2Q2UsVUFBVTlDLDJFQUF3RDtZQUN0RTtRQUNKO0lBQ0o7SUFDQSxNQUFNZ0QsYUFBYTVDLDBEQUFZQSxDQUFDO1FBQzVCYTtRQUNBRDtJQUNKO0lBQ0EsSUFBSTtRQUNBLE1BQU1pQyxTQUFTLE1BQU05QyxtRUFBUUEsQ0FBQzZDLFlBQVliO1FBQzFDLE9BQU8zQixrRUFBU0EsQ0FBQ3lDO0lBQ3JCLEVBQ0EsVUFBTTtRQUNGLGtIQUFrSDtRQUNsSCxNQUFNekIsZUFBZSxNQUFNQyx1QkFBdUI7WUFDOUNaO1lBQ0FDLFdBQVdLO1lBQ1hPLFVBQVV6QixrRUFBV0EsQ0FBQztnQkFDbEJnQjtnQkFDQUY7Z0JBQ0FDO1lBQ0o7UUFDSixHQUFHVyxLQUFLLENBQUMsQ0FBQ0M7WUFDTkMsUUFBUUMsS0FBSyxDQUFDLHNDQUFzQ0Y7WUFDcEQsT0FBTztRQUNYO1FBQ0EsSUFBSUosY0FBYztZQUNkLE9BQU87UUFDWDtRQUNBLHlIQUF5SDtRQUN6SCw4QkFBOEI7UUFDOUIsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNMEIsdUJBQXVCO0FBQ3RCLGVBQWV6Qix1QkFBdUIsS0FBOEI7UUFBOUIsRUFBRVosSUFBSSxFQUFFQyxTQUFTLEVBQUVZLFFBQVEsRUFBRyxHQUE5QjtJQUN6QyxJQUFJO1FBQ0EsTUFBTXVCLFNBQVMsTUFBTS9DLDBIQUFnQkEsQ0FBQztZQUNsQ1c7WUFDQUM7WUFDQVk7UUFDSjtRQUNBLE9BQU91QixXQUFXQztJQUN0QixFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vYXV0aC92ZXJpZnktaGFzaC5qcz9lYmE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG94X19BYmkgZnJvbSBcIm94L0FiaVwiO1xuaW1wb3J0ICogYXMgb3hfX0FiaUNvbnN0cnVjdG9yIGZyb20gXCJveC9BYmlDb25zdHJ1Y3RvclwiO1xuaW1wb3J0ICogYXMgb3hfX0FiaUZ1bmN0aW9uIGZyb20gXCJveC9BYmlGdW5jdGlvblwiO1xuaW1wb3J0ICogYXMgb3hfX1NpZ25hdHVyZSBmcm9tIFwib3gvU2lnbmF0dXJlXCI7XG5pbXBvcnQgeyBXcmFwcGVkU2lnbmF0dXJlIGFzIG94X19XcmFwcGVkU2lnbmF0dXJlIH0gZnJvbSBcIm94L2VyYzY0OTJcIjtcbmltcG9ydCB7IGdldENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2NvbnRyYWN0LmpzXCI7XG5pbXBvcnQgeyBpc1ZhbGlkU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2V4dGVuc2lvbnMvZXJjMTI3MS9fX2dlbmVyYXRlZF9fL2lzVmFsaWRTaWduYXR1cmUvcmVhZC9pc1ZhbGlkU2lnbmF0dXJlLmpzXCI7XG5pbXBvcnQgeyBldGhfY2FsbCB9IGZyb20gXCIuLi9ycGMvYWN0aW9ucy9ldGhfY2FsbC5qc1wiO1xuaW1wb3J0IHsgZ2V0UnBjQ2xpZW50IH0gZnJvbSBcIi4uL3JwYy9ycGMuanNcIjtcbmltcG9ydCB7IGlzWmtTeW5jQ2hhaW4gfSBmcm9tIFwiLi4vdXRpbHMvYW55LWV2bS96a3N5bmMvaXNaa1N5bmNDaGFpbi5qc1wiO1xuaW1wb3J0IHsgaXNDb250cmFjdERlcGxveWVkIH0gZnJvbSBcIi4uL3V0aWxzL2J5dGVjb2RlL2lzLWNvbnRyYWN0LWRlcGxveWVkLmpzXCI7XG5pbXBvcnQgeyBmcm9tQnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvZW5jb2RpbmcvZnJvbS1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgaGV4VG9Cb29sLCBpc0hleCB9IGZyb20gXCIuLi91dGlscy9lbmNvZGluZy9oZXguanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZUVyYzY0OTJTaWduYXR1cmUgfSBmcm9tIFwiLi9zZXJpYWxpemUtZXJjNjQ5Mi1zaWduYXR1cmUuanNcIjtcbmNvbnN0IFpLU1lOQ19WQUxJREFUT1JfQUREUkVTUyA9IFwiMHhmQjY4ODMzMDM3OTk3NkRBODFlQjY0RmU0QkY1MGQ3NDAxNzYzQjlDXCI7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBWZXJpZnkgdGhhdCBhbiBhZGRyZXNzIGNyZWF0ZWQgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBmb3IgYSBnaXZlbiBoYXNoIHVzaW5nIFtFUkMtNjQ5Ml0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyKS4gVGhpcyBmdW5jdGlvbiBpcyBpbnRlcm9wZXJhYmxlIHdpdGggYWxsIHdhbGxldCB0eXBlcywgaW5jbHVkaW5nIEVPQXMuXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCByYXJlbHkgYmUgdXNlZCBkaXJlY3RseSwgaW5zdGVhZCB1c2UgQHNlZSB7aW1wb3J0KFwiLi92ZXJpZnktc2lnbmF0dXJlLmpzXCIpfSBhbmQgQHNlZSB7aW1wb3J0KFwiLi92ZXJpZnktdHlwZWQtZGF0YS5qc1wiKX19XG4gKlxuICogQHBhcmFtIHtIZXh9IG9wdGlvbnMuaGFzaCBUaGUgaGFzaCB0aGF0IHdhcyBzaWduZWRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheSB8IFNpZ25hdHVyZX0gb3B0aW9ucy5zaWduYXR1cmUgVGhlIHNpZ25hdHVyZSB0aGF0IHdhcyBzaWduZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFkZHJlc3MgVGhlIGFkZHJlc3MgdGhhdCBzaWduZWQgdGhlIGhhc2hcbiAqIEBwYXJhbSB7VGhpcmR3ZWJDbGllbnR9IG9wdGlvbnMuY2xpZW50IFRoZSBUaGlyZHdlYiBjbGllbnRcbiAqIEBwYXJhbSB7Q2hhaW59IG9wdGlvbnMuY2hhaW4gVGhlIGNoYWluIHRoYXQgdGhlIGFkZHJlc3MgaXMgb24uIEZvciBhbiBFT0EsIHRoaXMgY2FuIGJlIGFueSBjaGFpbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hY2NvdW50RmFjdG9yeS5hZGRyZXNzXSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCBmYWN0b3J5IHRoYXQgY3JlYXRlZCB0aGUgYWNjb3VudCBpZiB1c2luZyBhIHNtYXJ0IGFjY291bnQgd2l0aCBhIGN1c3RvbSBhY2NvdW50IGZhY3RvcnlcbiAqIEBwYXJhbSB7SGV4fSBbb3B0aW9ucy5hY2NvdW50RmFjdG9yeS52ZXJpZmljYXRpb25DYWxsZGF0YV0gVGhlIGNhbGxkYXRhIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRoZSBhY2NvdW50IGlmIHVzaW5nIGEgc21hcnQgYWNjb3VudCB3aXRoIGEgY3VzdG9tIGFjY291bnQgZmFjdG9yeVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB2ZXJpZnlIYXNoIH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzXCI7XG4gKiBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5SGFzaCh7XG4gKiAgIGhhc2g6IFwiMHgxMjM0XCIsXG4gKiAgIHNpZ25hdHVyZTogXCIweDEyMzRcIixcbiAqICAgYWRkcmVzczogXCIweDEyMzRcIixcbiAqICAgY2xpZW50LFxuICogICBjaGFpbixcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGF1dGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUhhc2goeyBoYXNoLCBzaWduYXR1cmUsIGFkZHJlc3MsIGNsaWVudCwgY2hhaW4sIGFjY291bnRGYWN0b3J5LCB9KSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGlzSGV4KHNpZ25hdHVyZSkpXG4gICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJvYmplY3RcIiAmJiBcInJcIiBpbiBzaWduYXR1cmUgJiYgXCJzXCIgaW4gc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG94X19TaWduYXR1cmUudG9IZXgoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHNpZ25hdHVyZSwgXCJoZXhcIik7XG4gICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoaXQgdGhpcyBidXQgVFMgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSB0eXBlIGZvciBzaWduYXR1cmUgJHtzaWduYXR1cmV9OiAke3R5cGVvZiBzaWduYXR1cmV9YCk7XG4gICAgfSkoKTtcbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgaXNDb250cmFjdERlcGxveWVkKGdldENvbnRyYWN0KHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBjaGFpbixcbiAgICB9KSk7XG4gICAgaWYgKGlzRGVwbG95ZWQpIHtcbiAgICAgICAgY29uc3QgdmFsaWRFaXAxMjcxID0gYXdhaXQgdmVyaWZ5RWlwMTI3MVNpZ25hdHVyZSh7XG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVIZXgsXG4gICAgICAgICAgICBjb250cmFjdDogZ2V0Q29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB2ZXJpZnlpbmcgRUlQLTEyNzEgc2lnbmF0dXJlXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWRFaXAxMjcxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb250cmFjdCBub3QgZGVwbG95ZWQsIHVzZSBlcmM2NDkyIHZhbGlkYXRvciB0byB2ZXJpZnkgc2lnbmF0dXJlXG4gICAgY29uc3Qgd3JhcHBlZFNpZ25hdHVyZSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIElmIG5vIGZhY3RvcnkgaXMgcHJvdmlkZWQsIHdlIGhhdmUgdG8gYXNzdW1lIGl0cyBhbHJlYWR5IGRlcGxveWVkIG9yIGlzIGFuIEVPQVxuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyB0byBhdXRvbWF0aWNhbGx5IHRlbGwgaWYgb3VyIGRlZmF1bHQgZmFjdG9yeSB3YXMgdXNlZFxuICAgICAgICBpZiAoIWFjY291bnRGYWN0b3J5KVxuICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUhleDtcbiAgICAgICAgLy8gSWYgdGhpcyBzaWdhdHVyZSB3YXMgYWxyZWFkeSB3cmFwcGVkIGZvciBFUkMtNjQ5MiwgY2Fycnkgb25cbiAgICAgICAgaWYgKG94X19XcmFwcGVkU2lnbmF0dXJlLnZhbGlkYXRlKHNpZ25hdHVyZUhleCkpXG4gICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlSGV4O1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNlcmlhbGl6ZSB0aGUgc2lnbmF0dXJlIGZvciBFUkMtNjQ5MiB2YWxpZGF0aW9uXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVFcmM2NDkyU2lnbmF0dXJlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFjY291bnRGYWN0b3J5LmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBhY2NvdW50RmFjdG9yeS52ZXJpZmljYXRpb25DYWxsZGF0YSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlSGV4LFxuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIGxldCB2ZXJpZmljYXRpb25EYXRhO1xuICAgIGNvbnN0IHprU3luY0NoYWluID0gYXdhaXQgaXNaa1N5bmNDaGFpbihjaGFpbik7XG4gICAgY29uc3QgYWJpID0gb3hfX0FiaS5mcm9tKG94X19XcmFwcGVkU2lnbmF0dXJlLnVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSk7XG4gICAgaWYgKHprU3luY0NoYWluKSB7XG4gICAgICAgIC8vIHprc3luYyBjaGFpbnMgZG9udCBzdXBwb3J0IGRlcGxveWluZyBjb2RlIHdpdGggZXRoX2NhbGxcbiAgICAgICAgLy8gbmVlZCB0byBjYWxsIGEgZGVwbG95ZWQgY29udHJhY3QgaW5zdGVhZFxuICAgICAgICB2ZXJpZmljYXRpb25EYXRhID0ge1xuICAgICAgICAgICAgdG86IFpLU1lOQ19WQUxJREFUT1JfQUREUkVTUyxcbiAgICAgICAgICAgIGRhdGE6IG94X19BYmlGdW5jdGlvbi5lbmNvZGVEYXRhKG94X19BYmlGdW5jdGlvbi5mcm9tQWJpKGFiaSwgXCJpc1ZhbGlkU2lnXCIpLCBbYWRkcmVzcywgaGFzaCwgd3JhcHBlZFNpZ25hdHVyZV0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yQ29uc3RydWN0b3IgPSBveF9fQWJpQ29uc3RydWN0b3IuZnJvbUFiaShhYmkpO1xuICAgICAgICB2ZXJpZmljYXRpb25EYXRhID0ge1xuICAgICAgICAgICAgZGF0YTogb3hfX0FiaUNvbnN0cnVjdG9yLmVuY29kZSh2YWxpZGF0b3JDb25zdHJ1Y3Rvciwge1xuICAgICAgICAgICAgICAgIGFyZ3M6IFthZGRyZXNzLCBoYXNoLCB3cmFwcGVkU2lnbmF0dXJlXSxcbiAgICAgICAgICAgICAgICBieXRlY29kZTogb3hfX1dyYXBwZWRTaWduYXR1cmUudW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQnl0ZWNvZGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcnBjUmVxdWVzdCA9IGdldFJwY0NsaWVudCh7XG4gICAgICAgIGNoYWluLFxuICAgICAgICBjbGllbnQsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXRoX2NhbGwocnBjUmVxdWVzdCwgdmVyaWZpY2F0aW9uRGF0YSk7XG4gICAgICAgIHJldHVybiBoZXhUb0Jvb2wocmVzdWx0KTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBTb21lIGNoYWlucyBkbyBub3Qgc3VwcG9ydCB0aGUgZXRoX2NhbGwgc2ltdWxhdGlvbiBhbmQgd2lsbCBmYWlsLCBzbyB3ZSBmYWxsIGJhY2sgdG8gcmVndWxhciBFSVAxMjcxIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdmFsaWRFaXAxMjcxID0gYXdhaXQgdmVyaWZ5RWlwMTI3MVNpZ25hdHVyZSh7XG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVIZXgsXG4gICAgICAgICAgICBjb250cmFjdDogZ2V0Q29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB2ZXJpZnlpbmcgRUlQLTEyNzEgc2lnbmF0dXJlXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWRFaXAxMjcxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBJbXByb3ZlIG92ZXJhbGwgUlBDIGVycm9yIGhhbmRsaW5nIHNvIHdlIGNhbiB0ZWxsIGlmIHRoaXMgd2FzIGFuIGFjdHVhbCB2ZXJpZmljYXRpb24gZmFpbHVyZSBvciBzb21lIG90aGVyIGVycm9yXG4gICAgICAgIC8vIFZlcmlmaWNhdGlvbiBmYWlsZWQgc29tZWhvd1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgRUlQXzEyNzFfTUFHSUNfVkFMVUUgPSBcIjB4MTYyNmJhN2VcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlFaXAxMjcxU2lnbmF0dXJlKHsgaGFzaCwgc2lnbmF0dXJlLCBjb250cmFjdCwgfSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzVmFsaWRTaWduYXR1cmUoe1xuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gRUlQXzEyNzFfTUFHSUNfVkFMVUU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcmlmeS1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJveF9fQWJpIiwib3hfX0FiaUNvbnN0cnVjdG9yIiwib3hfX0FiaUZ1bmN0aW9uIiwib3hfX1NpZ25hdHVyZSIsIldyYXBwZWRTaWduYXR1cmUiLCJveF9fV3JhcHBlZFNpZ25hdHVyZSIsImdldENvbnRyYWN0IiwiaXNWYWxpZFNpZ25hdHVyZSIsImV0aF9jYWxsIiwiZ2V0UnBjQ2xpZW50IiwiaXNaa1N5bmNDaGFpbiIsImlzQ29udHJhY3REZXBsb3llZCIsImZyb21CeXRlcyIsImhleFRvQm9vbCIsImlzSGV4Iiwic2VyaWFsaXplRXJjNjQ5MlNpZ25hdHVyZSIsIlpLU1lOQ19WQUxJREFUT1JfQUREUkVTUyIsInZlcmlmeUhhc2giLCJoYXNoIiwic2lnbmF0dXJlIiwiYWRkcmVzcyIsImNsaWVudCIsImNoYWluIiwiYWNjb3VudEZhY3RvcnkiLCJzaWduYXR1cmVIZXgiLCJ0b0hleCIsIlVpbnQ4QXJyYXkiLCJFcnJvciIsImlzRGVwbG95ZWQiLCJ2YWxpZEVpcDEyNzEiLCJ2ZXJpZnlFaXAxMjcxU2lnbmF0dXJlIiwiY29udHJhY3QiLCJjYXRjaCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIndyYXBwZWRTaWduYXR1cmUiLCJ2YWxpZGF0ZSIsImRhdGEiLCJ2ZXJpZmljYXRpb25DYWxsZGF0YSIsInZlcmlmaWNhdGlvbkRhdGEiLCJ6a1N5bmNDaGFpbiIsImFiaSIsImZyb20iLCJ1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JBYmkiLCJ0byIsImVuY29kZURhdGEiLCJmcm9tQWJpIiwidmFsaWRhdG9yQ29uc3RydWN0b3IiLCJlbmNvZGUiLCJhcmdzIiwiYnl0ZWNvZGUiLCJ1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JCeXRlY29kZSIsInJwY1JlcXVlc3QiLCJyZXN1bHQiLCJFSVBfMTI3MV9NQUdJQ19WQUxVRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/verify-hash.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FN_SELECTOR: function() { return /* binding */ FN_SELECTOR; },\n/* harmony export */   decodeIsValidSignatureResult: function() { return /* binding */ decodeIsValidSignatureResult; },\n/* harmony export */   encodeIsValidSignature: function() { return /* binding */ encodeIsValidSignature; },\n/* harmony export */   encodeIsValidSignatureParams: function() { return /* binding */ encodeIsValidSignatureParams; },\n/* harmony export */   isIsValidSignatureSupported: function() { return /* binding */ isIsValidSignatureSupported; },\n/* harmony export */   isValidSignature: function() { return /* binding */ isValidSignature; }\n/* harmony export */ });\n/* harmony import */ var _transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../transaction/read-contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/read-contract.js\");\n/* harmony import */ var _utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../utils/abi/encodeAbiParameters.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/abi/decodeAbiParameters.js\");\n/* harmony import */ var _utils_bytecode_detectExtension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../utils/bytecode/detectExtension.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/detectExtension.js\");\n\n\n\n\nconst FN_SELECTOR = \"0x1626ba7e\";\nconst FN_INPUTS = [\n    {\n        type: \"bytes32\",\n        name: \"hash\"\n    },\n    {\n        type: \"bytes\",\n        name: \"signature\"\n    }\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"bytes4\"\n    }\n];\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n * const supported = isIsValidSignatureSupported([\"0x...\"]);\n * ```\n */ function isIsValidSignatureSupported(availableSelectors) {\n    return (0,_utils_bytecode_detectExtension_js__WEBPACK_IMPORTED_MODULE_0__.detectMethod)({\n        availableSelectors,\n        method: [\n            FN_SELECTOR,\n            FN_INPUTS,\n            FN_OUTPUTS\n        ]\n    });\n}\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */ function encodeIsValidSignatureParams(options) {\n    return (0,_utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encodeAbiParameters)(FN_INPUTS, [\n        options.hash,\n        options.signature\n    ]);\n}\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */ function encodeIsValidSignature(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return FN_SELECTOR + encodeIsValidSignatureParams(options).slice(2);\n}\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResultResult(\"...\");\n * ```\n */ function decodeIsValidSignatureResult(result) {\n    return (0,viem__WEBPACK_IMPORTED_MODULE_2__.decodeAbiParameters)(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */ async function isValidSignature(options) {\n    return (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__.readContract)({\n        contract: options.contract,\n        method: [\n            FN_SELECTOR,\n            FN_INPUTS,\n            FN_OUTPUTS\n        ],\n        params: [\n            options.hash,\n            options.signature\n        ]\n    });\n} //# sourceMappingURL=isValidSignature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9leHRlbnNpb25zL2VyYzEyNzEvX19nZW5lcmF0ZWRfXy9pc1ZhbGlkU2lnbmF0dXJlL3JlYWQvaXNWYWxpZFNpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTJFO0FBQ1c7QUFDM0M7QUFDcUM7QUFDekUsTUFBTUksY0FBYyxhQUFhO0FBQ3hDLE1BQU1DLFlBQVk7SUFDZDtRQUNJQyxNQUFNO1FBQ05DLE1BQU07SUFDVjtJQUNBO1FBQ0lELE1BQU07UUFDTkMsTUFBTTtJQUNWO0NBQ0g7QUFDRCxNQUFNQyxhQUFhO0lBQ2Y7UUFDSUYsTUFBTTtJQUNWO0NBQ0g7QUFDRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0csNEJBQTRCQyxrQkFBa0I7SUFDMUQsT0FBT1AsZ0ZBQVlBLENBQUM7UUFDaEJPO1FBQ0FDLFFBQVE7WUFBQ1A7WUFBYUM7WUFBV0c7U0FBVztJQUNoRDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNJLDZCQUE2QkMsT0FBTztJQUNoRCxPQUFPWixzRkFBbUJBLENBQUNJLFdBQVc7UUFBQ1EsUUFBUUMsSUFBSTtRQUFFRCxRQUFRRSxTQUFTO0tBQUM7QUFDM0U7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0MsdUJBQXVCSCxPQUFPO0lBQzFDLGlGQUFpRjtJQUNqRixvRUFBb0U7SUFDcEUsT0FBUVQsY0FDSlEsNkJBQTZCQyxTQUFTSSxLQUFLLENBQUM7QUFDcEQ7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0MsNkJBQTZCQyxNQUFNO0lBQy9DLE9BQU9qQix5REFBbUJBLENBQUNNLFlBQVlXLE9BQU8sQ0FBQyxFQUFFO0FBQ3JEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxlQUFlQyxpQkFBaUJQLE9BQU87SUFDMUMsT0FBT2IsMkVBQVlBLENBQUM7UUFDaEJxQixVQUFVUixRQUFRUSxRQUFRO1FBQzFCVixRQUFRO1lBQUNQO1lBQWFDO1lBQVdHO1NBQVc7UUFDNUNjLFFBQVE7WUFBQ1QsUUFBUUMsSUFBSTtZQUFFRCxRQUFRRSxTQUFTO1NBQUM7SUFDN0M7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vZXh0ZW5zaW9ucy9lcmMxMjcxL19fZ2VuZXJhdGVkX18vaXNWYWxpZFNpZ25hdHVyZS9yZWFkL2lzVmFsaWRTaWduYXR1cmUuanM/NTE0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWFkQ29udHJhY3QgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdHJhbnNhY3Rpb24vcmVhZC1jb250cmFjdC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlQWJpUGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi8uLi8uLi8uLi91dGlscy9hYmkvZW5jb2RlQWJpUGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlQWJpUGFyYW1ldGVycyB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyBkZXRlY3RNZXRob2QgfSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdXRpbHMvYnl0ZWNvZGUvZGV0ZWN0RXh0ZW5zaW9uLmpzXCI7XG5leHBvcnQgY29uc3QgRk5fU0VMRUNUT1IgPSBcIjB4MTYyNmJhN2VcIjtcbmNvbnN0IEZOX0lOUFVUUyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcImhhc2hcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICBuYW1lOiBcInNpZ25hdHVyZVwiLFxuICAgIH0sXG5dO1xuY29uc3QgRk5fT1VUUFVUUyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiYnl0ZXM0XCIsXG4gICAgfSxcbl07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYGlzVmFsaWRTaWduYXR1cmVgIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGdpdmVuIGNvbnRyYWN0LlxuICogQHBhcmFtIGF2YWlsYWJsZVNlbGVjdG9ycyBBbiBhcnJheSBvZiA0Ynl0ZSBmdW5jdGlvbiBzZWxlY3RvcnMgb2YgdGhlIGNvbnRyYWN0LiBZb3UgY2FuIGdldCB0aGlzIGluIHZhcmlvdXMgd2F5cywgc3VjaCBhcyB1c2luZyBcIndoYXRzYWJpXCIgb3IgaWYgeW91IGhhdmUgdGhlIEFCSSBvZiB0aGUgY29udHJhY3QgYXZhaWxhYmxlIHlvdSBjYW4gdXNlIGl0IHRvIGdlbmVyYXRlIHRoZSBzZWxlY3RvcnMuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYGlzVmFsaWRTaWduYXR1cmVgIG1ldGhvZCBpcyBzdXBwb3J0ZWQuXG4gKiBAZXh0ZW5zaW9uIEVSQzEyNzFcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNJc1ZhbGlkU2lnbmF0dXJlU3VwcG9ydGVkIH0gZnJvbSBcInRoaXJkd2ViL2V4dGVuc2lvbnMvZXJjMTI3MVwiO1xuICogY29uc3Qgc3VwcG9ydGVkID0gaXNJc1ZhbGlkU2lnbmF0dXJlU3VwcG9ydGVkKFtcIjB4Li4uXCJdKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJc1ZhbGlkU2lnbmF0dXJlU3VwcG9ydGVkKGF2YWlsYWJsZVNlbGVjdG9ycykge1xuICAgIHJldHVybiBkZXRlY3RNZXRob2Qoe1xuICAgICAgICBhdmFpbGFibGVTZWxlY3RvcnMsXG4gICAgICAgIG1ldGhvZDogW0ZOX1NFTEVDVE9SLCBGTl9JTlBVVFMsIEZOX09VVFBVVFNdLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgXCJpc1ZhbGlkU2lnbmF0dXJlXCIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgaXNWYWxpZFNpZ25hdHVyZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIEFCSSBwYXJhbWV0ZXJzLlxuICogQGV4dGVuc2lvbiBFUkMxMjcxXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVuY29kZUlzVmFsaWRTaWduYXR1cmVQYXJhbXMgfSBmcm9tIFwidGhpcmR3ZWIvZXh0ZW5zaW9ucy9lcmMxMjcxXCI7XG4gKiBjb25zdCByZXN1bHQgPSBlbmNvZGVJc1ZhbGlkU2lnbmF0dXJlUGFyYW1zKHtcbiAqICBoYXNoOiAuLi4sXG4gKiAgc2lnbmF0dXJlOiAuLi4sXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSXNWYWxpZFNpZ25hdHVyZVBhcmFtcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVuY29kZUFiaVBhcmFtZXRlcnMoRk5fSU5QVVRTLCBbb3B0aW9ucy5oYXNoLCBvcHRpb25zLnNpZ25hdHVyZV0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIHRoZSBcImlzVmFsaWRTaWduYXR1cmVcIiBmdW5jdGlvbiBpbnRvIGEgSGV4IHN0cmluZyB3aXRoIGl0cyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGlzVmFsaWRTaWduYXR1cmUgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAZXh0ZW5zaW9uIEVSQzEyNzFcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW5jb2RlSXNWYWxpZFNpZ25hdHVyZSB9IGZyb20gXCJ0aGlyZHdlYi9leHRlbnNpb25zL2VyYzEyNzFcIjtcbiAqIGNvbnN0IHJlc3VsdCA9IGVuY29kZUlzVmFsaWRTaWduYXR1cmUoe1xuICogIGhhc2g6IC4uLixcbiAqICBzaWduYXR1cmU6IC4uLixcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJc1ZhbGlkU2lnbmF0dXJlKG9wdGlvbnMpIHtcbiAgICAvLyB3ZSBkbyBhIFwibWFudWFsXCIgY29uY2F0IGhlcmUgdG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mIHRoZSBcImNvbmNhdEhleFwiIGZ1bmN0aW9uXG4gICAgLy8gd2UgY2FuIGRvIHRoaXMgYmVjYXVzZSB3ZSBrbm93IHRoZSBzcGVjaWZpYyBmb3JtYXRzIG9mIHRoZSB2YWx1ZXNcbiAgICByZXR1cm4gKEZOX1NFTEVDVE9SICtcbiAgICAgICAgZW5jb2RlSXNWYWxpZFNpZ25hdHVyZVBhcmFtcyhvcHRpb25zKS5zbGljZSgyKSk7XG59XG4vKipcbiAqIERlY29kZXMgdGhlIHJlc3VsdCBvZiB0aGUgaXNWYWxpZFNpZ25hdHVyZSBmdW5jdGlvbiBjYWxsLlxuICogQHBhcmFtIHJlc3VsdCAtIFRoZSBoZXhhZGVjaW1hbCByZXN1bHQgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgcmVzdWx0IGFzIHBlciB0aGUgRk5fT1VUUFVUUyBkZWZpbml0aW9uLlxuICogQGV4dGVuc2lvbiBFUkMxMjcxXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGRlY29kZUlzVmFsaWRTaWduYXR1cmVSZXN1bHQgfSBmcm9tIFwidGhpcmR3ZWIvZXh0ZW5zaW9ucy9lcmMxMjcxXCI7XG4gKiBjb25zdCByZXN1bHQgPSBkZWNvZGVJc1ZhbGlkU2lnbmF0dXJlUmVzdWx0UmVzdWx0KFwiLi4uXCIpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVJc1ZhbGlkU2lnbmF0dXJlUmVzdWx0KHJlc3VsdCkge1xuICAgIHJldHVybiBkZWNvZGVBYmlQYXJhbWV0ZXJzKEZOX09VVFBVVFMsIHJlc3VsdClbMF07XG59XG4vKipcbiAqIENhbGxzIHRoZSBcImlzVmFsaWRTaWduYXR1cmVcIiBmdW5jdGlvbiBvbiB0aGUgY29udHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgaXNWYWxpZFNpZ25hdHVyZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLlxuICogQGV4dGVuc2lvbiBFUkMxMjcxXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzVmFsaWRTaWduYXR1cmUgfSBmcm9tIFwidGhpcmR3ZWIvZXh0ZW5zaW9ucy9lcmMxMjcxXCI7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgaXNWYWxpZFNpZ25hdHVyZSh7XG4gKiAgY29udHJhY3QsXG4gKiAgaGFzaDogLi4uLFxuICogIHNpZ25hdHVyZTogLi4uLFxuICogfSk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcmVhZENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3Q6IG9wdGlvbnMuY29udHJhY3QsXG4gICAgICAgIG1ldGhvZDogW0ZOX1NFTEVDVE9SLCBGTl9JTlBVVFMsIEZOX09VVFBVVFNdLFxuICAgICAgICBwYXJhbXM6IFtvcHRpb25zLmhhc2gsIG9wdGlvbnMuc2lnbmF0dXJlXSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmFsaWRTaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbInJlYWRDb250cmFjdCIsImVuY29kZUFiaVBhcmFtZXRlcnMiLCJkZWNvZGVBYmlQYXJhbWV0ZXJzIiwiZGV0ZWN0TWV0aG9kIiwiRk5fU0VMRUNUT1IiLCJGTl9JTlBVVFMiLCJ0eXBlIiwibmFtZSIsIkZOX09VVFBVVFMiLCJpc0lzVmFsaWRTaWduYXR1cmVTdXBwb3J0ZWQiLCJhdmFpbGFibGVTZWxlY3RvcnMiLCJtZXRob2QiLCJlbmNvZGVJc1ZhbGlkU2lnbmF0dXJlUGFyYW1zIiwib3B0aW9ucyIsImhhc2giLCJzaWduYXR1cmUiLCJlbmNvZGVJc1ZhbGlkU2lnbmF0dXJlIiwic2xpY2UiLCJkZWNvZGVJc1ZhbGlkU2lnbmF0dXJlUmVzdWx0IiwicmVzdWx0IiwiaXNWYWxpZFNpZ25hdHVyZSIsImNvbnRyYWN0IiwicGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesToBigInt: function() { return /* binding */ bytesToBigInt; },\n/* harmony export */   bytesToBool: function() { return /* binding */ bytesToBool; },\n/* harmony export */   bytesToNumber: function() { return /* binding */ bytesToNumber; },\n/* harmony export */   bytesToString: function() { return /* binding */ bytesToString; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; }\n/* harmony export */ });\n/* harmony import */ var ox_Bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ox/Bytes */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n\n\n/**\n * Converts a Uint8Array to the specified type.\n * @param bytes - The Uint8Array to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromBytes } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = fromBytes(bytes, \"number\");\n * console.log(number); // 420\n * ```\n * @utils\n */ function fromBytes(bytes, toOrOpts) {\n    const opts = typeof toOrOpts === \"string\" ? {\n        to: toOrOpts\n    } : toOrOpts;\n    switch(opts.to){\n        case \"number\":\n            return bytesToNumber(bytes, opts);\n        case \"bigint\":\n            return bytesToBigInt(bytes, opts);\n        case \"boolean\":\n            return bytesToBool(bytes, opts);\n        case \"string\":\n            return bytesToString(bytes, opts);\n        default:\n            return (0,_hex_js__WEBPACK_IMPORTED_MODULE_0__.uint8ArrayToHex)(bytes, opts);\n    }\n}\n/**\n * Converts a Uint8Array of bytes to a bigint.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The converted bigint.\n * @example\n * ```ts\n * import { bytesToBigInt } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const bigInt = bytesToBigInt(bytes);\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */ function bytesToBigInt(bytes) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ox_Bytes__WEBPACK_IMPORTED_MODULE_1__.toBigInt(bytes, opts);\n}\n/**\n * Converts a byte array to a boolean value.\n * @param bytes_ - The byte array to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The boolean value converted from the byte array.\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\n * @example\n * ```ts\n * import { bytesToBool } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1]);\n * const bool = bytesToBool(bytes);\n * console.log(bool); // true\n * ```\n * @utils\n */ function bytesToBool(bytes_) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ox_Bytes__WEBPACK_IMPORTED_MODULE_1__.toBoolean(bytes_, opts);\n}\n/**\n * Converts a Uint8Array of bytes to a number.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional configuration options.\n * @returns The converted number.\n * @example\n * ```ts\n * import { bytesToNumber } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = bytesToNumber(bytes);\n * console.log(number); // 420\n * ```\n * @utils\n */ function bytesToNumber(bytes) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ox_Bytes__WEBPACK_IMPORTED_MODULE_1__.toNumber(bytes, opts);\n}\n/**\n * Converts an array of bytes to a string using UTF-8 encoding.\n * @param bytes_ - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The resulting string.\n * @example\n * ```ts\n * import { bytesToString } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\n * const string = bytesToString(bytes);\n * console.log(string); // \"Hello\"\n * ```\n * @utils\n */ function bytesToString(bytes_) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return ox_Bytes__WEBPACK_IMPORTED_MODULE_1__.toString(bytes_, opts);\n} //# sourceMappingURL=from-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9lbmNvZGluZy9mcm9tLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0M7QUFDSztBQUMzQzs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0UsVUFBVUMsS0FBSyxFQUFFQyxRQUFRO0lBQ3JDLE1BQU1DLE9BQU8sT0FBT0QsYUFBYSxXQUFXO1FBQUVFLElBQUlGO0lBQVMsSUFBSUE7SUFDL0QsT0FBUUMsS0FBS0MsRUFBRTtRQUNYLEtBQUs7WUFDRCxPQUFPQyxjQUFjSixPQUFPRTtRQUNoQyxLQUFLO1lBQ0QsT0FBT0csY0FBY0wsT0FBT0U7UUFDaEMsS0FBSztZQUNELE9BQU9JLFlBQVlOLE9BQU9FO1FBQzlCLEtBQUs7WUFDRCxPQUFPSyxjQUFjUCxPQUFPRTtRQUNoQztZQUNJLE9BQU9KLHdEQUFlQSxDQUFDRSxPQUFPRTtJQUN0QztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNHLGNBQWNMLEtBQUs7UUFBRUUsT0FBQUEsaUVBQU8sQ0FBQztJQUN6QyxPQUFPTCw4Q0FBa0IsQ0FBQ0csT0FBT0U7QUFDckM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNJLFlBQVlHLE1BQU07UUFBRVAsT0FBQUEsaUVBQU8sQ0FBQztJQUN4QyxPQUFPTCwrQ0FBbUIsQ0FBQ1ksUUFBUVA7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0UsY0FBY0osS0FBSztRQUFFRSxPQUFBQSxpRUFBTyxDQUFDO0lBQ3pDLE9BQU9MLDhDQUFrQixDQUFDRyxPQUFPRTtBQUNyQztBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTSyxjQUFjRSxNQUFNO1FBQUVQLE9BQUFBLGlFQUFPLENBQUM7SUFDMUMsT0FBT0wsOENBQWtCLENBQUNZLFFBQVFQO0FBQ3RDLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9lbmNvZGluZy9mcm9tLWJ5dGVzLmpzPzg5NjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgb3hfX0J5dGVzIGZyb20gXCJveC9CeXRlc1wiO1xuaW1wb3J0IHsgdWludDhBcnJheVRvSGV4IH0gZnJvbSBcIi4vaGV4LmpzXCI7XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgVWludDhBcnJheSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHRvT3JPcHRzIC0gVGhlIHRhcmdldCB0eXBlIG9yIGNvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tQnl0ZXMgfSBmcm9tIFwidGhpcmR3ZWIvdXRpbHNcIjtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDE2NF0pO1xuICogY29uc3QgbnVtYmVyID0gZnJvbUJ5dGVzKGJ5dGVzLCBcIm51bWJlclwiKTtcbiAqIGNvbnNvbGUubG9nKG51bWJlcik7IC8vIDQyMFxuICogYGBgXG4gKiBAdXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdG9Pck9wdHMpIHtcbiAgICBjb25zdCBvcHRzID0gdHlwZW9mIHRvT3JPcHRzID09PSBcInN0cmluZ1wiID8geyB0bzogdG9Pck9wdHMgfSA6IHRvT3JPcHRzO1xuICAgIHN3aXRjaCAob3B0cy50bykge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlcihieXRlcywgb3B0cyk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvQmlnSW50KGJ5dGVzLCBvcHRzKTtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvQm9vbChieXRlcywgb3B0cyk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvU3RyaW5nKGJ5dGVzLCBvcHRzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9IZXgoYnl0ZXMsIG9wdHMpO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IG9mIGJ5dGVzIHRvIGEgYmlnaW50LlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGNvbnZlcnNpb24uXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJpZ2ludC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgYnl0ZXNUb0JpZ0ludCB9IGZyb20gXCJ0aGlyZHdlYi91dGlsc1wiO1xuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMTY0XSk7XG4gKiBjb25zdCBiaWdJbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAqIGNvbnNvbGUubG9nKGJpZ0ludCk7IC8vIDQyMG5cbiAqIGBgYFxuICogQHV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gb3hfX0J5dGVzLnRvQmlnSW50KGJ5dGVzLCBvcHRzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBieXRlIGFycmF5IHRvIGEgYm9vbGVhbiB2YWx1ZS5cbiAqIEBwYXJhbSBieXRlc18gLSBUaGUgYnl0ZSBhcnJheSB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgY29udmVyc2lvbi5cbiAqIEByZXR1cm5zIFRoZSBib29sZWFuIHZhbHVlIGNvbnZlcnRlZCBmcm9tIHRoZSBieXRlIGFycmF5LlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYnl0ZSBhcnJheSBpcyBpbnZhbGlkIG9yIHRoZSBib29sZWFuIHJlcHJlc2VudGF0aW9uIGlzIGludmFsaWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGJ5dGVzVG9Cb29sIH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzXCI7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxXSk7XG4gKiBjb25zdCBib29sID0gYnl0ZXNUb0Jvb2woYnl0ZXMpO1xuICogY29uc29sZS5sb2coYm9vbCk7IC8vIHRydWVcbiAqIGBgYFxuICogQHV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvQm9vbChieXRlc18sIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBveF9fQnl0ZXMudG9Cb29sZWFuKGJ5dGVzXywgb3B0cyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSBvZiBieXRlcyB0byBhIG51bWJlci5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBVaW50OEFycmF5IG9mIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBieXRlc1RvTnVtYmVyIH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzXCI7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAxNjRdKTtcbiAqIGNvbnN0IG51bWJlciA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMpO1xuICogY29uc29sZS5sb2cobnVtYmVyKTsgLy8gNDIwXG4gKiBgYGBcbiAqIEB1dGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcywgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG94X19CeXRlcy50b051bWJlcihieXRlcywgb3B0cyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGEgc3RyaW5nIHVzaW5nIFVURi04IGVuY29kaW5nLlxuICogQHBhcmFtIGJ5dGVzXyAtIFRoZSBhcnJheSBvZiBieXRlcyB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgY29udmVyc2lvbi5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBieXRlc1RvU3RyaW5nIH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzXCI7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExXSk7XG4gKiBjb25zdCBzdHJpbmcgPSBieXRlc1RvU3RyaW5nKGJ5dGVzKTtcbiAqIGNvbnNvbGUubG9nKHN0cmluZyk7IC8vIFwiSGVsbG9cIlxuICogYGBgXG4gKiBAdXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXNfLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gb3hfX0J5dGVzLnRvU3RyaW5nKGJ5dGVzXywgb3B0cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJveF9fQnl0ZXMiLCJ1aW50OEFycmF5VG9IZXgiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInRvT3JPcHRzIiwib3B0cyIsInRvIiwiYnl0ZXNUb051bWJlciIsImJ5dGVzVG9CaWdJbnQiLCJieXRlc1RvQm9vbCIsImJ5dGVzVG9TdHJpbmciLCJ0b0JpZ0ludCIsImJ5dGVzXyIsInRvQm9vbGVhbiIsInRvTnVtYmVyIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMessage: function() { return /* binding */ hashMessage; }\n/* harmony export */ });\n/* harmony import */ var ox_Bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ox/Bytes */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/to-bytes.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js\");\n/* harmony import */ var _keccak256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keccak256.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js\");\n\n\n\nconst presignMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n/**\n * Ethereum Signed Message hashing\n * @param message - The message to hash, either as a string, a Uint8Array, or an object with a `raw` property containing a Uint8Array.\n * @param to_ - The desired output format of the hash (optional). Defaults to 'hex'.\n * @example\n * ```ts\n * import { hashMessage } from \"thirdweb/utils\";\n * const hash = hashMessage(\"hello world\");\n * ```\n * @returns The Ethereum Signed Message hash of the message in the specified format.\n * @utils\n */ function hashMessage(message, to_) {\n    const messageBytes = (()=>{\n        if (typeof message === \"string\") {\n            return (0,_encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n            return message.raw;\n        }\n        return (0,_encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(message.raw);\n    })();\n    const prefixBytes = (0,_encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(\"\".concat(presignMessagePrefix).concat(messageBytes.length));\n    return (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(ox_Bytes__WEBPACK_IMPORTED_MODULE_2__.concat(prefixBytes, messageBytes), to_);\n} //# sourceMappingURL=hashMessage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9oYXNoaW5nL2hhc2hNZXNzYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0M7QUFDMkI7QUFDdEI7QUFDM0MsTUFBTUksdUJBQXVCO0FBQzdCOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU0MsWUFBWUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3BDLE1BQU1DLGVBQWUsQ0FBQztRQUNsQixJQUFJLE9BQU9GLFlBQVksVUFBVTtZQUM3QixPQUFPTCxvRUFBYUEsQ0FBQ0s7UUFDekI7UUFDQSxJQUFJQSxRQUFRRyxHQUFHLFlBQVlDLFlBQVk7WUFDbkMsT0FBT0osUUFBUUcsR0FBRztRQUN0QjtRQUNBLE9BQU9QLDhEQUFPQSxDQUFDSSxRQUFRRyxHQUFHO0lBQzlCO0lBQ0EsTUFBTUUsY0FBY1Ysb0VBQWFBLENBQUMsR0FBMEJPLE9BQXZCSixzQkFBMkMsT0FBcEJJLGFBQWFJLE1BQU07SUFDL0UsT0FBT1Qsd0RBQVNBLENBQUNILDRDQUFnQixDQUFDVyxhQUFhSCxlQUFlRDtBQUNsRSxFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvaGFzaGluZy9oYXNoTWVzc2FnZS5qcz9iNDgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG94X19CeXRlcyBmcm9tIFwib3gvQnl0ZXNcIjtcbmltcG9ydCB7IHN0cmluZ1RvQnl0ZXMsIHRvQnl0ZXMgfSBmcm9tIFwiLi4vZW5jb2RpbmcvdG8tYnl0ZXMuanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuL2tlY2NhazI1Ni5qc1wiO1xuY29uc3QgcHJlc2lnbk1lc3NhZ2VQcmVmaXggPSBcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7XG4vKipcbiAqIEV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlIGhhc2hpbmdcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gaGFzaCwgZWl0aGVyIGFzIGEgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIG9yIGFuIG9iamVjdCB3aXRoIGEgYHJhd2AgcHJvcGVydHkgY29udGFpbmluZyBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gdG9fIC0gVGhlIGRlc2lyZWQgb3V0cHV0IGZvcm1hdCBvZiB0aGUgaGFzaCAob3B0aW9uYWwpLiBEZWZhdWx0cyB0byAnaGV4Jy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaGFzaE1lc3NhZ2UgfSBmcm9tIFwidGhpcmR3ZWIvdXRpbHNcIjtcbiAqIGNvbnN0IGhhc2ggPSBoYXNoTWVzc2FnZShcImhlbGxvIHdvcmxkXCIpO1xuICogYGBgXG4gKiBAcmV0dXJucyBUaGUgRXRoZXJldW0gU2lnbmVkIE1lc3NhZ2UgaGFzaCBvZiB0aGUgbWVzc2FnZSBpbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAqIEB1dGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSwgdG9fKSB7XG4gICAgY29uc3QgbWVzc2FnZUJ5dGVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yYXcgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5yYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQnl0ZXMobWVzc2FnZS5yYXcpO1xuICAgIH0pKCk7XG4gICAgY29uc3QgcHJlZml4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVzKGAke3ByZXNpZ25NZXNzYWdlUHJlZml4fSR7bWVzc2FnZUJ5dGVzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4ga2VjY2FrMjU2KG94X19CeXRlcy5jb25jYXQocHJlZml4Qnl0ZXMsIG1lc3NhZ2VCeXRlcyksIHRvXyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOlsib3hfX0J5dGVzIiwic3RyaW5nVG9CeXRlcyIsInRvQnl0ZXMiLCJrZWNjYWsyNTYiLCJwcmVzaWduTWVzc2FnZVByZWZpeCIsImhhc2hNZXNzYWdlIiwibWVzc2FnZSIsInRvXyIsIm1lc3NhZ2VCeXRlcyIsInJhdyIsIlVpbnQ4QXJyYXkiLCJwcmVmaXhCeXRlcyIsImxlbmd0aCIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashTypedData.js":
/*!***********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/hashing/hashTypedData.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashTypedData: function() { return /* binding */ hashTypedData; }\n/* harmony export */ });\n/* harmony import */ var ox_Bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ox/Bytes */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var ox_TypedData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ox/TypedData */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TypedData.js\");\n/* harmony import */ var _abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../abi/encodeAbiParameters.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var _encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n/* harmony import */ var _keccak256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keccak256.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js\");\n\n\n\n\n\n/**\n * @internal\n */ function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType } = parameters;\n    const types = {\n        EIP712Domain: ox_TypedData__WEBPACK_IMPORTED_MODULE_0__.extractEip712DomainTypes(domain),\n        ...parameters.types\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    ox_TypedData__WEBPACK_IMPORTED_MODULE_0__.validate({\n        domain,\n        message,\n        primaryType,\n        types\n    });\n    const parts = [\n        \"0x1901\"\n    ];\n    if (domain) parts.push(ox_TypedData__WEBPACK_IMPORTED_MODULE_0__.hashDomain({\n        domain,\n        types: types\n    }));\n    if (primaryType !== \"EIP712Domain\") {\n        const hashedStruct = (()=>{\n            const encoded = encodeData({\n                data: message,\n                primaryType,\n                types: types\n            });\n            return (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(encoded);\n        })();\n        parts.push(hashedStruct);\n    }\n    return (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(ox_Bytes__WEBPACK_IMPORTED_MODULE_2__.concat(...parts.map((p)=>ox_Bytes__WEBPACK_IMPORTED_MODULE_2__.fromHex(p))));\n}\nfunction encodeData(param) {\n    let { data, primaryType, types } = param;\n    const encodedTypes = [\n        {\n            type: \"bytes32\"\n        }\n    ];\n    const encodedValues = [\n        hashType({\n            primaryType,\n            types\n        })\n    ];\n    if (!types[primaryType]) throw new Error(\"Invalid types\");\n    for (const field of types[primaryType]){\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name]\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return (0,_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encodeAbiParameters)(encodedTypes, encodedValues);\n}\nfunction hashType(param) {\n    let { primaryType, types } = param;\n    const encodedHashType = (0,_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.toHex)(encodeType({\n        primaryType,\n        types\n    }));\n    return (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(encodedHashType);\n}\nfunction encodeType(param) {\n    let { primaryType, types } = param;\n    let result = \"\";\n    const unsortedDeps = findTypeDependencies({\n        primaryType,\n        types\n    });\n    unsortedDeps.delete(primaryType);\n    const deps = [\n        primaryType,\n        ...Array.from(unsortedDeps).sort()\n    ];\n    for (const type of deps){\n        if (!types[type]) throw new Error(\"Invalid types\");\n        result += \"\".concat(type, \"(\").concat(types[type].map((param)=>{\n            let { name, type: t } = param;\n            return \"\".concat(t, \" \").concat(name);\n        }).join(\",\"), \")\");\n    }\n    return result;\n}\nfunction findTypeDependencies(param) {\n    let { primaryType: primaryType_, types } = param, results = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set();\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match === null || match === void 0 ? void 0 : match[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]){\n        findTypeDependencies({\n            primaryType: field.type,\n            types\n        }, results);\n    }\n    return results;\n}\nfunction encodeField(param) {\n    let { types, name, type, value } = param;\n    if (types[type] !== undefined) {\n        return [\n            {\n                type: \"bytes32\"\n            },\n            (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(encodeData({\n                data: value,\n                primaryType: type,\n                types\n            }))\n        ];\n    }\n    if (type === \"bytes\") {\n        const prepend = value.length % 2 ? \"0\" : \"\";\n        value = \"0x\".concat(prepend + value.slice(2));\n        return [\n            {\n                type: \"bytes32\"\n            },\n            (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(value)\n        ];\n    }\n    if (type === \"string\") return [\n        {\n            type: \"bytes32\"\n        },\n        (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.toHex)(value))\n    ];\n    if (type.lastIndexOf(\"]\") === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n        const typeValuePairs = // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n        value.map((item)=>encodeField({\n                name,\n                type: parsedType,\n                types,\n                value: item\n            }));\n        return [\n            {\n                type: \"bytes32\"\n            },\n            (0,_keccak256_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encodeAbiParameters)(typeValuePairs.map((param)=>{\n                let [t] = param;\n                return t;\n            }), typeValuePairs.map((param)=>{\n                let [, v] = param;\n                return v;\n            })))\n        ];\n    }\n    return [\n        {\n            type\n        },\n        value\n    ];\n} //# sourceMappingURL=hashTypedData.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9oYXNoaW5nL2hhc2hUeXBlZERhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ1E7QUFDc0I7QUFDekI7QUFDQTtBQUMzQzs7Q0FFQyxHQUNNLFNBQVNLLGNBQWNDLFVBQVU7SUFDcEMsTUFBTSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRyxHQUFHSDtJQUMvQyxNQUFNSSxRQUFRO1FBQ1ZDLGNBQWNWLGtFQUFzQyxDQUFDTTtRQUNyRCxHQUFHRCxXQUFXSSxLQUFLO0lBQ3ZCO0lBQ0EsdUZBQXVGO0lBQ3ZGLHFEQUFxRDtJQUNyRFQsa0RBQXNCLENBQUM7UUFDbkJNO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNSSxRQUFRO1FBQUM7S0FBUztJQUN4QixJQUFJUCxRQUNBTyxNQUFNQyxJQUFJLENBQUNkLG9EQUF3QixDQUFDO1FBQ2hDTTtRQUNBRyxPQUFPQTtJQUNYO0lBQ0osSUFBSUQsZ0JBQWdCLGdCQUFnQjtRQUNoQyxNQUFNUSxlQUFlLENBQUM7WUFDbEIsTUFBTUMsVUFBVUMsV0FBVztnQkFDdkJDLE1BQU1aO2dCQUNOQztnQkFDQUMsT0FBT0E7WUFDWDtZQUNBLE9BQU9OLHdEQUFTQSxDQUFDYztRQUNyQjtRQUNBSixNQUFNQyxJQUFJLENBQUNFO0lBQ2Y7SUFDQSxPQUFPYix3REFBU0EsQ0FBQ0osNENBQWdCLElBQUljLE1BQU1RLEdBQUcsQ0FBQyxDQUFDQyxJQUFNdkIsNkNBQWlCLENBQUN1QjtBQUM1RTtBQUNBLFNBQVNKLFdBQVcsS0FBNkI7UUFBN0IsRUFBRUMsSUFBSSxFQUFFWCxXQUFXLEVBQUVDLEtBQUssRUFBRyxHQUE3QjtJQUNoQixNQUFNZSxlQUFlO1FBQUM7WUFBRUMsTUFBTTtRQUFVO0tBQUU7SUFDMUMsTUFBTUMsZ0JBQWdCO1FBQUNDLFNBQVM7WUFBRW5C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O1lBQVU7WUFBR3RCLHdEQUFTQSxDQUFDMkI7U0FBTztJQUNsRDtJQUNBLElBQUlMLFNBQVMsVUFDVCxPQUFPO1FBQUM7WUFBRUEsTUFBTTtRQUFVO1FBQUd0Qix3REFBU0EsQ0FBQ0QsdURBQUtBLENBQUM0QjtLQUFRO0lBQ3pELElBQUlMLEtBQUs4QixXQUFXLENBQUMsU0FBUzlCLEtBQUs0QixNQUFNLEdBQUcsR0FBRztRQUMzQyxNQUFNRyxhQUFhL0IsS0FBSzZCLEtBQUssQ0FBQyxHQUFHN0IsS0FBSzhCLFdBQVcsQ0FBQztRQUNsRCxNQUFNRSxpQkFDTixzRkFBc0Y7UUFDdEYzQixNQUFNVCxHQUFHLENBQUMsQ0FBQ3FDLE9BQVMzQixZQUFZO2dCQUM1QkM7Z0JBQ0FQLE1BQU0rQjtnQkFDTi9DO2dCQUNBcUIsT0FBTzRCO1lBQ1g7UUFDQSxPQUFPO1lBQ0g7Z0JBQUVqQyxNQUFNO1lBQVU7WUFDbEJ0Qix3REFBU0EsQ0FBQ0YsZ0ZBQW1CQSxDQUFDd0QsZUFBZXBDLEdBQUcsQ0FBQztvQkFBQyxDQUFDc0IsRUFBRTt1QkFBS0E7Z0JBQUljLGVBQWVwQyxHQUFHLENBQUM7b0JBQUMsR0FBR3NDLEVBQUU7dUJBQUtBOztTQUMvRjtJQUNMO0lBQ0EsT0FBTztRQUFDO1lBQUVsQztRQUFLO1FBQUdLO0tBQU07QUFDNUIsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL2hhc2hpbmcvaGFzaFR5cGVkRGF0YS5qcz8xMWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG94X19CeXRlcyBmcm9tIFwib3gvQnl0ZXNcIjtcbmltcG9ydCAqIGFzIG94X19UeXBlZERhdGEgZnJvbSBcIm94L1R5cGVkRGF0YVwiO1xuaW1wb3J0IHsgZW5jb2RlQWJpUGFyYW1ldGVycyB9IGZyb20gXCIuLi9hYmkvZW5jb2RlQWJpUGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tIFwiLi4vZW5jb2RpbmcvaGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi9rZWNjYWsyNTYuanNcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVHlwZWREYXRhKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IGRvbWFpbiA9IHt9LCBtZXNzYWdlLCBwcmltYXJ5VHlwZSwgfSA9IHBhcmFtZXRlcnM7XG4gICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgIEVJUDcxMkRvbWFpbjogb3hfX1R5cGVkRGF0YS5leHRyYWN0RWlwNzEyRG9tYWluVHlwZXMoZG9tYWluKSxcbiAgICAgICAgLi4ucGFyYW1ldGVycy50eXBlcyxcbiAgICB9O1xuICAgIC8vIE5lZWQgdG8gZG8gYSBydW50aW1lIHZhbGlkYXRpb24gY2hlY2sgb24gYWRkcmVzc2VzLCBieXRlIHJhbmdlcywgaW50ZWdlciByYW5nZXMsIGV0Y1xuICAgIC8vIGFzIHdlIGNhbid0IHN0YXRpY2FsbHkgY2hlY2sgdGhpcyB3aXRoIFR5cGVTY3JpcHQuXG4gICAgb3hfX1R5cGVkRGF0YS52YWxpZGF0ZSh7XG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgIHR5cGVzLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRzID0gW1wiMHgxOTAxXCJdO1xuICAgIGlmIChkb21haW4pXG4gICAgICAgIHBhcnRzLnB1c2gob3hfX1R5cGVkRGF0YS5oYXNoRG9tYWluKHtcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgICAgfSkpO1xuICAgIGlmIChwcmltYXJ5VHlwZSAhPT0gXCJFSVA3MTJEb21haW5cIikge1xuICAgICAgICBjb25zdCBoYXNoZWRTdHJ1Y3QgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZURhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgICAgICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGVuY29kZWQpO1xuICAgICAgICB9KSgpO1xuICAgICAgICBwYXJ0cy5wdXNoKGhhc2hlZFN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiBrZWNjYWsyNTYob3hfX0J5dGVzLmNvbmNhdCguLi5wYXJ0cy5tYXAoKHApID0+IG94X19CeXRlcy5mcm9tSGV4KHApKSkpO1xufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh7IGRhdGEsIHByaW1hcnlUeXBlLCB0eXBlcywgfSkge1xuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFt7IHR5cGU6IFwiYnl0ZXMzMlwiIH1dO1xuICAgIGNvbnN0IGVuY29kZWRWYWx1ZXMgPSBbaGFzaFR5cGUoeyBwcmltYXJ5VHlwZSwgdHlwZXMgfSldO1xuICAgIGlmICghdHlwZXNbcHJpbWFyeVR5cGVdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGVzXCIpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSBlbmNvZGVGaWVsZCh7XG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBmaWVsZC50eXBlLFxuICAgICAgICAgICAgdmFsdWU6IGRhdGFbZmllbGQubmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZUFiaVBhcmFtZXRlcnMoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGhhc2hUeXBlKHsgcHJpbWFyeVR5cGUsIHR5cGVzLCB9KSB7XG4gICAgY29uc3QgZW5jb2RlZEhhc2hUeXBlID0gdG9IZXgoZW5jb2RlVHlwZSh7IHByaW1hcnlUeXBlLCB0eXBlcyB9KSk7XG4gICAgcmV0dXJuIGtlY2NhazI1NihlbmNvZGVkSGFzaFR5cGUpO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZSh7IHByaW1hcnlUeXBlLCB0eXBlcywgfSkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IHVuc29ydGVkRGVwcyA9IGZpbmRUeXBlRGVwZW5kZW5jaWVzKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pO1xuICAgIHVuc29ydGVkRGVwcy5kZWxldGUocHJpbWFyeVR5cGUpO1xuICAgIGNvbnN0IGRlcHMgPSBbcHJpbWFyeVR5cGUsIC4uLkFycmF5LmZyb20odW5zb3J0ZWREZXBzKS5zb3J0KCldO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBkZXBzKSB7XG4gICAgICAgIGlmICghdHlwZXNbdHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGVzXCIpO1xuICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMoeyBwcmltYXJ5VHlwZTogcHJpbWFyeVR5cGVfLCB0eXBlcywgfSwgcmVzdWx0cyA9IG5ldyBTZXQoKSkge1xuICAgIGNvbnN0IG1hdGNoID0gcHJpbWFyeVR5cGVfLm1hdGNoKC9eXFx3Ki91KTtcbiAgICBjb25zdCBwcmltYXJ5VHlwZSA9IG1hdGNoPy5bMF07XG4gICAgaWYgKHJlc3VsdHMuaGFzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKHsgcHJpbWFyeVR5cGU6IGZpZWxkLnR5cGUsIHR5cGVzIH0sIHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHsgdHlwZXMsIG5hbWUsIHR5cGUsIHZhbHVlLCB9KSB7XG4gICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgICAgICAgIGtlY2NhazI1NihlbmNvZGVEYXRhKHsgZGF0YTogdmFsdWUsIHByaW1hcnlUeXBlOiB0eXBlLCB0eXBlcyB9KSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgY29uc3QgcHJlcGVuZCA9IHZhbHVlLmxlbmd0aCAlIDIgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgIHZhbHVlID0gYDB4JHtwcmVwZW5kICsgdmFsdWUuc2xpY2UoMil9YDtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwiYnl0ZXMzMlwiIH0sIGtlY2NhazI1Nih2YWx1ZSldO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwiYnl0ZXMzMlwiIH0sIGtlY2NhazI1Nih0b0hleCh2YWx1ZSkpXTtcbiAgICBpZiAodHlwZS5sYXN0SW5kZXhPZihcIl1cIikgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKFwiW1wiKSk7XG4gICAgICAgIGNvbnN0IHR5cGVWYWx1ZVBhaXJzID0gXG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogQ2FuJ3QgYW50aWNpcGF0ZSB0eXBlcyBvZiBuZXN0ZWQgdmFsdWVzXG4gICAgICAgIHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICAgICAgICBrZWNjYWsyNTYoZW5jb2RlQWJpUGFyYW1ldGVycyh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbeyB0eXBlIH0sIHZhbHVlXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hUeXBlZERhdGEuanMubWFwIl0sIm5hbWVzIjpbIm94X19CeXRlcyIsIm94X19UeXBlZERhdGEiLCJlbmNvZGVBYmlQYXJhbWV0ZXJzIiwidG9IZXgiLCJrZWNjYWsyNTYiLCJoYXNoVHlwZWREYXRhIiwicGFyYW1ldGVycyIsImRvbWFpbiIsIm1lc3NhZ2UiLCJwcmltYXJ5VHlwZSIsInR5cGVzIiwiRUlQNzEyRG9tYWluIiwiZXh0cmFjdEVpcDcxMkRvbWFpblR5cGVzIiwidmFsaWRhdGUiLCJwYXJ0cyIsInB1c2giLCJoYXNoRG9tYWluIiwiaGFzaGVkU3RydWN0IiwiZW5jb2RlZCIsImVuY29kZURhdGEiLCJkYXRhIiwiY29uY2F0IiwibWFwIiwicCIsImZyb21IZXgiLCJlbmNvZGVkVHlwZXMiLCJ0eXBlIiwiZW5jb2RlZFZhbHVlcyIsImhhc2hUeXBlIiwiRXJyb3IiLCJmaWVsZCIsInZhbHVlIiwiZW5jb2RlRmllbGQiLCJuYW1lIiwiZW5jb2RlZEhhc2hUeXBlIiwiZW5jb2RlVHlwZSIsInJlc3VsdCIsInVuc29ydGVkRGVwcyIsImZpbmRUeXBlRGVwZW5kZW5jaWVzIiwiZGVsZXRlIiwiZGVwcyIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJ0Iiwiam9pbiIsInByaW1hcnlUeXBlXyIsInJlc3VsdHMiLCJTZXQiLCJtYXRjaCIsImhhcyIsInVuZGVmaW5lZCIsImFkZCIsInByZXBlbmQiLCJsZW5ndGgiLCJzbGljZSIsImxhc3RJbmRleE9mIiwicGFyc2VkVHlwZSIsInR5cGVWYWx1ZVBhaXJzIiwiaXRlbSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashTypedData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/smart/lib/signing.js":
/*!*********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/wallets/smart/lib/signing.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   confirmContractDeployment: function() { return /* binding */ confirmContractDeployment; },\n/* harmony export */   deploySmartAccount: function() { return /* binding */ deploySmartAccount; },\n/* harmony export */   smartAccountSignMessage: function() { return /* binding */ smartAccountSignMessage; },\n/* harmony export */   smartAccountSignTypedData: function() { return /* binding */ smartAccountSignTypedData; }\n/* harmony export */ });\n/* harmony import */ var _auth_serialize_erc6492_signature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../auth/serialize-erc6492-signature.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js\");\n/* harmony import */ var _auth_verify_hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../auth/verify-hash.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/auth/verify-hash.js\");\n/* harmony import */ var _contract_contract_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../contract/contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/contract/contract.js\");\n/* harmony import */ var _transaction_actions_encode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../transaction/actions/encode.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/actions/encode.js\");\n/* harmony import */ var _transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../transaction/read-contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/read-contract.js\");\n/* harmony import */ var _utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/abi/encodeAbiParameters.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var _utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/bytecode/is-contract-deployed.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/is-contract-deployed.js\");\n/* harmony import */ var _utils_hashing_hashMessage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/hashing/hashMessage.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js\");\n/* harmony import */ var _utils_hashing_hashTypedData_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/hashing/hashTypedData.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/hashing/hashTypedData.js\");\n/* harmony import */ var _calls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calls.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/smart/lib/calls.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */ async function smartAccountSignMessage(param) {\n    let { accountContract, factoryContract, options, message } = param;\n    const originalMsgHash = (0,_utils_hashing_hashMessage_js__WEBPACK_IMPORTED_MODULE_0__.hashMessage)(message);\n    const is712Factory = await checkFor712Factory({\n        factoryContract,\n        accountContract,\n        originalMsgHash\n    });\n    let sig;\n    if (is712Factory) {\n        const wrappedMessageHash = (0,_utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encodeAbiParameters)([\n            {\n                type: \"bytes32\"\n            }\n        ], [\n            originalMsgHash\n        ]);\n        sig = await options.personalAccount.signTypedData({\n            domain: {\n                name: \"Account\",\n                version: \"1\",\n                chainId: options.chain.id,\n                verifyingContract: accountContract.address\n            },\n            primaryType: \"AccountMessage\",\n            types: {\n                AccountMessage: [\n                    {\n                        name: \"message\",\n                        type: \"bytes\"\n                    }\n                ]\n            },\n            message: {\n                message: wrappedMessageHash\n            }\n        });\n    } else {\n        sig = await options.personalAccount.signMessage({\n            message\n        });\n    }\n    const isDeployed = await (0,_utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_2__.isContractDeployed)(accountContract);\n    if (isDeployed) {\n        const isValid = await (0,_auth_verify_hash_js__WEBPACK_IMPORTED_MODULE_3__.verifyEip1271Signature)({\n            hash: originalMsgHash,\n            signature: sig,\n            contract: accountContract\n        });\n        if (isValid) {\n            return sig;\n        }\n        throw new Error(\"Failed to verify signature\");\n    } else {\n        var _options_overrides, _options_overrides1;\n        const deployTx = (0,_calls_js__WEBPACK_IMPORTED_MODULE_4__.prepareCreateAccount)({\n            factoryContract,\n            adminAddress: options.personalAccount.address,\n            accountSalt: (_options_overrides = options.overrides) === null || _options_overrides === void 0 ? void 0 : _options_overrides.accountSalt,\n            createAccountOverride: (_options_overrides1 = options.overrides) === null || _options_overrides1 === void 0 ? void 0 : _options_overrides1.createAccount\n        });\n        if (!deployTx) {\n            throw new Error(\"Create account override not provided\");\n        }\n        const initCode = await (0,_transaction_actions_encode_js__WEBPACK_IMPORTED_MODULE_5__.encode)(deployTx);\n        const erc6492Sig = (0,_auth_serialize_erc6492_signature_js__WEBPACK_IMPORTED_MODULE_6__.serializeErc6492Signature)({\n            address: factoryContract.address,\n            data: initCode,\n            signature: sig\n        });\n        // check if the signature is valid\n        const isValid = await (0,_auth_verify_hash_js__WEBPACK_IMPORTED_MODULE_3__.verifyHash)({\n            hash: originalMsgHash,\n            signature: erc6492Sig,\n            address: accountContract.address,\n            chain: accountContract.chain,\n            client: accountContract.client\n        });\n        if (isValid) {\n            return erc6492Sig;\n        }\n        throw new Error(\"Unable to verify ERC-6492 signature after signing.\");\n    }\n}\nasync function smartAccountSignTypedData(param) {\n    let { accountContract, factoryContract, options, typedData } = param;\n    var _typedData_domain_verifyingContract, _typedData_domain, _accountContract_address;\n    const isSelfVerifyingContract = ((_typedData_domain = typedData.domain) === null || _typedData_domain === void 0 ? void 0 : (_typedData_domain_verifyingContract = _typedData_domain.verifyingContract) === null || _typedData_domain_verifyingContract === void 0 ? void 0 : _typedData_domain_verifyingContract.toLowerCase()) === ((_accountContract_address = accountContract.address) === null || _accountContract_address === void 0 ? void 0 : _accountContract_address.toLowerCase());\n    if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n    }\n    const originalMsgHash = (0,_utils_hashing_hashTypedData_js__WEBPACK_IMPORTED_MODULE_7__.hashTypedData)(typedData);\n    // check if the account contract supports EIP721 domain separator based signing\n    const is712Factory = await checkFor712Factory({\n        factoryContract,\n        accountContract,\n        originalMsgHash\n    });\n    let sig;\n    if (is712Factory) {\n        const wrappedMessageHash = (0,_utils_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encodeAbiParameters)([\n            {\n                type: \"bytes32\"\n            }\n        ], [\n            originalMsgHash\n        ]);\n        sig = await options.personalAccount.signTypedData({\n            domain: {\n                name: \"Account\",\n                version: \"1\",\n                chainId: options.chain.id,\n                verifyingContract: accountContract.address\n            },\n            primaryType: \"AccountMessage\",\n            types: {\n                AccountMessage: [\n                    {\n                        name: \"message\",\n                        type: \"bytes\"\n                    }\n                ]\n            },\n            message: {\n                message: wrappedMessageHash\n            }\n        });\n    } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n    }\n    const isDeployed = await (0,_utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_2__.isContractDeployed)(accountContract);\n    if (isDeployed) {\n        const isValid = await (0,_auth_verify_hash_js__WEBPACK_IMPORTED_MODULE_3__.verifyEip1271Signature)({\n            hash: originalMsgHash,\n            signature: sig,\n            contract: accountContract\n        });\n        if (isValid) {\n            return sig;\n        }\n        throw new Error(\"Failed to verify signature\");\n    } else {\n        var _options_overrides, _options_overrides1;\n        const deployTx = (0,_calls_js__WEBPACK_IMPORTED_MODULE_4__.prepareCreateAccount)({\n            factoryContract,\n            adminAddress: options.personalAccount.address,\n            accountSalt: (_options_overrides = options.overrides) === null || _options_overrides === void 0 ? void 0 : _options_overrides.accountSalt,\n            createAccountOverride: (_options_overrides1 = options.overrides) === null || _options_overrides1 === void 0 ? void 0 : _options_overrides1.createAccount\n        });\n        if (!deployTx) {\n            throw new Error(\"Create account override not provided\");\n        }\n        const initCode = await (0,_transaction_actions_encode_js__WEBPACK_IMPORTED_MODULE_5__.encode)(deployTx);\n        const erc6492Sig = (0,_auth_serialize_erc6492_signature_js__WEBPACK_IMPORTED_MODULE_6__.serializeErc6492Signature)({\n            address: factoryContract.address,\n            data: initCode,\n            signature: sig\n        });\n        // check if the signature is valid\n        const isValid = await (0,_auth_verify_hash_js__WEBPACK_IMPORTED_MODULE_3__.verifyHash)({\n            hash: originalMsgHash,\n            signature: erc6492Sig,\n            address: accountContract.address,\n            chain: accountContract.chain,\n            client: accountContract.client\n        });\n        if (isValid) {\n            return erc6492Sig;\n        }\n        throw new Error(\"Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.\");\n    }\n}\nasync function confirmContractDeployment(args) {\n    const { accountContract } = args;\n    const startTime = Date.now();\n    const timeout = 60000; // wait 1 minute max\n    const { isContractDeployed } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../utils/bytecode/is-contract-deployed.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/is-contract-deployed.js\"));\n    let isDeployed = await isContractDeployed(accountContract);\n    while(!isDeployed){\n        if (Date.now() - startTime > timeout) {\n            throw new Error(\"Timeout: Smart account deployment not confirmed after 1 minute\");\n        }\n        await new Promise((resolve)=>setTimeout(resolve, 500));\n        isDeployed = await isContractDeployed(accountContract);\n    }\n}\nasync function checkFor712Factory(param) {\n    let { factoryContract, accountContract, originalMsgHash } = param;\n    try {\n        const implementationAccount = await (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_8__.readContract)({\n            contract: factoryContract,\n            method: \"function accountImplementation() public view returns (address)\"\n        });\n        // check if the account contract supports EIP721 domain separator or modular based signing\n        const is712Factory = await (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_8__.readContract)({\n            contract: (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_9__.getContract)({\n                address: implementationAccount,\n                chain: accountContract.chain,\n                client: accountContract.client\n            }),\n            method: \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n            params: [\n                originalMsgHash\n            ]\n        }).then((res)=>res !== \"0x\").catch(()=>false);\n        return is712Factory;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */ async function deploySmartAccount(args) {\n    const { chain, client, smartAccount, accountContract } = args;\n    const isDeployed = await (0,_utils_bytecode_is_contract_deployed_js__WEBPACK_IMPORTED_MODULE_2__.isContractDeployed)(accountContract);\n    if (isDeployed) {\n        return;\n    }\n    const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../transaction/actions/send-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/actions/send-transaction.js\")),\n        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../transaction/prepare-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/prepare-transaction.js\"))\n    ]);\n    const dummyTx = prepareTransaction({\n        client: client,\n        chain: chain,\n        to: accountContract.address,\n        value: 0n,\n        gas: 50000n\n    });\n    const deployResult = await sendTransaction({\n        transaction: dummyTx,\n        account: smartAccount\n    });\n    await confirmContractDeployment({\n        accountContract\n    });\n    return deployResult;\n} //# sourceMappingURL=signing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL3NtYXJ0L2xpYi9zaWduaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlGO0FBQ047QUFDdEI7QUFDRztBQUNLO0FBQ1c7QUFDSztBQUNqQjtBQUNJO0FBQ3RCO0FBQ2xEOzs7OztDQUtDLEdBQ00sZUFBZVcsd0JBQXdCLEtBQXVEO1FBQXZELEVBQUVDLGVBQWUsRUFBRUMsZUFBZSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRyxHQUF2RDtJQUMxQyxNQUFNQyxrQkFBa0JSLDBFQUFXQSxDQUFDTztJQUNwQyxNQUFNRSxlQUFlLE1BQU1DLG1CQUFtQjtRQUMxQ0w7UUFDQUQ7UUFDQUk7SUFDSjtJQUNBLElBQUlHO0lBQ0osSUFBSUYsY0FBYztRQUNkLE1BQU1HLHFCQUFxQmQsc0ZBQW1CQSxDQUFDO1lBQUM7Z0JBQUVlLE1BQU07WUFBVTtTQUFFLEVBQUU7WUFBQ0w7U0FBZ0I7UUFDdkZHLE1BQU0sTUFBTUwsUUFBUVEsZUFBZSxDQUFDQyxhQUFhLENBQUM7WUFDOUNDLFFBQVE7Z0JBQ0pDLE1BQU07Z0JBQ05DLFNBQVM7Z0JBQ1RDLFNBQVNiLFFBQVFjLEtBQUssQ0FBQ0MsRUFBRTtnQkFDekJDLG1CQUFtQmxCLGdCQUFnQm1CLE9BQU87WUFDOUM7WUFDQUMsYUFBYTtZQUNiQyxPQUFPO2dCQUFFQyxnQkFBZ0I7b0JBQUM7d0JBQUVULE1BQU07d0JBQVdKLE1BQU07b0JBQVE7aUJBQUU7WUFBQztZQUM5RE4sU0FBUztnQkFBRUEsU0FBU0s7WUFBbUI7UUFDM0M7SUFDSixPQUNLO1FBQ0RELE1BQU0sTUFBTUwsUUFBUVEsZUFBZSxDQUFDYSxXQUFXLENBQUM7WUFBRXBCO1FBQVE7SUFDOUQ7SUFDQSxNQUFNcUIsYUFBYSxNQUFNN0IsMkZBQWtCQSxDQUFDSztJQUM1QyxJQUFJd0IsWUFBWTtRQUNaLE1BQU1DLFVBQVUsTUFBTXBD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LENBQUMsR0FBRyxNQUFNWixRQUFRYSxHQUFHLENBQUM7UUFDcEUsNE9BQTBEO1FBQzFELGtPQUFxRDtLQUN4RDtJQUNELE1BQU1DLFVBQVVGLG1CQUFtQjtRQUMvQnZCLFFBQVFBO1FBQ1J2QixPQUFPQTtRQUNQaUQsSUFBSWpFLGdCQUFnQm1CLE9BQU87UUFDM0IrQyxPQUFPLEVBQUU7UUFDVEMsS0FBSyxNQUFNO0lBQ2Y7SUFDQSxNQUFNQyxlQUFlLE1BQU1QLGdCQUFnQjtRQUN2Q1EsYUFBYUw7UUFDYk0sU0FBU1Y7SUFDYjtJQUNBLE1BQU1oQiwwQkFBMEI7UUFDNUI1QztJQUNKO0lBQ0EsT0FBT29FO0FBQ1gsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3dhbGxldHMvc21hcnQvbGliL3NpZ25pbmcuanM/MzkzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXJpYWxpemVFcmM2NDkyU2lnbmF0dXJlIH0gZnJvbSBcIi4uLy4uLy4uL2F1dGgvc2VyaWFsaXplLWVyYzY0OTItc2lnbmF0dXJlLmpzXCI7XG5pbXBvcnQgeyB2ZXJpZnlFaXAxMjcxU2lnbmF0dXJlLCB2ZXJpZnlIYXNoLCB9IGZyb20gXCIuLi8uLi8uLi9hdXRoL3ZlcmlmeS1oYXNoLmpzXCI7XG5pbXBvcnQgeyBnZXRDb250cmFjdCwgfSBmcm9tIFwiLi4vLi4vLi4vY29udHJhY3QvY29udHJhY3QuanNcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCIuLi8uLi8uLi90cmFuc2FjdGlvbi9hY3Rpb25zL2VuY29kZS5qc1wiO1xuaW1wb3J0IHsgcmVhZENvbnRyYWN0IH0gZnJvbSBcIi4uLy4uLy4uL3RyYW5zYWN0aW9uL3JlYWQtY29udHJhY3QuanNcIjtcbmltcG9ydCB7IGVuY29kZUFiaVBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvYWJpL2VuY29kZUFiaVBhcmFtZXRlcnMuanNcIjtcbmltcG9ydCB7IGlzQ29udHJhY3REZXBsb3llZCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9ieXRlY29kZS9pcy1jb250cmFjdC1kZXBsb3llZC5qc1wiO1xuaW1wb3J0IHsgaGFzaE1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvaGFzaGluZy9oYXNoTWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgaGFzaFR5cGVkRGF0YSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9oYXNoaW5nL2hhc2hUeXBlZERhdGEuanNcIjtcbmltcG9ydCB7IHByZXBhcmVDcmVhdGVBY2NvdW50IH0gZnJvbSBcIi4vY2FsbHMuanNcIjtcbi8qKlxuICogSWYgdGhlIGFjY291bnQgaXMgYWxyZWFkeSBkZXBsb3llZCwgZ2VuZXJhdGUgYW4gRVJDLTEyNzEgc2lnbmF0dXJlLlxuICogSWYgdGhlIGFjY291bnQgaXMgbm90IGRlcGxveWVkLCBnZW5lcmF0ZSBhbiBFUkMtNjQ5MiBzaWduYXR1cmUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbWFydEFjY291bnRTaWduTWVzc2FnZSh7IGFjY291bnRDb250cmFjdCwgZmFjdG9yeUNvbnRyYWN0LCBvcHRpb25zLCBtZXNzYWdlLCB9KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNc2dIYXNoID0gaGFzaE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgY29uc3QgaXM3MTJGYWN0b3J5ID0gYXdhaXQgY2hlY2tGb3I3MTJGYWN0b3J5KHtcbiAgICAgICAgZmFjdG9yeUNvbnRyYWN0LFxuICAgICAgICBhY2NvdW50Q29udHJhY3QsXG4gICAgICAgIG9yaWdpbmFsTXNnSGFzaCxcbiAgICB9KTtcbiAgICBsZXQgc2lnO1xuICAgIGlmIChpczcxMkZhY3RvcnkpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZE1lc3NhZ2VIYXNoID0gZW5jb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiBcImJ5dGVzMzJcIiB9XSwgW29yaWdpbmFsTXNnSGFzaF0pO1xuICAgICAgICBzaWcgPSBhd2FpdCBvcHRpb25zLnBlcnNvbmFsQWNjb3VudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQWNjb3VudFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IG9wdGlvbnMuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGFjY291bnRDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBcIkFjY291bnRNZXNzYWdlXCIsXG4gICAgICAgICAgICB0eXBlczogeyBBY2NvdW50TWVzc2FnZTogW3sgbmFtZTogXCJtZXNzYWdlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogeyBtZXNzYWdlOiB3cmFwcGVkTWVzc2FnZUhhc2ggfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaWcgPSBhd2FpdCBvcHRpb25zLnBlcnNvbmFsQWNjb3VudC5zaWduTWVzc2FnZSh7IG1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzRGVwbG95ZWQgPSBhd2FpdCBpc0NvbnRyYWN0RGVwbG95ZWQoYWNjb3VudENvbnRyYWN0KTtcbiAgICBpZiAoaXNEZXBsb3llZCkge1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5RWlwMTI3MVNpZ25hdHVyZSh7XG4gICAgICAgICAgICBoYXNoOiBvcmlnaW5hbE1zZ0hhc2gsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZyxcbiAgICAgICAgICAgIGNvbnRyYWN0OiBhY2NvdW50Q29udHJhY3QsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdmVyaWZ5IHNpZ25hdHVyZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlcGxveVR4ID0gcHJlcGFyZUNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgICAgZmFjdG9yeUNvbnRyYWN0LFxuICAgICAgICAgICAgYWRtaW5BZGRyZXNzOiBvcHRpb25zLnBlcnNvbmFsQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICAgICAgYWNjb3VudFNhbHQ6IG9wdGlvbnMub3ZlcnJpZGVzPy5hY2NvdW50U2FsdCxcbiAgICAgICAgICAgIGNyZWF0ZUFjY291bnRPdmVycmlkZTogb3B0aW9ucy5vdmVycmlkZXM/LmNyZWF0ZUFjY291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWRlcGxveVR4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGUgYWNjb3VudCBvdmVycmlkZSBub3QgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdENvZGUgPSBhd2FpdCBlbmNvZGUoZGVwbG95VHgpO1xuICAgICAgICBjb25zdCBlcmM2NDkyU2lnID0gc2VyaWFsaXplRXJjNjQ5MlNpZ25hdHVyZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiBmYWN0b3J5Q29udHJhY3QuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGluaXRDb2RlLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWcsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB2ZXJpZnlIYXNoKHtcbiAgICAgICAgICAgIGhhc2g6IG9yaWdpbmFsTXNnSGFzaCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZXJjNjQ5MlNpZyxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFjY291bnRDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW46IGFjY291bnRDb250cmFjdC5jaGFpbixcbiAgICAgICAgICAgIGNsaWVudDogYWNjb3VudENvbnRyYWN0LmNsaWVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJjNjQ5MlNpZztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gdmVyaWZ5IEVSQy02NDkyIHNpZ25hdHVyZSBhZnRlciBzaWduaW5nLlwiKTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc21hcnRBY2NvdW50U2lnblR5cGVkRGF0YSh7IGFjY291bnRDb250cmFjdCwgZmFjdG9yeUNvbnRyYWN0LCBvcHRpb25zLCB0eXBlZERhdGEsIH0pIHtcbiAgICBjb25zdCBpc1NlbGZWZXJpZnlpbmdDb250cmFjdCA9IHR5cGVkRGF0YS5kb21haW4/LnZlcmlmeWluZ0NvbnRyYWN0Py50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICBhY2NvdW50Q29udHJhY3QuYWRkcmVzcz8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNTZWxmVmVyaWZ5aW5nQ29udHJhY3QpIHtcbiAgICAgICAgLy8gaWYgdGhlIGNvbnRyYWN0IGlzIHNlbGYtdmVyaWZ5aW5nLCB3ZSBjYW4ganVzdCBzaWduIHRoZSBtZXNzYWdlIHdpdGggdGhlIEVPQSAoaWUuIGFkZGluZyBhIHNlc3Npb24ga2V5KVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5wZXJzb25hbEFjY291bnQuc2lnblR5cGVkRGF0YSh0eXBlZERhdGEpO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbE1zZ0hhc2ggPSBoYXNoVHlwZWREYXRhKHR5cGVkRGF0YSk7XG4gICAgLy8gY2hlY2sgaWYgdGhlIGFjY291bnQgY29udHJhY3Qgc3VwcG9ydHMgRUlQNzIxIGRvbWFpbiBzZXBhcmF0b3IgYmFzZWQgc2lnbmluZ1xuICAgIGNvbnN0IGlzNzEyRmFjdG9yeSA9IGF3YWl0IGNoZWNrRm9yNzEyRmFjdG9yeSh7XG4gICAgICAgIGZhY3RvcnlDb250cmFjdCxcbiAgICAgICAgYWNjb3VudENvbnRyYWN0LFxuICAgICAgICBvcmlnaW5hbE1zZ0hhc2gsXG4gICAgfSk7XG4gICAgbGV0IHNpZztcbiAgICBpZiAoaXM3MTJGYWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRNZXNzYWdlSGFzaCA9IGVuY29kZUFiaVBhcmFtZXRlcnMoW3sgdHlwZTogXCJieXRlczMyXCIgfV0sIFtvcmlnaW5hbE1zZ0hhc2hdKTtcbiAgICAgICAgc2lnID0gYXdhaXQgb3B0aW9ucy5wZXJzb25hbEFjY291bnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkFjY291bnRcIixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjFcIixcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBvcHRpb25zLmNoYWluLmlkLFxuICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBhY2NvdW50Q29udHJhY3QuYWRkcmVzcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogXCJBY2NvdW50TWVzc2FnZVwiLFxuICAgICAgICAgICAgdHlwZXM6IHsgQWNjb3VudE1lc3NhZ2U6IFt7IG5hbWU6IFwibWVzc2FnZVwiLCB0eXBlOiBcImJ5dGVzXCIgfV0gfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHsgbWVzc2FnZTogd3JhcHBlZE1lc3NhZ2VIYXNoIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2lnID0gYXdhaXQgb3B0aW9ucy5wZXJzb25hbEFjY291bnQuc2lnblR5cGVkRGF0YSh0eXBlZERhdGEpO1xuICAgIH1cbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgaXNDb250cmFjdERlcGxveWVkKGFjY291bnRDb250cmFjdCk7XG4gICAgaWYgKGlzRGVwbG95ZWQpIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHZlcmlmeUVpcDEyNzFTaWduYXR1cmUoe1xuICAgICAgICAgICAgaGFzaDogb3JpZ2luYWxNc2dIYXNoLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWcsXG4gICAgICAgICAgICBjb250cmFjdDogYWNjb3VudENvbnRyYWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHZlcmlmeSBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHByZXBhcmVDcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICAgIGZhY3RvcnlDb250cmFjdCxcbiAgICAgICAgICAgIGFkbWluQWRkcmVzczogb3B0aW9ucy5wZXJzb25hbEFjY291bnQuYWRkcmVzcyxcbiAgICAgICAgICAgIGFjY291bnRTYWx0OiBvcHRpb25zLm92ZXJyaWRlcz8uYWNjb3VudFNhbHQsXG4gICAgICAgICAgICBjcmVhdGVBY2NvdW50T3ZlcnJpZGU6IG9wdGlvbnMub3ZlcnJpZGVzPy5jcmVhdGVBY2NvdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkZXBsb3lUeCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRlIGFjY291bnQgb3ZlcnJpZGUgbm90IHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRDb2RlID0gYXdhaXQgZW5jb2RlKGRlcGxveVR4KTtcbiAgICAgICAgY29uc3QgZXJjNjQ5MlNpZyA9IHNlcmlhbGl6ZUVyYzY0OTJTaWduYXR1cmUoe1xuICAgICAgICAgICAgYWRkcmVzczogZmFjdG9yeUNvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBpbml0Q29kZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZFxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5SGFzaCh7XG4gICAgICAgICAgICBoYXNoOiBvcmlnaW5hbE1zZ0hhc2gsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGVyYzY0OTJTaWcsXG4gICAgICAgICAgICBhZGRyZXNzOiBhY2NvdW50Q29udHJhY3QuYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluOiBhY2NvdW50Q29udHJhY3QuY2hhaW4sXG4gICAgICAgICAgICBjbGllbnQ6IGFjY291bnRDb250cmFjdC5jbGllbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVyYzY0OTJTaWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHZlcmlmeSBzaWduYXR1cmUgb24gc21hcnQgYWNjb3VudCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgYWRtaW4gd2FsbGV0IGhhcyBwZXJtaXNzaW9ucyBhbmQgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cIik7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmZpcm1Db250cmFjdERlcGxveW1lbnQoYXJncykge1xuICAgIGNvbnN0IHsgYWNjb3VudENvbnRyYWN0IH0gPSBhcmdzO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgdGltZW91dCA9IDYwMDAwOyAvLyB3YWl0IDEgbWludXRlIG1heFxuICAgIGNvbnN0IHsgaXNDb250cmFjdERlcGxveWVkIH0gPSBhd2FpdCBpbXBvcnQoXCIuLi8uLi8uLi91dGlscy9ieXRlY29kZS9pcy1jb250cmFjdC1kZXBsb3llZC5qc1wiKTtcbiAgICBsZXQgaXNEZXBsb3llZCA9IGF3YWl0IGlzQ29udHJhY3REZXBsb3llZChhY2NvdW50Q29udHJhY3QpO1xuICAgIHdoaWxlICghaXNEZXBsb3llZCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQ6IFNtYXJ0IGFjY291bnQgZGVwbG95bWVudCBub3QgY29uZmlybWVkIGFmdGVyIDEgbWludXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICBpc0RlcGxveWVkID0gYXdhaXQgaXNDb250cmFjdERlcGxveWVkKGFjY291bnRDb250cmFjdCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2hlY2tGb3I3MTJGYWN0b3J5KHsgZmFjdG9yeUNvbnRyYWN0LCBhY2NvdW50Q29udHJhY3QsIG9yaWdpbmFsTXNnSGFzaCwgfSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9uQWNjb3VudCA9IGF3YWl0IHJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBjb250cmFjdDogZmFjdG9yeUNvbnRyYWN0LFxuICAgICAgICAgICAgbWV0aG9kOiBcImZ1bmN0aW9uIGFjY291bnRJbXBsZW1lbnRhdGlvbigpIHB1YmxpYyB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYWNjb3VudCBjb250cmFjdCBzdXBwb3J0cyBFSVA3MjEgZG9tYWluIHNlcGFyYXRvciBvciBtb2R1bGFyIGJhc2VkIHNpZ25pbmdcbiAgICAgICAgY29uc3QgaXM3MTJGYWN0b3J5ID0gYXdhaXQgcmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgIGNvbnRyYWN0OiBnZXRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogaW1wbGVtZW50YXRpb25BY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluOiBhY2NvdW50Q29udHJhY3QuY2hhaW4sXG4gICAgICAgICAgICAgICAgY2xpZW50OiBhY2NvdW50Q29udHJhY3QuY2xpZW50LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtZXRob2Q6IFwiZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2goYnl0ZXMzMiBfaGFzaCkgcHVibGljIHZpZXcgcmV0dXJucyAoYnl0ZXMzMilcIixcbiAgICAgICAgICAgIHBhcmFtczogW29yaWdpbmFsTXNnSGFzaF0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMgIT09IFwiMHhcIilcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIHJldHVybiBpczcxMkZhY3Rvcnk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGVwbG95ZXMgYSBzbWFydCBhY2NvdW50IHZpYSBhIGR1bW15IHRyYW5zYWN0aW9uLiBJZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGRlcGxveWVkLCB0aGlzIHdpbGwgZG8gbm90aGluZy5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyBmb3IgdGhlIGRlcGxveW1lbnQuXG4gKiBAcGFyYW0gYXJncy5zbWFydEFjY291bnQgLSBUaGUgc21hcnQgYWNjb3VudCB0byBkZXBsb3kuXG4gKiBAcGFyYW0gYXJncy5jaGFpbiAtIFRoZSBjaGFpbiB0byBkZXBsb3kgb24uXG4gKiBAcGFyYW0gYXJncy5jbGllbnQgLSBUaGUgY2xpZW50IHRvIHVzZSBmb3IgdGhlIGRlcGxveW1lbnQuXG4gKiBAcGFyYW0gYXJncy5hY2NvdW50Q29udHJhY3QgLSBUaGUgYWNjb3VudCBjb250cmFjdCB0byBkZXBsb3kuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBkZXBsb3lTbWFydEFjY291bnQgfSBmcm9tIFwidGhpcmR3ZWJcIjtcbiAqXG4gKiBjb25zdCBhY2NvdW50ID0gYXdhaXQgZGVwbG95U21hcnRBY2NvdW50KHtcbiAqICAgc21hcnRBY2NvdW50LFxuICogICBjaGFpbixcbiAqICAgY2xpZW50LFxuICogICBhY2NvdW50Q29udHJhY3QsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEB3YWxsZXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcGxveVNtYXJ0QWNjb3VudChhcmdzKSB7XG4gICAgY29uc3QgeyBjaGFpbiwgY2xpZW50LCBzbWFydEFjY291bnQsIGFjY291bnRDb250cmFjdCB9ID0gYXJncztcbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgaXNDb250cmFjdERlcGxveWVkKGFjY291bnRDb250cmFjdCk7XG4gICAgaWYgKGlzRGVwbG95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbeyBzZW5kVHJhbnNhY3Rpb24gfSwgeyBwcmVwYXJlVHJhbnNhY3Rpb24gfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGltcG9ydChcIi4uLy4uLy4uL3RyYW5zYWN0aW9uL2FjdGlvbnMvc2VuZC10cmFuc2FjdGlvbi5qc1wiKSxcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vLi4vdHJhbnNhY3Rpb24vcHJlcGFyZS10cmFuc2FjdGlvbi5qc1wiKSxcbiAgICBdKTtcbiAgICBjb25zdCBkdW1teVR4ID0gcHJlcGFyZVRyYW5zYWN0aW9uKHtcbiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgdG86IGFjY291bnRDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgIGdhczogNTAwMDBuLCAvLyBmb3JjZSBnYXMgdG8gYXZvaWQgc2ltdWxhdGlvbiBlcnJvclxuICAgIH0pO1xuICAgIGNvbnN0IGRlcGxveVJlc3VsdCA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBkdW1teVR4LFxuICAgICAgICBhY2NvdW50OiBzbWFydEFjY291bnQsXG4gICAgfSk7XG4gICAgYXdhaXQgY29uZmlybUNvbnRyYWN0RGVwbG95bWVudCh7XG4gICAgICAgIGFjY291bnRDb250cmFjdCxcbiAgICB9KTtcbiAgICByZXR1cm4gZGVwbG95UmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmluZy5qcy5tYXAiXSwibmFtZXMiOlsic2VyaWFsaXplRXJjNjQ5MlNpZ25hdHVyZSIsInZlcmlmeUVpcDEyNzFTaWduYXR1cmUiLCJ2ZXJpZnlIYXNoIiwiZ2V0Q29udHJhY3QiLCJlbmNvZGUiLCJyZWFkQ29udHJhY3QiLCJlbmNvZGVBYmlQYXJhbWV0ZXJzIiwiaXNDb250cmFjdERlcGxveWVkIiwiaGFzaE1lc3NhZ2UiLCJoYXNoVHlwZWREYXRhIiwicHJlcGFyZUNyZWF0ZUFjY291bnQiLCJzbWFydEFjY291bnRTaWduTWVzc2FnZSIsImFjY291bnRDb250cmFjdCIsImZhY3RvcnlDb250cmFjdCIsIm9wdGlvbnMiLCJtZXNzYWdlIiwib3JpZ2luYWxNc2dIYXNoIiwiaXM3MTJGYWN0b3J5IiwiY2hlY2tGb3I3MTJGYWN0b3J5Iiwic2lnIiwid3JhcHBlZE1lc3NhZ2VIYXNoIiwidHlwZSIsInBlcnNvbmFsQWNjb3VudCIsInNpZ25UeXBlZERhdGEiLCJkb21haW4iLCJuYW1lIiwidmVyc2lvbiIsImNoYWluSWQiLCJjaGFpbiIsImlkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJhZGRyZXNzIiwicHJpbWFyeVR5cGUiLCJ0eXBlcyIsIkFjY291bnRNZXNzYWdlIiwic2lnbk1lc3NhZ2UiLCJpc0RlcGxveWVkIiwiaXNWYWxpZCIsImhhc2giLCJzaWduYXR1cmUiLCJjb250cmFjdCIsIkVycm9yIiwiZGVwbG95VHgiLCJhZG1pbkFkZHJlc3MiLCJhY2NvdW50U2FsdCIsIm92ZXJyaWRlcyIsImNyZWF0ZUFjY291bnRPdmVycmlkZSIsImNyZWF0ZUFjY291bnQiLCJpbml0Q29kZSIsImVyYzY0OTJTaWciLCJkYXRhIiwiY2xpZW50Iiwic21hcnRBY2NvdW50U2lnblR5cGVkRGF0YSIsInR5cGVkRGF0YSIsImlzU2VsZlZlcmlmeWluZ0NvbnRyYWN0IiwidG9Mb3dlckNhc2UiLCJjb25maXJtQ29udHJhY3REZXBsb3ltZW50IiwiYXJncyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJ0aW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaW1wbGVtZW50YXRpb25BY2NvdW50IiwibWV0aG9kIiwicGFyYW1zIiwidGhlbiIsInJlcyIsImNhdGNoIiwiZGVwbG95U21hcnRBY2NvdW50Iiwic21hcnRBY2NvdW50Iiwic2VuZFRyYW5zYWN0aW9uIiwicHJlcGFyZVRyYW5zYWN0aW9uIiwiYWxsIiwiZHVtbXlUeCIsInRvIiwidmFsdWUiLCJnYXMiLCJkZXBsb3lSZXN1bHQiLCJ0cmFuc2FjdGlvbiIsImFjY291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/smart/lib/signing.js\n"));

/***/ })

}]);